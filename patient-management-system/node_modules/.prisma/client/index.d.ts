
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Patient
 * 
 */
export type Patient = $Result.DefaultSelection<Prisma.$PatientPayload>
/**
 * Model PatientHistory
 * 
 */
export type PatientHistory = $Result.DefaultSelection<Prisma.$PatientHistoryPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Queue
 * 
 */
export type Queue = $Result.DefaultSelection<Prisma.$QueuePayload>
/**
 * Model QueueEntry
 * 
 */
export type QueueEntry = $Result.DefaultSelection<Prisma.$QueueEntryPayload>
/**
 * Model DrugBrand
 * 
 */
export type DrugBrand = $Result.DefaultSelection<Prisma.$DrugBrandPayload>
/**
 * Model Drug
 * 
 */
export type Drug = $Result.DefaultSelection<Prisma.$DrugPayload>
/**
 * Model BufferLevel
 * 
 */
export type BufferLevel = $Result.DefaultSelection<Prisma.$BufferLevelPayload>
/**
 * Model Supplier
 * 
 */
export type Supplier = $Result.DefaultSelection<Prisma.$SupplierPayload>
/**
 * Model Batch
 * 
 */
export type Batch = $Result.DefaultSelection<Prisma.$BatchPayload>
/**
 * Model UnitConcentration
 * 
 */
export type UnitConcentration = $Result.DefaultSelection<Prisma.$UnitConcentrationPayload>
/**
 * Model Prescription
 * 
 */
export type Prescription = $Result.DefaultSelection<Prisma.$PrescriptionPayload>
/**
 * Model PrescriptionCharges
 * 
 */
export type PrescriptionCharges = $Result.DefaultSelection<Prisma.$PrescriptionChargesPayload>
/**
 * Model Vitals
 * 
 */
export type Vitals = $Result.DefaultSelection<Prisma.$VitalsPayload>
/**
 * Model PrescriptionVitals
 * 
 */
export type PrescriptionVitals = $Result.DefaultSelection<Prisma.$PrescriptionVitalsPayload>
/**
 * Model MedicalCertificate
 * 
 */
export type MedicalCertificate = $Result.DefaultSelection<Prisma.$MedicalCertificatePayload>
/**
 * Model USSReferral
 * 
 */
export type USSReferral = $Result.DefaultSelection<Prisma.$USSReferralPayload>
/**
 * Model ReferralLetter
 * 
 */
export type ReferralLetter = $Result.DefaultSelection<Prisma.$ReferralLetterPayload>
/**
 * Model OffRecordMeds
 * 
 */
export type OffRecordMeds = $Result.DefaultSelection<Prisma.$OffRecordMedsPayload>
/**
 * Model Issue
 * 
 */
export type Issue = $Result.DefaultSelection<Prisma.$IssuePayload>
/**
 * Model ReportParameter
 * 
 */
export type ReportParameter = $Result.DefaultSelection<Prisma.$ReportParameterPayload>
/**
 * Model ReportType
 * 
 */
export type ReportType = $Result.DefaultSelection<Prisma.$ReportTypePayload>
/**
 * Model PatientReport
 * 
 */
export type PatientReport = $Result.DefaultSelection<Prisma.$PatientReportPayload>
/**
 * Model ReportValue
 * 
 */
export type ReportValue = $Result.DefaultSelection<Prisma.$ReportValuePayload>
/**
 * Model StratergyHistory
 * 
 */
export type StratergyHistory = $Result.DefaultSelection<Prisma.$StratergyHistoryPayload>
/**
 * Model BatchHistory
 * 
 */
export type BatchHistory = $Result.DefaultSelection<Prisma.$BatchHistoryPayload>
/**
 * Model Charge
 * 
 */
export type Charge = $Result.DefaultSelection<Prisma.$ChargePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Gender: {
  MALE: 'MALE',
  FEMALE: 'FEMALE'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const Role: {
  DOCTOR: 'DOCTOR',
  NURSE: 'NURSE'
};

export type Role = (typeof Role)[keyof typeof Role]


export const QueueStatus: {
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED'
};

export type QueueStatus = (typeof QueueStatus)[keyof typeof QueueStatus]


export const VisitStatus: {
  PENDING: 'PENDING',
  PRESCRIBED: 'PRESCRIBED',
  COMPLETED: 'COMPLETED'
};

export type VisitStatus = (typeof VisitStatus)[keyof typeof VisitStatus]


export const DrugType: {
  TABLET: 'TABLET',
  CAPSULE: 'CAPSULE',
  SYRUP: 'SYRUP',
  EYE_DROP: 'EYE_DROP',
  EAR_DROP: 'EAR_DROP',
  NASAL_DROP: 'NASAL_DROP',
  CREAM: 'CREAM',
  OINTMENT: 'OINTMENT',
  GEL: 'GEL',
  LOTION: 'LOTION',
  INJECTION: 'INJECTION',
  INHALER: 'INHALER',
  SPRAY: 'SPRAY',
  LOZENGE: 'LOZENGE',
  SUPPOSITORY: 'SUPPOSITORY',
  PATCH: 'PATCH',
  POWDER: 'POWDER',
  SOLUTION: 'SOLUTION',
  SUSPENSION: 'SUSPENSION',
  GARGLE: 'GARGLE',
  MOUTHWASH: 'MOUTHWASH'
};

export type DrugType = (typeof DrugType)[keyof typeof DrugType]


export const BatchStatus: {
  AVAILABLE: 'AVAILABLE',
  EXPIRED: 'EXPIRED',
  COMPLETED: 'COMPLETED',
  QUALITY_FAILED: 'QUALITY_FAILED',
  DISPOSED: 'DISPOSED'
};

export type BatchStatus = (typeof BatchStatus)[keyof typeof BatchStatus]


export const IssuingStrategy: {
  TDS: 'TDS',
  BD: 'BD',
  OD: 'OD',
  QDS: 'QDS',
  SOS: 'SOS',
  NOCTE: 'NOCTE',
  MANE: 'MANE',
  VESPE: 'VESPE',
  NOON: 'NOON',
  WEEKLY: 'WEEKLY',
  OTHER: 'OTHER'
};

export type IssuingStrategy = (typeof IssuingStrategy)[keyof typeof IssuingStrategy]


export const MEAL: {
  BEFORE: 'BEFORE',
  AFTER: 'AFTER',
  WITH: 'WITH'
};

export type MEAL = (typeof MEAL)[keyof typeof MEAL]


export const PrescriptionStatus: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED'
};

export type PrescriptionStatus = (typeof PrescriptionStatus)[keyof typeof PrescriptionStatus]


export const MedicalCertificateStatus: {
  FIT: 'FIT',
  UNFIT: 'UNFIT'
};

export type MedicalCertificateStatus = (typeof MedicalCertificateStatus)[keyof typeof MedicalCertificateStatus]


export const PatientHistoryType: {
  ALLERGY: 'ALLERGY',
  MEDICAL: 'MEDICAL',
  SURGICAL: 'SURGICAL',
  FAMILY: 'FAMILY',
  SOCIAL: 'SOCIAL'
};

export type PatientHistoryType = (typeof PatientHistoryType)[keyof typeof PatientHistoryType]


export const VitalType: {
  NUMBER: 'NUMBER',
  TEXT: 'TEXT',
  DATE: 'DATE'
};

export type VitalType = (typeof VitalType)[keyof typeof VitalType]


export const ChargeType: {
  MEDICINE: 'MEDICINE',
  FIXED: 'FIXED',
  PERCENTAGE: 'PERCENTAGE',
  PROCEDURE: 'PROCEDURE',
  DISCOUNT: 'DISCOUNT'
};

export type ChargeType = (typeof ChargeType)[keyof typeof ChargeType]

}

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type QueueStatus = $Enums.QueueStatus

export const QueueStatus: typeof $Enums.QueueStatus

export type VisitStatus = $Enums.VisitStatus

export const VisitStatus: typeof $Enums.VisitStatus

export type DrugType = $Enums.DrugType

export const DrugType: typeof $Enums.DrugType

export type BatchStatus = $Enums.BatchStatus

export const BatchStatus: typeof $Enums.BatchStatus

export type IssuingStrategy = $Enums.IssuingStrategy

export const IssuingStrategy: typeof $Enums.IssuingStrategy

export type MEAL = $Enums.MEAL

export const MEAL: typeof $Enums.MEAL

export type PrescriptionStatus = $Enums.PrescriptionStatus

export const PrescriptionStatus: typeof $Enums.PrescriptionStatus

export type MedicalCertificateStatus = $Enums.MedicalCertificateStatus

export const MedicalCertificateStatus: typeof $Enums.MedicalCertificateStatus

export type PatientHistoryType = $Enums.PatientHistoryType

export const PatientHistoryType: typeof $Enums.PatientHistoryType

export type VitalType = $Enums.VitalType

export const VitalType: typeof $Enums.VitalType

export type ChargeType = $Enums.ChargeType

export const ChargeType: typeof $Enums.ChargeType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Patients
 * const patients = await prisma.patient.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Patients
   * const patients = await prisma.patient.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.patient`: Exposes CRUD operations for the **Patient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Patients
    * const patients = await prisma.patient.findMany()
    * ```
    */
  get patient(): Prisma.PatientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.patientHistory`: Exposes CRUD operations for the **PatientHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PatientHistories
    * const patientHistories = await prisma.patientHistory.findMany()
    * ```
    */
  get patientHistory(): Prisma.PatientHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.queue`: Exposes CRUD operations for the **Queue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Queues
    * const queues = await prisma.queue.findMany()
    * ```
    */
  get queue(): Prisma.QueueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.queueEntry`: Exposes CRUD operations for the **QueueEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QueueEntries
    * const queueEntries = await prisma.queueEntry.findMany()
    * ```
    */
  get queueEntry(): Prisma.QueueEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.drugBrand`: Exposes CRUD operations for the **DrugBrand** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DrugBrands
    * const drugBrands = await prisma.drugBrand.findMany()
    * ```
    */
  get drugBrand(): Prisma.DrugBrandDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.drug`: Exposes CRUD operations for the **Drug** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Drugs
    * const drugs = await prisma.drug.findMany()
    * ```
    */
  get drug(): Prisma.DrugDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bufferLevel`: Exposes CRUD operations for the **BufferLevel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BufferLevels
    * const bufferLevels = await prisma.bufferLevel.findMany()
    * ```
    */
  get bufferLevel(): Prisma.BufferLevelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.supplier`: Exposes CRUD operations for the **Supplier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Suppliers
    * const suppliers = await prisma.supplier.findMany()
    * ```
    */
  get supplier(): Prisma.SupplierDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.batch`: Exposes CRUD operations for the **Batch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Batches
    * const batches = await prisma.batch.findMany()
    * ```
    */
  get batch(): Prisma.BatchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.unitConcentration`: Exposes CRUD operations for the **UnitConcentration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UnitConcentrations
    * const unitConcentrations = await prisma.unitConcentration.findMany()
    * ```
    */
  get unitConcentration(): Prisma.UnitConcentrationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.prescription`: Exposes CRUD operations for the **Prescription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prescriptions
    * const prescriptions = await prisma.prescription.findMany()
    * ```
    */
  get prescription(): Prisma.PrescriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.prescriptionCharges`: Exposes CRUD operations for the **PrescriptionCharges** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PrescriptionCharges
    * const prescriptionCharges = await prisma.prescriptionCharges.findMany()
    * ```
    */
  get prescriptionCharges(): Prisma.PrescriptionChargesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vitals`: Exposes CRUD operations for the **Vitals** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vitals
    * const vitals = await prisma.vitals.findMany()
    * ```
    */
  get vitals(): Prisma.VitalsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.prescriptionVitals`: Exposes CRUD operations for the **PrescriptionVitals** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PrescriptionVitals
    * const prescriptionVitals = await prisma.prescriptionVitals.findMany()
    * ```
    */
  get prescriptionVitals(): Prisma.PrescriptionVitalsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.medicalCertificate`: Exposes CRUD operations for the **MedicalCertificate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MedicalCertificates
    * const medicalCertificates = await prisma.medicalCertificate.findMany()
    * ```
    */
  get medicalCertificate(): Prisma.MedicalCertificateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.uSSReferral`: Exposes CRUD operations for the **USSReferral** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more USSReferrals
    * const uSSReferrals = await prisma.uSSReferral.findMany()
    * ```
    */
  get uSSReferral(): Prisma.USSReferralDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.referralLetter`: Exposes CRUD operations for the **ReferralLetter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReferralLetters
    * const referralLetters = await prisma.referralLetter.findMany()
    * ```
    */
  get referralLetter(): Prisma.ReferralLetterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.offRecordMeds`: Exposes CRUD operations for the **OffRecordMeds** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OffRecordMeds
    * const offRecordMeds = await prisma.offRecordMeds.findMany()
    * ```
    */
  get offRecordMeds(): Prisma.OffRecordMedsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.issue`: Exposes CRUD operations for the **Issue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Issues
    * const issues = await prisma.issue.findMany()
    * ```
    */
  get issue(): Prisma.IssueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reportParameter`: Exposes CRUD operations for the **ReportParameter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReportParameters
    * const reportParameters = await prisma.reportParameter.findMany()
    * ```
    */
  get reportParameter(): Prisma.ReportParameterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reportType`: Exposes CRUD operations for the **ReportType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReportTypes
    * const reportTypes = await prisma.reportType.findMany()
    * ```
    */
  get reportType(): Prisma.ReportTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.patientReport`: Exposes CRUD operations for the **PatientReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PatientReports
    * const patientReports = await prisma.patientReport.findMany()
    * ```
    */
  get patientReport(): Prisma.PatientReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reportValue`: Exposes CRUD operations for the **ReportValue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReportValues
    * const reportValues = await prisma.reportValue.findMany()
    * ```
    */
  get reportValue(): Prisma.ReportValueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stratergyHistory`: Exposes CRUD operations for the **StratergyHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StratergyHistories
    * const stratergyHistories = await prisma.stratergyHistory.findMany()
    * ```
    */
  get stratergyHistory(): Prisma.StratergyHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.batchHistory`: Exposes CRUD operations for the **BatchHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BatchHistories
    * const batchHistories = await prisma.batchHistory.findMany()
    * ```
    */
  get batchHistory(): Prisma.BatchHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.charge`: Exposes CRUD operations for the **Charge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Charges
    * const charges = await prisma.charge.findMany()
    * ```
    */
  get charge(): Prisma.ChargeDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.5.0
   * Query Engine version: 173f8d54f8d52e692c7e27e72a88314ec7aeff60
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Patient: 'Patient',
    PatientHistory: 'PatientHistory',
    User: 'User',
    Queue: 'Queue',
    QueueEntry: 'QueueEntry',
    DrugBrand: 'DrugBrand',
    Drug: 'Drug',
    BufferLevel: 'BufferLevel',
    Supplier: 'Supplier',
    Batch: 'Batch',
    UnitConcentration: 'UnitConcentration',
    Prescription: 'Prescription',
    PrescriptionCharges: 'PrescriptionCharges',
    Vitals: 'Vitals',
    PrescriptionVitals: 'PrescriptionVitals',
    MedicalCertificate: 'MedicalCertificate',
    USSReferral: 'USSReferral',
    ReferralLetter: 'ReferralLetter',
    OffRecordMeds: 'OffRecordMeds',
    Issue: 'Issue',
    ReportParameter: 'ReportParameter',
    ReportType: 'ReportType',
    PatientReport: 'PatientReport',
    ReportValue: 'ReportValue',
    StratergyHistory: 'StratergyHistory',
    BatchHistory: 'BatchHistory',
    Charge: 'Charge'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "patient" | "patientHistory" | "user" | "queue" | "queueEntry" | "drugBrand" | "drug" | "bufferLevel" | "supplier" | "batch" | "unitConcentration" | "prescription" | "prescriptionCharges" | "vitals" | "prescriptionVitals" | "medicalCertificate" | "uSSReferral" | "referralLetter" | "offRecordMeds" | "issue" | "reportParameter" | "reportType" | "patientReport" | "reportValue" | "stratergyHistory" | "batchHistory" | "charge"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Patient: {
        payload: Prisma.$PatientPayload<ExtArgs>
        fields: Prisma.PatientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findFirst: {
            args: Prisma.PatientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findMany: {
            args: Prisma.PatientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          create: {
            args: Prisma.PatientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          createMany: {
            args: Prisma.PatientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PatientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          delete: {
            args: Prisma.PatientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          update: {
            args: Prisma.PatientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          deleteMany: {
            args: Prisma.PatientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PatientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PatientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          upsert: {
            args: Prisma.PatientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          aggregate: {
            args: Prisma.PatientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatient>
          }
          groupBy: {
            args: Prisma.PatientGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatientGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatientCountArgs<ExtArgs>
            result: $Utils.Optional<PatientCountAggregateOutputType> | number
          }
        }
      }
      PatientHistory: {
        payload: Prisma.$PatientHistoryPayload<ExtArgs>
        fields: Prisma.PatientHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatientHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatientHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientHistoryPayload>
          }
          findFirst: {
            args: Prisma.PatientHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatientHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientHistoryPayload>
          }
          findMany: {
            args: Prisma.PatientHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientHistoryPayload>[]
          }
          create: {
            args: Prisma.PatientHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientHistoryPayload>
          }
          createMany: {
            args: Prisma.PatientHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PatientHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientHistoryPayload>[]
          }
          delete: {
            args: Prisma.PatientHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientHistoryPayload>
          }
          update: {
            args: Prisma.PatientHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientHistoryPayload>
          }
          deleteMany: {
            args: Prisma.PatientHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PatientHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PatientHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientHistoryPayload>[]
          }
          upsert: {
            args: Prisma.PatientHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientHistoryPayload>
          }
          aggregate: {
            args: Prisma.PatientHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatientHistory>
          }
          groupBy: {
            args: Prisma.PatientHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatientHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatientHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<PatientHistoryCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Queue: {
        payload: Prisma.$QueuePayload<ExtArgs>
        fields: Prisma.QueueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QueueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QueueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueuePayload>
          }
          findFirst: {
            args: Prisma.QueueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QueueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueuePayload>
          }
          findMany: {
            args: Prisma.QueueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueuePayload>[]
          }
          create: {
            args: Prisma.QueueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueuePayload>
          }
          createMany: {
            args: Prisma.QueueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QueueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueuePayload>[]
          }
          delete: {
            args: Prisma.QueueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueuePayload>
          }
          update: {
            args: Prisma.QueueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueuePayload>
          }
          deleteMany: {
            args: Prisma.QueueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QueueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QueueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueuePayload>[]
          }
          upsert: {
            args: Prisma.QueueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueuePayload>
          }
          aggregate: {
            args: Prisma.QueueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQueue>
          }
          groupBy: {
            args: Prisma.QueueGroupByArgs<ExtArgs>
            result: $Utils.Optional<QueueGroupByOutputType>[]
          }
          count: {
            args: Prisma.QueueCountArgs<ExtArgs>
            result: $Utils.Optional<QueueCountAggregateOutputType> | number
          }
        }
      }
      QueueEntry: {
        payload: Prisma.$QueueEntryPayload<ExtArgs>
        fields: Prisma.QueueEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QueueEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QueueEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueEntryPayload>
          }
          findFirst: {
            args: Prisma.QueueEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QueueEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueEntryPayload>
          }
          findMany: {
            args: Prisma.QueueEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueEntryPayload>[]
          }
          create: {
            args: Prisma.QueueEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueEntryPayload>
          }
          createMany: {
            args: Prisma.QueueEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QueueEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueEntryPayload>[]
          }
          delete: {
            args: Prisma.QueueEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueEntryPayload>
          }
          update: {
            args: Prisma.QueueEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueEntryPayload>
          }
          deleteMany: {
            args: Prisma.QueueEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QueueEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QueueEntryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueEntryPayload>[]
          }
          upsert: {
            args: Prisma.QueueEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueEntryPayload>
          }
          aggregate: {
            args: Prisma.QueueEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQueueEntry>
          }
          groupBy: {
            args: Prisma.QueueEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<QueueEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.QueueEntryCountArgs<ExtArgs>
            result: $Utils.Optional<QueueEntryCountAggregateOutputType> | number
          }
        }
      }
      DrugBrand: {
        payload: Prisma.$DrugBrandPayload<ExtArgs>
        fields: Prisma.DrugBrandFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DrugBrandFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrugBrandPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DrugBrandFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrugBrandPayload>
          }
          findFirst: {
            args: Prisma.DrugBrandFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrugBrandPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DrugBrandFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrugBrandPayload>
          }
          findMany: {
            args: Prisma.DrugBrandFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrugBrandPayload>[]
          }
          create: {
            args: Prisma.DrugBrandCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrugBrandPayload>
          }
          createMany: {
            args: Prisma.DrugBrandCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DrugBrandCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrugBrandPayload>[]
          }
          delete: {
            args: Prisma.DrugBrandDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrugBrandPayload>
          }
          update: {
            args: Prisma.DrugBrandUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrugBrandPayload>
          }
          deleteMany: {
            args: Prisma.DrugBrandDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DrugBrandUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DrugBrandUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrugBrandPayload>[]
          }
          upsert: {
            args: Prisma.DrugBrandUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrugBrandPayload>
          }
          aggregate: {
            args: Prisma.DrugBrandAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDrugBrand>
          }
          groupBy: {
            args: Prisma.DrugBrandGroupByArgs<ExtArgs>
            result: $Utils.Optional<DrugBrandGroupByOutputType>[]
          }
          count: {
            args: Prisma.DrugBrandCountArgs<ExtArgs>
            result: $Utils.Optional<DrugBrandCountAggregateOutputType> | number
          }
        }
      }
      Drug: {
        payload: Prisma.$DrugPayload<ExtArgs>
        fields: Prisma.DrugFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DrugFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrugPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DrugFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrugPayload>
          }
          findFirst: {
            args: Prisma.DrugFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrugPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DrugFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrugPayload>
          }
          findMany: {
            args: Prisma.DrugFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrugPayload>[]
          }
          create: {
            args: Prisma.DrugCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrugPayload>
          }
          createMany: {
            args: Prisma.DrugCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DrugCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrugPayload>[]
          }
          delete: {
            args: Prisma.DrugDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrugPayload>
          }
          update: {
            args: Prisma.DrugUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrugPayload>
          }
          deleteMany: {
            args: Prisma.DrugDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DrugUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DrugUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrugPayload>[]
          }
          upsert: {
            args: Prisma.DrugUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrugPayload>
          }
          aggregate: {
            args: Prisma.DrugAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDrug>
          }
          groupBy: {
            args: Prisma.DrugGroupByArgs<ExtArgs>
            result: $Utils.Optional<DrugGroupByOutputType>[]
          }
          count: {
            args: Prisma.DrugCountArgs<ExtArgs>
            result: $Utils.Optional<DrugCountAggregateOutputType> | number
          }
        }
      }
      BufferLevel: {
        payload: Prisma.$BufferLevelPayload<ExtArgs>
        fields: Prisma.BufferLevelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BufferLevelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BufferLevelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BufferLevelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BufferLevelPayload>
          }
          findFirst: {
            args: Prisma.BufferLevelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BufferLevelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BufferLevelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BufferLevelPayload>
          }
          findMany: {
            args: Prisma.BufferLevelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BufferLevelPayload>[]
          }
          create: {
            args: Prisma.BufferLevelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BufferLevelPayload>
          }
          createMany: {
            args: Prisma.BufferLevelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BufferLevelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BufferLevelPayload>[]
          }
          delete: {
            args: Prisma.BufferLevelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BufferLevelPayload>
          }
          update: {
            args: Prisma.BufferLevelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BufferLevelPayload>
          }
          deleteMany: {
            args: Prisma.BufferLevelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BufferLevelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BufferLevelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BufferLevelPayload>[]
          }
          upsert: {
            args: Prisma.BufferLevelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BufferLevelPayload>
          }
          aggregate: {
            args: Prisma.BufferLevelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBufferLevel>
          }
          groupBy: {
            args: Prisma.BufferLevelGroupByArgs<ExtArgs>
            result: $Utils.Optional<BufferLevelGroupByOutputType>[]
          }
          count: {
            args: Prisma.BufferLevelCountArgs<ExtArgs>
            result: $Utils.Optional<BufferLevelCountAggregateOutputType> | number
          }
        }
      }
      Supplier: {
        payload: Prisma.$SupplierPayload<ExtArgs>
        fields: Prisma.SupplierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupplierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupplierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findFirst: {
            args: Prisma.SupplierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupplierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findMany: {
            args: Prisma.SupplierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          create: {
            args: Prisma.SupplierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          createMany: {
            args: Prisma.SupplierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupplierCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          delete: {
            args: Prisma.SupplierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          update: {
            args: Prisma.SupplierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          deleteMany: {
            args: Prisma.SupplierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupplierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SupplierUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          upsert: {
            args: Prisma.SupplierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          aggregate: {
            args: Prisma.SupplierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupplier>
          }
          groupBy: {
            args: Prisma.SupplierGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupplierGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupplierCountArgs<ExtArgs>
            result: $Utils.Optional<SupplierCountAggregateOutputType> | number
          }
        }
      }
      Batch: {
        payload: Prisma.$BatchPayload<ExtArgs>
        fields: Prisma.BatchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BatchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BatchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>
          }
          findFirst: {
            args: Prisma.BatchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BatchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>
          }
          findMany: {
            args: Prisma.BatchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>[]
          }
          create: {
            args: Prisma.BatchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>
          }
          createMany: {
            args: Prisma.BatchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BatchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>[]
          }
          delete: {
            args: Prisma.BatchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>
          }
          update: {
            args: Prisma.BatchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>
          }
          deleteMany: {
            args: Prisma.BatchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BatchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BatchUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>[]
          }
          upsert: {
            args: Prisma.BatchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>
          }
          aggregate: {
            args: Prisma.BatchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBatch>
          }
          groupBy: {
            args: Prisma.BatchGroupByArgs<ExtArgs>
            result: $Utils.Optional<BatchGroupByOutputType>[]
          }
          count: {
            args: Prisma.BatchCountArgs<ExtArgs>
            result: $Utils.Optional<BatchCountAggregateOutputType> | number
          }
        }
      }
      UnitConcentration: {
        payload: Prisma.$UnitConcentrationPayload<ExtArgs>
        fields: Prisma.UnitConcentrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitConcentrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitConcentrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitConcentrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitConcentrationPayload>
          }
          findFirst: {
            args: Prisma.UnitConcentrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitConcentrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitConcentrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitConcentrationPayload>
          }
          findMany: {
            args: Prisma.UnitConcentrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitConcentrationPayload>[]
          }
          create: {
            args: Prisma.UnitConcentrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitConcentrationPayload>
          }
          createMany: {
            args: Prisma.UnitConcentrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UnitConcentrationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitConcentrationPayload>[]
          }
          delete: {
            args: Prisma.UnitConcentrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitConcentrationPayload>
          }
          update: {
            args: Prisma.UnitConcentrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitConcentrationPayload>
          }
          deleteMany: {
            args: Prisma.UnitConcentrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnitConcentrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UnitConcentrationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitConcentrationPayload>[]
          }
          upsert: {
            args: Prisma.UnitConcentrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitConcentrationPayload>
          }
          aggregate: {
            args: Prisma.UnitConcentrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnitConcentration>
          }
          groupBy: {
            args: Prisma.UnitConcentrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnitConcentrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitConcentrationCountArgs<ExtArgs>
            result: $Utils.Optional<UnitConcentrationCountAggregateOutputType> | number
          }
        }
      }
      Prescription: {
        payload: Prisma.$PrescriptionPayload<ExtArgs>
        fields: Prisma.PrescriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PrescriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrescriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          findFirst: {
            args: Prisma.PrescriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrescriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          findMany: {
            args: Prisma.PrescriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>[]
          }
          create: {
            args: Prisma.PrescriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          createMany: {
            args: Prisma.PrescriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PrescriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>[]
          }
          delete: {
            args: Prisma.PrescriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          update: {
            args: Prisma.PrescriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          deleteMany: {
            args: Prisma.PrescriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PrescriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PrescriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>[]
          }
          upsert: {
            args: Prisma.PrescriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          aggregate: {
            args: Prisma.PrescriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrescription>
          }
          groupBy: {
            args: Prisma.PrescriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrescriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PrescriptionCountArgs<ExtArgs>
            result: $Utils.Optional<PrescriptionCountAggregateOutputType> | number
          }
        }
      }
      PrescriptionCharges: {
        payload: Prisma.$PrescriptionChargesPayload<ExtArgs>
        fields: Prisma.PrescriptionChargesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PrescriptionChargesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionChargesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrescriptionChargesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionChargesPayload>
          }
          findFirst: {
            args: Prisma.PrescriptionChargesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionChargesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrescriptionChargesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionChargesPayload>
          }
          findMany: {
            args: Prisma.PrescriptionChargesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionChargesPayload>[]
          }
          create: {
            args: Prisma.PrescriptionChargesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionChargesPayload>
          }
          createMany: {
            args: Prisma.PrescriptionChargesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PrescriptionChargesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionChargesPayload>[]
          }
          delete: {
            args: Prisma.PrescriptionChargesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionChargesPayload>
          }
          update: {
            args: Prisma.PrescriptionChargesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionChargesPayload>
          }
          deleteMany: {
            args: Prisma.PrescriptionChargesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PrescriptionChargesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PrescriptionChargesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionChargesPayload>[]
          }
          upsert: {
            args: Prisma.PrescriptionChargesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionChargesPayload>
          }
          aggregate: {
            args: Prisma.PrescriptionChargesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrescriptionCharges>
          }
          groupBy: {
            args: Prisma.PrescriptionChargesGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrescriptionChargesGroupByOutputType>[]
          }
          count: {
            args: Prisma.PrescriptionChargesCountArgs<ExtArgs>
            result: $Utils.Optional<PrescriptionChargesCountAggregateOutputType> | number
          }
        }
      }
      Vitals: {
        payload: Prisma.$VitalsPayload<ExtArgs>
        fields: Prisma.VitalsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VitalsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VitalsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalsPayload>
          }
          findFirst: {
            args: Prisma.VitalsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VitalsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalsPayload>
          }
          findMany: {
            args: Prisma.VitalsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalsPayload>[]
          }
          create: {
            args: Prisma.VitalsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalsPayload>
          }
          createMany: {
            args: Prisma.VitalsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VitalsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalsPayload>[]
          }
          delete: {
            args: Prisma.VitalsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalsPayload>
          }
          update: {
            args: Prisma.VitalsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalsPayload>
          }
          deleteMany: {
            args: Prisma.VitalsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VitalsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VitalsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalsPayload>[]
          }
          upsert: {
            args: Prisma.VitalsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalsPayload>
          }
          aggregate: {
            args: Prisma.VitalsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVitals>
          }
          groupBy: {
            args: Prisma.VitalsGroupByArgs<ExtArgs>
            result: $Utils.Optional<VitalsGroupByOutputType>[]
          }
          count: {
            args: Prisma.VitalsCountArgs<ExtArgs>
            result: $Utils.Optional<VitalsCountAggregateOutputType> | number
          }
        }
      }
      PrescriptionVitals: {
        payload: Prisma.$PrescriptionVitalsPayload<ExtArgs>
        fields: Prisma.PrescriptionVitalsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PrescriptionVitalsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionVitalsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrescriptionVitalsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionVitalsPayload>
          }
          findFirst: {
            args: Prisma.PrescriptionVitalsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionVitalsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrescriptionVitalsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionVitalsPayload>
          }
          findMany: {
            args: Prisma.PrescriptionVitalsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionVitalsPayload>[]
          }
          create: {
            args: Prisma.PrescriptionVitalsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionVitalsPayload>
          }
          createMany: {
            args: Prisma.PrescriptionVitalsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PrescriptionVitalsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionVitalsPayload>[]
          }
          delete: {
            args: Prisma.PrescriptionVitalsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionVitalsPayload>
          }
          update: {
            args: Prisma.PrescriptionVitalsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionVitalsPayload>
          }
          deleteMany: {
            args: Prisma.PrescriptionVitalsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PrescriptionVitalsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PrescriptionVitalsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionVitalsPayload>[]
          }
          upsert: {
            args: Prisma.PrescriptionVitalsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionVitalsPayload>
          }
          aggregate: {
            args: Prisma.PrescriptionVitalsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrescriptionVitals>
          }
          groupBy: {
            args: Prisma.PrescriptionVitalsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrescriptionVitalsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PrescriptionVitalsCountArgs<ExtArgs>
            result: $Utils.Optional<PrescriptionVitalsCountAggregateOutputType> | number
          }
        }
      }
      MedicalCertificate: {
        payload: Prisma.$MedicalCertificatePayload<ExtArgs>
        fields: Prisma.MedicalCertificateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MedicalCertificateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalCertificatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MedicalCertificateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalCertificatePayload>
          }
          findFirst: {
            args: Prisma.MedicalCertificateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalCertificatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MedicalCertificateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalCertificatePayload>
          }
          findMany: {
            args: Prisma.MedicalCertificateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalCertificatePayload>[]
          }
          create: {
            args: Prisma.MedicalCertificateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalCertificatePayload>
          }
          createMany: {
            args: Prisma.MedicalCertificateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MedicalCertificateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalCertificatePayload>[]
          }
          delete: {
            args: Prisma.MedicalCertificateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalCertificatePayload>
          }
          update: {
            args: Prisma.MedicalCertificateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalCertificatePayload>
          }
          deleteMany: {
            args: Prisma.MedicalCertificateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MedicalCertificateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MedicalCertificateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalCertificatePayload>[]
          }
          upsert: {
            args: Prisma.MedicalCertificateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalCertificatePayload>
          }
          aggregate: {
            args: Prisma.MedicalCertificateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedicalCertificate>
          }
          groupBy: {
            args: Prisma.MedicalCertificateGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicalCertificateGroupByOutputType>[]
          }
          count: {
            args: Prisma.MedicalCertificateCountArgs<ExtArgs>
            result: $Utils.Optional<MedicalCertificateCountAggregateOutputType> | number
          }
        }
      }
      USSReferral: {
        payload: Prisma.$USSReferralPayload<ExtArgs>
        fields: Prisma.USSReferralFieldRefs
        operations: {
          findUnique: {
            args: Prisma.USSReferralFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$USSReferralPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.USSReferralFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$USSReferralPayload>
          }
          findFirst: {
            args: Prisma.USSReferralFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$USSReferralPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.USSReferralFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$USSReferralPayload>
          }
          findMany: {
            args: Prisma.USSReferralFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$USSReferralPayload>[]
          }
          create: {
            args: Prisma.USSReferralCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$USSReferralPayload>
          }
          createMany: {
            args: Prisma.USSReferralCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.USSReferralCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$USSReferralPayload>[]
          }
          delete: {
            args: Prisma.USSReferralDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$USSReferralPayload>
          }
          update: {
            args: Prisma.USSReferralUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$USSReferralPayload>
          }
          deleteMany: {
            args: Prisma.USSReferralDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.USSReferralUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.USSReferralUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$USSReferralPayload>[]
          }
          upsert: {
            args: Prisma.USSReferralUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$USSReferralPayload>
          }
          aggregate: {
            args: Prisma.USSReferralAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUSSReferral>
          }
          groupBy: {
            args: Prisma.USSReferralGroupByArgs<ExtArgs>
            result: $Utils.Optional<USSReferralGroupByOutputType>[]
          }
          count: {
            args: Prisma.USSReferralCountArgs<ExtArgs>
            result: $Utils.Optional<USSReferralCountAggregateOutputType> | number
          }
        }
      }
      ReferralLetter: {
        payload: Prisma.$ReferralLetterPayload<ExtArgs>
        fields: Prisma.ReferralLetterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReferralLetterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralLetterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReferralLetterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralLetterPayload>
          }
          findFirst: {
            args: Prisma.ReferralLetterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralLetterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReferralLetterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralLetterPayload>
          }
          findMany: {
            args: Prisma.ReferralLetterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralLetterPayload>[]
          }
          create: {
            args: Prisma.ReferralLetterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralLetterPayload>
          }
          createMany: {
            args: Prisma.ReferralLetterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReferralLetterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralLetterPayload>[]
          }
          delete: {
            args: Prisma.ReferralLetterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralLetterPayload>
          }
          update: {
            args: Prisma.ReferralLetterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralLetterPayload>
          }
          deleteMany: {
            args: Prisma.ReferralLetterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReferralLetterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReferralLetterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralLetterPayload>[]
          }
          upsert: {
            args: Prisma.ReferralLetterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralLetterPayload>
          }
          aggregate: {
            args: Prisma.ReferralLetterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReferralLetter>
          }
          groupBy: {
            args: Prisma.ReferralLetterGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReferralLetterGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReferralLetterCountArgs<ExtArgs>
            result: $Utils.Optional<ReferralLetterCountAggregateOutputType> | number
          }
        }
      }
      OffRecordMeds: {
        payload: Prisma.$OffRecordMedsPayload<ExtArgs>
        fields: Prisma.OffRecordMedsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OffRecordMedsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OffRecordMedsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OffRecordMedsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OffRecordMedsPayload>
          }
          findFirst: {
            args: Prisma.OffRecordMedsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OffRecordMedsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OffRecordMedsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OffRecordMedsPayload>
          }
          findMany: {
            args: Prisma.OffRecordMedsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OffRecordMedsPayload>[]
          }
          create: {
            args: Prisma.OffRecordMedsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OffRecordMedsPayload>
          }
          createMany: {
            args: Prisma.OffRecordMedsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OffRecordMedsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OffRecordMedsPayload>[]
          }
          delete: {
            args: Prisma.OffRecordMedsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OffRecordMedsPayload>
          }
          update: {
            args: Prisma.OffRecordMedsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OffRecordMedsPayload>
          }
          deleteMany: {
            args: Prisma.OffRecordMedsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OffRecordMedsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OffRecordMedsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OffRecordMedsPayload>[]
          }
          upsert: {
            args: Prisma.OffRecordMedsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OffRecordMedsPayload>
          }
          aggregate: {
            args: Prisma.OffRecordMedsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOffRecordMeds>
          }
          groupBy: {
            args: Prisma.OffRecordMedsGroupByArgs<ExtArgs>
            result: $Utils.Optional<OffRecordMedsGroupByOutputType>[]
          }
          count: {
            args: Prisma.OffRecordMedsCountArgs<ExtArgs>
            result: $Utils.Optional<OffRecordMedsCountAggregateOutputType> | number
          }
        }
      }
      Issue: {
        payload: Prisma.$IssuePayload<ExtArgs>
        fields: Prisma.IssueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IssueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IssueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssuePayload>
          }
          findFirst: {
            args: Prisma.IssueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IssueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssuePayload>
          }
          findMany: {
            args: Prisma.IssueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssuePayload>[]
          }
          create: {
            args: Prisma.IssueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssuePayload>
          }
          createMany: {
            args: Prisma.IssueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IssueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssuePayload>[]
          }
          delete: {
            args: Prisma.IssueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssuePayload>
          }
          update: {
            args: Prisma.IssueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssuePayload>
          }
          deleteMany: {
            args: Prisma.IssueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IssueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IssueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssuePayload>[]
          }
          upsert: {
            args: Prisma.IssueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssuePayload>
          }
          aggregate: {
            args: Prisma.IssueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIssue>
          }
          groupBy: {
            args: Prisma.IssueGroupByArgs<ExtArgs>
            result: $Utils.Optional<IssueGroupByOutputType>[]
          }
          count: {
            args: Prisma.IssueCountArgs<ExtArgs>
            result: $Utils.Optional<IssueCountAggregateOutputType> | number
          }
        }
      }
      ReportParameter: {
        payload: Prisma.$ReportParameterPayload<ExtArgs>
        fields: Prisma.ReportParameterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportParameterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportParameterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportParameterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportParameterPayload>
          }
          findFirst: {
            args: Prisma.ReportParameterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportParameterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportParameterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportParameterPayload>
          }
          findMany: {
            args: Prisma.ReportParameterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportParameterPayload>[]
          }
          create: {
            args: Prisma.ReportParameterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportParameterPayload>
          }
          createMany: {
            args: Prisma.ReportParameterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReportParameterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportParameterPayload>[]
          }
          delete: {
            args: Prisma.ReportParameterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportParameterPayload>
          }
          update: {
            args: Prisma.ReportParameterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportParameterPayload>
          }
          deleteMany: {
            args: Prisma.ReportParameterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportParameterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReportParameterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportParameterPayload>[]
          }
          upsert: {
            args: Prisma.ReportParameterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportParameterPayload>
          }
          aggregate: {
            args: Prisma.ReportParameterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReportParameter>
          }
          groupBy: {
            args: Prisma.ReportParameterGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportParameterGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportParameterCountArgs<ExtArgs>
            result: $Utils.Optional<ReportParameterCountAggregateOutputType> | number
          }
        }
      }
      ReportType: {
        payload: Prisma.$ReportTypePayload<ExtArgs>
        fields: Prisma.ReportTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTypePayload>
          }
          findFirst: {
            args: Prisma.ReportTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTypePayload>
          }
          findMany: {
            args: Prisma.ReportTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTypePayload>[]
          }
          create: {
            args: Prisma.ReportTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTypePayload>
          }
          createMany: {
            args: Prisma.ReportTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReportTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTypePayload>[]
          }
          delete: {
            args: Prisma.ReportTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTypePayload>
          }
          update: {
            args: Prisma.ReportTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTypePayload>
          }
          deleteMany: {
            args: Prisma.ReportTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReportTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTypePayload>[]
          }
          upsert: {
            args: Prisma.ReportTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTypePayload>
          }
          aggregate: {
            args: Prisma.ReportTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReportType>
          }
          groupBy: {
            args: Prisma.ReportTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportTypeCountArgs<ExtArgs>
            result: $Utils.Optional<ReportTypeCountAggregateOutputType> | number
          }
        }
      }
      PatientReport: {
        payload: Prisma.$PatientReportPayload<ExtArgs>
        fields: Prisma.PatientReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatientReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatientReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientReportPayload>
          }
          findFirst: {
            args: Prisma.PatientReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatientReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientReportPayload>
          }
          findMany: {
            args: Prisma.PatientReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientReportPayload>[]
          }
          create: {
            args: Prisma.PatientReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientReportPayload>
          }
          createMany: {
            args: Prisma.PatientReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PatientReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientReportPayload>[]
          }
          delete: {
            args: Prisma.PatientReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientReportPayload>
          }
          update: {
            args: Prisma.PatientReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientReportPayload>
          }
          deleteMany: {
            args: Prisma.PatientReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PatientReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PatientReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientReportPayload>[]
          }
          upsert: {
            args: Prisma.PatientReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientReportPayload>
          }
          aggregate: {
            args: Prisma.PatientReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatientReport>
          }
          groupBy: {
            args: Prisma.PatientReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatientReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatientReportCountArgs<ExtArgs>
            result: $Utils.Optional<PatientReportCountAggregateOutputType> | number
          }
        }
      }
      ReportValue: {
        payload: Prisma.$ReportValuePayload<ExtArgs>
        fields: Prisma.ReportValueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportValueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportValuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportValueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportValuePayload>
          }
          findFirst: {
            args: Prisma.ReportValueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportValuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportValueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportValuePayload>
          }
          findMany: {
            args: Prisma.ReportValueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportValuePayload>[]
          }
          create: {
            args: Prisma.ReportValueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportValuePayload>
          }
          createMany: {
            args: Prisma.ReportValueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReportValueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportValuePayload>[]
          }
          delete: {
            args: Prisma.ReportValueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportValuePayload>
          }
          update: {
            args: Prisma.ReportValueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportValuePayload>
          }
          deleteMany: {
            args: Prisma.ReportValueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportValueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReportValueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportValuePayload>[]
          }
          upsert: {
            args: Prisma.ReportValueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportValuePayload>
          }
          aggregate: {
            args: Prisma.ReportValueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReportValue>
          }
          groupBy: {
            args: Prisma.ReportValueGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportValueGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportValueCountArgs<ExtArgs>
            result: $Utils.Optional<ReportValueCountAggregateOutputType> | number
          }
        }
      }
      StratergyHistory: {
        payload: Prisma.$StratergyHistoryPayload<ExtArgs>
        fields: Prisma.StratergyHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StratergyHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StratergyHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StratergyHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StratergyHistoryPayload>
          }
          findFirst: {
            args: Prisma.StratergyHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StratergyHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StratergyHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StratergyHistoryPayload>
          }
          findMany: {
            args: Prisma.StratergyHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StratergyHistoryPayload>[]
          }
          create: {
            args: Prisma.StratergyHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StratergyHistoryPayload>
          }
          createMany: {
            args: Prisma.StratergyHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StratergyHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StratergyHistoryPayload>[]
          }
          delete: {
            args: Prisma.StratergyHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StratergyHistoryPayload>
          }
          update: {
            args: Prisma.StratergyHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StratergyHistoryPayload>
          }
          deleteMany: {
            args: Prisma.StratergyHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StratergyHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StratergyHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StratergyHistoryPayload>[]
          }
          upsert: {
            args: Prisma.StratergyHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StratergyHistoryPayload>
          }
          aggregate: {
            args: Prisma.StratergyHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStratergyHistory>
          }
          groupBy: {
            args: Prisma.StratergyHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<StratergyHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.StratergyHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<StratergyHistoryCountAggregateOutputType> | number
          }
        }
      }
      BatchHistory: {
        payload: Prisma.$BatchHistoryPayload<ExtArgs>
        fields: Prisma.BatchHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BatchHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BatchHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchHistoryPayload>
          }
          findFirst: {
            args: Prisma.BatchHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BatchHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchHistoryPayload>
          }
          findMany: {
            args: Prisma.BatchHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchHistoryPayload>[]
          }
          create: {
            args: Prisma.BatchHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchHistoryPayload>
          }
          createMany: {
            args: Prisma.BatchHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BatchHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchHistoryPayload>[]
          }
          delete: {
            args: Prisma.BatchHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchHistoryPayload>
          }
          update: {
            args: Prisma.BatchHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchHistoryPayload>
          }
          deleteMany: {
            args: Prisma.BatchHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BatchHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BatchHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchHistoryPayload>[]
          }
          upsert: {
            args: Prisma.BatchHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchHistoryPayload>
          }
          aggregate: {
            args: Prisma.BatchHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBatchHistory>
          }
          groupBy: {
            args: Prisma.BatchHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<BatchHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.BatchHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<BatchHistoryCountAggregateOutputType> | number
          }
        }
      }
      Charge: {
        payload: Prisma.$ChargePayload<ExtArgs>
        fields: Prisma.ChargeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChargeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChargePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChargeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChargePayload>
          }
          findFirst: {
            args: Prisma.ChargeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChargePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChargeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChargePayload>
          }
          findMany: {
            args: Prisma.ChargeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChargePayload>[]
          }
          create: {
            args: Prisma.ChargeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChargePayload>
          }
          createMany: {
            args: Prisma.ChargeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChargeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChargePayload>[]
          }
          delete: {
            args: Prisma.ChargeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChargePayload>
          }
          update: {
            args: Prisma.ChargeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChargePayload>
          }
          deleteMany: {
            args: Prisma.ChargeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChargeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChargeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChargePayload>[]
          }
          upsert: {
            args: Prisma.ChargeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChargePayload>
          }
          aggregate: {
            args: Prisma.ChargeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCharge>
          }
          groupBy: {
            args: Prisma.ChargeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChargeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChargeCountArgs<ExtArgs>
            result: $Utils.Optional<ChargeCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    patient?: PatientOmit
    patientHistory?: PatientHistoryOmit
    user?: UserOmit
    queue?: QueueOmit
    queueEntry?: QueueEntryOmit
    drugBrand?: DrugBrandOmit
    drug?: DrugOmit
    bufferLevel?: BufferLevelOmit
    supplier?: SupplierOmit
    batch?: BatchOmit
    unitConcentration?: UnitConcentrationOmit
    prescription?: PrescriptionOmit
    prescriptionCharges?: PrescriptionChargesOmit
    vitals?: VitalsOmit
    prescriptionVitals?: PrescriptionVitalsOmit
    medicalCertificate?: MedicalCertificateOmit
    uSSReferral?: USSReferralOmit
    referralLetter?: ReferralLetterOmit
    offRecordMeds?: OffRecordMedsOmit
    issue?: IssueOmit
    reportParameter?: ReportParameterOmit
    reportType?: ReportTypeOmit
    patientReport?: PatientReportOmit
    reportValue?: ReportValueOmit
    stratergyHistory?: StratergyHistoryOmit
    batchHistory?: BatchHistoryOmit
    charge?: ChargeOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type PatientCountOutputType
   */

  export type PatientCountOutputType = {
    medicalCert: number
    PatientHistory: number
    reports: number
    prescription: number
    queueEntry: number
    USSReferral: number
    referralLetters: number
  }

  export type PatientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicalCert?: boolean | PatientCountOutputTypeCountMedicalCertArgs
    PatientHistory?: boolean | PatientCountOutputTypeCountPatientHistoryArgs
    reports?: boolean | PatientCountOutputTypeCountReportsArgs
    prescription?: boolean | PatientCountOutputTypeCountPrescriptionArgs
    queueEntry?: boolean | PatientCountOutputTypeCountQueueEntryArgs
    USSReferral?: boolean | PatientCountOutputTypeCountUSSReferralArgs
    referralLetters?: boolean | PatientCountOutputTypeCountReferralLettersArgs
  }

  // Custom InputTypes
  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientCountOutputType
     */
    select?: PatientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountMedicalCertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicalCertificateWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountPatientHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientHistoryWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientReportWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountPrescriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountQueueEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QueueEntryWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountUSSReferralArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: USSReferralWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountReferralLettersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralLetterWhereInput
  }


  /**
   * Count Type QueueCountOutputType
   */

  export type QueueCountOutputType = {
    entries: number
  }

  export type QueueCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entries?: boolean | QueueCountOutputTypeCountEntriesArgs
  }

  // Custom InputTypes
  /**
   * QueueCountOutputType without action
   */
  export type QueueCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueCountOutputType
     */
    select?: QueueCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QueueCountOutputType without action
   */
  export type QueueCountOutputTypeCountEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QueueEntryWhereInput
  }


  /**
   * Count Type DrugBrandCountOutputType
   */

  export type DrugBrandCountOutputType = {
    Batch: number
    BatchHistory: number
    Issue: number
  }

  export type DrugBrandCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Batch?: boolean | DrugBrandCountOutputTypeCountBatchArgs
    BatchHistory?: boolean | DrugBrandCountOutputTypeCountBatchHistoryArgs
    Issue?: boolean | DrugBrandCountOutputTypeCountIssueArgs
  }

  // Custom InputTypes
  /**
   * DrugBrandCountOutputType without action
   */
  export type DrugBrandCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrugBrandCountOutputType
     */
    select?: DrugBrandCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DrugBrandCountOutputType without action
   */
  export type DrugBrandCountOutputTypeCountBatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchWhereInput
  }

  /**
   * DrugBrandCountOutputType without action
   */
  export type DrugBrandCountOutputTypeCountBatchHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchHistoryWhereInput
  }

  /**
   * DrugBrandCountOutputType without action
   */
  export type DrugBrandCountOutputTypeCountIssueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IssueWhereInput
  }


  /**
   * Count Type DrugCountOutputType
   */

  export type DrugCountOutputType = {
    batch: number
    BatchHistory: number
    Issue: number
    bufferLevels: number
  }

  export type DrugCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batch?: boolean | DrugCountOutputTypeCountBatchArgs
    BatchHistory?: boolean | DrugCountOutputTypeCountBatchHistoryArgs
    Issue?: boolean | DrugCountOutputTypeCountIssueArgs
    bufferLevels?: boolean | DrugCountOutputTypeCountBufferLevelsArgs
  }

  // Custom InputTypes
  /**
   * DrugCountOutputType without action
   */
  export type DrugCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrugCountOutputType
     */
    select?: DrugCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DrugCountOutputType without action
   */
  export type DrugCountOutputTypeCountBatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchWhereInput
  }

  /**
   * DrugCountOutputType without action
   */
  export type DrugCountOutputTypeCountBatchHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchHistoryWhereInput
  }

  /**
   * DrugCountOutputType without action
   */
  export type DrugCountOutputTypeCountIssueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IssueWhereInput
  }

  /**
   * DrugCountOutputType without action
   */
  export type DrugCountOutputTypeCountBufferLevelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BufferLevelWhereInput
  }


  /**
   * Count Type SupplierCountOutputType
   */

  export type SupplierCountOutputType = {
    batches: number
  }

  export type SupplierCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batches?: boolean | SupplierCountOutputTypeCountBatchesArgs
  }

  // Custom InputTypes
  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCountOutputType
     */
    select?: SupplierCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountBatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchWhereInput
  }


  /**
   * Count Type BatchCountOutputType
   */

  export type BatchCountOutputType = {
    BatchHistory: number
    Issue: number
  }

  export type BatchCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BatchHistory?: boolean | BatchCountOutputTypeCountBatchHistoryArgs
    Issue?: boolean | BatchCountOutputTypeCountIssueArgs
  }

  // Custom InputTypes
  /**
   * BatchCountOutputType without action
   */
  export type BatchCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchCountOutputType
     */
    select?: BatchCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BatchCountOutputType without action
   */
  export type BatchCountOutputTypeCountBatchHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchHistoryWhereInput
  }

  /**
   * BatchCountOutputType without action
   */
  export type BatchCountOutputTypeCountIssueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IssueWhereInput
  }


  /**
   * Count Type UnitConcentrationCountOutputType
   */

  export type UnitConcentrationCountOutputType = {
    Batch: number
    BatchHistory: number
    Issue: number
    BufferLevel: number
  }

  export type UnitConcentrationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Batch?: boolean | UnitConcentrationCountOutputTypeCountBatchArgs
    BatchHistory?: boolean | UnitConcentrationCountOutputTypeCountBatchHistoryArgs
    Issue?: boolean | UnitConcentrationCountOutputTypeCountIssueArgs
    BufferLevel?: boolean | UnitConcentrationCountOutputTypeCountBufferLevelArgs
  }

  // Custom InputTypes
  /**
   * UnitConcentrationCountOutputType without action
   */
  export type UnitConcentrationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitConcentrationCountOutputType
     */
    select?: UnitConcentrationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UnitConcentrationCountOutputType without action
   */
  export type UnitConcentrationCountOutputTypeCountBatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchWhereInput
  }

  /**
   * UnitConcentrationCountOutputType without action
   */
  export type UnitConcentrationCountOutputTypeCountBatchHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchHistoryWhereInput
  }

  /**
   * UnitConcentrationCountOutputType without action
   */
  export type UnitConcentrationCountOutputTypeCountIssueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IssueWhereInput
  }

  /**
   * UnitConcentrationCountOutputType without action
   */
  export type UnitConcentrationCountOutputTypeCountBufferLevelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BufferLevelWhereInput
  }


  /**
   * Count Type PrescriptionCountOutputType
   */

  export type PrescriptionCountOutputType = {
    issues: number
    OffRecordMeds: number
    PrescriptionVitals: number
    Charges: number
  }

  export type PrescriptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    issues?: boolean | PrescriptionCountOutputTypeCountIssuesArgs
    OffRecordMeds?: boolean | PrescriptionCountOutputTypeCountOffRecordMedsArgs
    PrescriptionVitals?: boolean | PrescriptionCountOutputTypeCountPrescriptionVitalsArgs
    Charges?: boolean | PrescriptionCountOutputTypeCountChargesArgs
  }

  // Custom InputTypes
  /**
   * PrescriptionCountOutputType without action
   */
  export type PrescriptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionCountOutputType
     */
    select?: PrescriptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PrescriptionCountOutputType without action
   */
  export type PrescriptionCountOutputTypeCountIssuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IssueWhereInput
  }

  /**
   * PrescriptionCountOutputType without action
   */
  export type PrescriptionCountOutputTypeCountOffRecordMedsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OffRecordMedsWhereInput
  }

  /**
   * PrescriptionCountOutputType without action
   */
  export type PrescriptionCountOutputTypeCountPrescriptionVitalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionVitalsWhereInput
  }

  /**
   * PrescriptionCountOutputType without action
   */
  export type PrescriptionCountOutputTypeCountChargesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionChargesWhereInput
  }


  /**
   * Count Type VitalsCountOutputType
   */

  export type VitalsCountOutputType = {
    PrescriptionVitals: number
  }

  export type VitalsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PrescriptionVitals?: boolean | VitalsCountOutputTypeCountPrescriptionVitalsArgs
  }

  // Custom InputTypes
  /**
   * VitalsCountOutputType without action
   */
  export type VitalsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalsCountOutputType
     */
    select?: VitalsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VitalsCountOutputType without action
   */
  export type VitalsCountOutputTypeCountPrescriptionVitalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionVitalsWhereInput
  }


  /**
   * Count Type IssueCountOutputType
   */

  export type IssueCountOutputType = {
    stratergyHistory: number
  }

  export type IssueCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stratergyHistory?: boolean | IssueCountOutputTypeCountStratergyHistoryArgs
  }

  // Custom InputTypes
  /**
   * IssueCountOutputType without action
   */
  export type IssueCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IssueCountOutputType
     */
    select?: IssueCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * IssueCountOutputType without action
   */
  export type IssueCountOutputTypeCountStratergyHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StratergyHistoryWhereInput
  }


  /**
   * Count Type ReportParameterCountOutputType
   */

  export type ReportParameterCountOutputType = {
    ReportValue: number
  }

  export type ReportParameterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ReportValue?: boolean | ReportParameterCountOutputTypeCountReportValueArgs
  }

  // Custom InputTypes
  /**
   * ReportParameterCountOutputType without action
   */
  export type ReportParameterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportParameterCountOutputType
     */
    select?: ReportParameterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReportParameterCountOutputType without action
   */
  export type ReportParameterCountOutputTypeCountReportValueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportValueWhereInput
  }


  /**
   * Count Type ReportTypeCountOutputType
   */

  export type ReportTypeCountOutputType = {
    PatientReport: number
    parameters: number
  }

  export type ReportTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PatientReport?: boolean | ReportTypeCountOutputTypeCountPatientReportArgs
    parameters?: boolean | ReportTypeCountOutputTypeCountParametersArgs
  }

  // Custom InputTypes
  /**
   * ReportTypeCountOutputType without action
   */
  export type ReportTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTypeCountOutputType
     */
    select?: ReportTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReportTypeCountOutputType without action
   */
  export type ReportTypeCountOutputTypeCountPatientReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientReportWhereInput
  }

  /**
   * ReportTypeCountOutputType without action
   */
  export type ReportTypeCountOutputTypeCountParametersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportParameterWhereInput
  }


  /**
   * Count Type PatientReportCountOutputType
   */

  export type PatientReportCountOutputType = {
    parameters: number
  }

  export type PatientReportCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parameters?: boolean | PatientReportCountOutputTypeCountParametersArgs
  }

  // Custom InputTypes
  /**
   * PatientReportCountOutputType without action
   */
  export type PatientReportCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientReportCountOutputType
     */
    select?: PatientReportCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PatientReportCountOutputType without action
   */
  export type PatientReportCountOutputTypeCountParametersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportValueWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Patient
   */

  export type AggregatePatient = {
    _count: PatientCountAggregateOutputType | null
    _avg: PatientAvgAggregateOutputType | null
    _sum: PatientSumAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  export type PatientAvgAggregateOutputType = {
    id: number | null
    height: number | null
    weight: number | null
  }

  export type PatientSumAggregateOutputType = {
    id: number | null
    height: number | null
    weight: number | null
  }

  export type PatientMinAggregateOutputType = {
    id: number | null
    telephone: string | null
    name: string | null
    birthDate: Date | null
    address: string | null
    height: number | null
    weight: number | null
    gender: $Enums.Gender | null
    NIC: string | null
  }

  export type PatientMaxAggregateOutputType = {
    id: number | null
    telephone: string | null
    name: string | null
    birthDate: Date | null
    address: string | null
    height: number | null
    weight: number | null
    gender: $Enums.Gender | null
    NIC: string | null
  }

  export type PatientCountAggregateOutputType = {
    id: number
    telephone: number
    name: number
    birthDate: number
    address: number
    height: number
    weight: number
    gender: number
    NIC: number
    _all: number
  }


  export type PatientAvgAggregateInputType = {
    id?: true
    height?: true
    weight?: true
  }

  export type PatientSumAggregateInputType = {
    id?: true
    height?: true
    weight?: true
  }

  export type PatientMinAggregateInputType = {
    id?: true
    telephone?: true
    name?: true
    birthDate?: true
    address?: true
    height?: true
    weight?: true
    gender?: true
    NIC?: true
  }

  export type PatientMaxAggregateInputType = {
    id?: true
    telephone?: true
    name?: true
    birthDate?: true
    address?: true
    height?: true
    weight?: true
    gender?: true
    NIC?: true
  }

  export type PatientCountAggregateInputType = {
    id?: true
    telephone?: true
    name?: true
    birthDate?: true
    address?: true
    height?: true
    weight?: true
    gender?: true
    NIC?: true
    _all?: true
  }

  export type PatientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patient to aggregate.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Patients
    **/
    _count?: true | PatientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PatientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PatientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatientMaxAggregateInputType
  }

  export type GetPatientAggregateType<T extends PatientAggregateArgs> = {
        [P in keyof T & keyof AggregatePatient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatient[P]>
      : GetScalarType<T[P], AggregatePatient[P]>
  }




  export type PatientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientWhereInput
    orderBy?: PatientOrderByWithAggregationInput | PatientOrderByWithAggregationInput[]
    by: PatientScalarFieldEnum[] | PatientScalarFieldEnum
    having?: PatientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatientCountAggregateInputType | true
    _avg?: PatientAvgAggregateInputType
    _sum?: PatientSumAggregateInputType
    _min?: PatientMinAggregateInputType
    _max?: PatientMaxAggregateInputType
  }

  export type PatientGroupByOutputType = {
    id: number
    telephone: string
    name: string
    birthDate: Date | null
    address: string | null
    height: number | null
    weight: number | null
    gender: $Enums.Gender
    NIC: string | null
    _count: PatientCountAggregateOutputType | null
    _avg: PatientAvgAggregateOutputType | null
    _sum: PatientSumAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  type GetPatientGroupByPayload<T extends PatientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatientGroupByOutputType[P]>
            : GetScalarType<T[P], PatientGroupByOutputType[P]>
        }
      >
    >


  export type PatientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    telephone?: boolean
    name?: boolean
    birthDate?: boolean
    address?: boolean
    height?: boolean
    weight?: boolean
    gender?: boolean
    NIC?: boolean
    medicalCert?: boolean | Patient$medicalCertArgs<ExtArgs>
    PatientHistory?: boolean | Patient$PatientHistoryArgs<ExtArgs>
    reports?: boolean | Patient$reportsArgs<ExtArgs>
    prescription?: boolean | Patient$prescriptionArgs<ExtArgs>
    queueEntry?: boolean | Patient$queueEntryArgs<ExtArgs>
    USSReferral?: boolean | Patient$USSReferralArgs<ExtArgs>
    referralLetters?: boolean | Patient$referralLettersArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    telephone?: boolean
    name?: boolean
    birthDate?: boolean
    address?: boolean
    height?: boolean
    weight?: boolean
    gender?: boolean
    NIC?: boolean
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    telephone?: boolean
    name?: boolean
    birthDate?: boolean
    address?: boolean
    height?: boolean
    weight?: boolean
    gender?: boolean
    NIC?: boolean
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectScalar = {
    id?: boolean
    telephone?: boolean
    name?: boolean
    birthDate?: boolean
    address?: boolean
    height?: boolean
    weight?: boolean
    gender?: boolean
    NIC?: boolean
  }

  export type PatientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "telephone" | "name" | "birthDate" | "address" | "height" | "weight" | "gender" | "NIC", ExtArgs["result"]["patient"]>
  export type PatientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicalCert?: boolean | Patient$medicalCertArgs<ExtArgs>
    PatientHistory?: boolean | Patient$PatientHistoryArgs<ExtArgs>
    reports?: boolean | Patient$reportsArgs<ExtArgs>
    prescription?: boolean | Patient$prescriptionArgs<ExtArgs>
    queueEntry?: boolean | Patient$queueEntryArgs<ExtArgs>
    USSReferral?: boolean | Patient$USSReferralArgs<ExtArgs>
    referralLetters?: boolean | Patient$referralLettersArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PatientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PatientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PatientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Patient"
    objects: {
      medicalCert: Prisma.$MedicalCertificatePayload<ExtArgs>[]
      PatientHistory: Prisma.$PatientHistoryPayload<ExtArgs>[]
      reports: Prisma.$PatientReportPayload<ExtArgs>[]
      prescription: Prisma.$PrescriptionPayload<ExtArgs>[]
      queueEntry: Prisma.$QueueEntryPayload<ExtArgs>[]
      USSReferral: Prisma.$USSReferralPayload<ExtArgs>[]
      referralLetters: Prisma.$ReferralLetterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      telephone: string
      name: string
      birthDate: Date | null
      address: string | null
      height: number | null
      weight: number | null
      gender: $Enums.Gender
      NIC: string | null
    }, ExtArgs["result"]["patient"]>
    composites: {}
  }

  type PatientGetPayload<S extends boolean | null | undefined | PatientDefaultArgs> = $Result.GetResult<Prisma.$PatientPayload, S>

  type PatientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PatientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PatientCountAggregateInputType | true
    }

  export interface PatientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Patient'], meta: { name: 'Patient' } }
    /**
     * Find zero or one Patient that matches the filter.
     * @param {PatientFindUniqueArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PatientFindUniqueArgs>(args: SelectSubset<T, PatientFindUniqueArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Patient that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PatientFindUniqueOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PatientFindUniqueOrThrowArgs>(args: SelectSubset<T, PatientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Patient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PatientFindFirstArgs>(args?: SelectSubset<T, PatientFindFirstArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Patient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PatientFindFirstOrThrowArgs>(args?: SelectSubset<T, PatientFindFirstOrThrowArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Patients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Patients
     * const patients = await prisma.patient.findMany()
     * 
     * // Get first 10 Patients
     * const patients = await prisma.patient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patientWithIdOnly = await prisma.patient.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PatientFindManyArgs>(args?: SelectSubset<T, PatientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Patient.
     * @param {PatientCreateArgs} args - Arguments to create a Patient.
     * @example
     * // Create one Patient
     * const Patient = await prisma.patient.create({
     *   data: {
     *     // ... data to create a Patient
     *   }
     * })
     * 
     */
    create<T extends PatientCreateArgs>(args: SelectSubset<T, PatientCreateArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Patients.
     * @param {PatientCreateManyArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patient = await prisma.patient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PatientCreateManyArgs>(args?: SelectSubset<T, PatientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Patients and returns the data saved in the database.
     * @param {PatientCreateManyAndReturnArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patient = await prisma.patient.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Patients and only return the `id`
     * const patientWithIdOnly = await prisma.patient.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PatientCreateManyAndReturnArgs>(args?: SelectSubset<T, PatientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Patient.
     * @param {PatientDeleteArgs} args - Arguments to delete one Patient.
     * @example
     * // Delete one Patient
     * const Patient = await prisma.patient.delete({
     *   where: {
     *     // ... filter to delete one Patient
     *   }
     * })
     * 
     */
    delete<T extends PatientDeleteArgs>(args: SelectSubset<T, PatientDeleteArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Patient.
     * @param {PatientUpdateArgs} args - Arguments to update one Patient.
     * @example
     * // Update one Patient
     * const patient = await prisma.patient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PatientUpdateArgs>(args: SelectSubset<T, PatientUpdateArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Patients.
     * @param {PatientDeleteManyArgs} args - Arguments to filter Patients to delete.
     * @example
     * // Delete a few Patients
     * const { count } = await prisma.patient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PatientDeleteManyArgs>(args?: SelectSubset<T, PatientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Patients
     * const patient = await prisma.patient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PatientUpdateManyArgs>(args: SelectSubset<T, PatientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patients and returns the data updated in the database.
     * @param {PatientUpdateManyAndReturnArgs} args - Arguments to update many Patients.
     * @example
     * // Update many Patients
     * const patient = await prisma.patient.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Patients and only return the `id`
     * const patientWithIdOnly = await prisma.patient.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PatientUpdateManyAndReturnArgs>(args: SelectSubset<T, PatientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Patient.
     * @param {PatientUpsertArgs} args - Arguments to update or create a Patient.
     * @example
     * // Update or create a Patient
     * const patient = await prisma.patient.upsert({
     *   create: {
     *     // ... data to create a Patient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Patient we want to update
     *   }
     * })
     */
    upsert<T extends PatientUpsertArgs>(args: SelectSubset<T, PatientUpsertArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientCountArgs} args - Arguments to filter Patients to count.
     * @example
     * // Count the number of Patients
     * const count = await prisma.patient.count({
     *   where: {
     *     // ... the filter for the Patients we want to count
     *   }
     * })
    **/
    count<T extends PatientCountArgs>(
      args?: Subset<T, PatientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatientAggregateArgs>(args: Subset<T, PatientAggregateArgs>): Prisma.PrismaPromise<GetPatientAggregateType<T>>

    /**
     * Group by Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatientGroupByArgs['orderBy'] }
        : { orderBy?: PatientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Patient model
   */
  readonly fields: PatientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Patient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    medicalCert<T extends Patient$medicalCertArgs<ExtArgs> = {}>(args?: Subset<T, Patient$medicalCertArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalCertificatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    PatientHistory<T extends Patient$PatientHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Patient$PatientHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reports<T extends Patient$reportsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    prescription<T extends Patient$prescriptionArgs<ExtArgs> = {}>(args?: Subset<T, Patient$prescriptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    queueEntry<T extends Patient$queueEntryArgs<ExtArgs> = {}>(args?: Subset<T, Patient$queueEntryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueueEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    USSReferral<T extends Patient$USSReferralArgs<ExtArgs> = {}>(args?: Subset<T, Patient$USSReferralArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$USSReferralPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    referralLetters<T extends Patient$referralLettersArgs<ExtArgs> = {}>(args?: Subset<T, Patient$referralLettersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralLetterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Patient model
   */ 
  interface PatientFieldRefs {
    readonly id: FieldRef<"Patient", 'Int'>
    readonly telephone: FieldRef<"Patient", 'String'>
    readonly name: FieldRef<"Patient", 'String'>
    readonly birthDate: FieldRef<"Patient", 'DateTime'>
    readonly address: FieldRef<"Patient", 'String'>
    readonly height: FieldRef<"Patient", 'Float'>
    readonly weight: FieldRef<"Patient", 'Float'>
    readonly gender: FieldRef<"Patient", 'Gender'>
    readonly NIC: FieldRef<"Patient", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Patient findUnique
   */
  export type PatientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findUniqueOrThrow
   */
  export type PatientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findFirst
   */
  export type PatientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient findFirstOrThrow
   */
  export type PatientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient findMany
   */
  export type PatientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patients to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient create
   */
  export type PatientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to create a Patient.
     */
    data: XOR<PatientCreateInput, PatientUncheckedCreateInput>
  }

  /**
   * Patient createMany
   */
  export type PatientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Patients.
     */
    data: PatientCreateManyInput | PatientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Patient createManyAndReturn
   */
  export type PatientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * The data used to create many Patients.
     */
    data: PatientCreateManyInput | PatientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Patient update
   */
  export type PatientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to update a Patient.
     */
    data: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
    /**
     * Choose, which Patient to update.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient updateMany
   */
  export type PatientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Patients.
     */
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyInput>
    /**
     * Filter which Patients to update
     */
    where?: PatientWhereInput
    /**
     * Limit how many Patients to update.
     */
    limit?: number
  }

  /**
   * Patient updateManyAndReturn
   */
  export type PatientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * The data used to update Patients.
     */
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyInput>
    /**
     * Filter which Patients to update
     */
    where?: PatientWhereInput
    /**
     * Limit how many Patients to update.
     */
    limit?: number
  }

  /**
   * Patient upsert
   */
  export type PatientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The filter to search for the Patient to update in case it exists.
     */
    where: PatientWhereUniqueInput
    /**
     * In case the Patient found by the `where` argument doesn't exist, create a new Patient with this data.
     */
    create: XOR<PatientCreateInput, PatientUncheckedCreateInput>
    /**
     * In case the Patient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
  }

  /**
   * Patient delete
   */
  export type PatientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter which Patient to delete.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient deleteMany
   */
  export type PatientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patients to delete
     */
    where?: PatientWhereInput
    /**
     * Limit how many Patients to delete.
     */
    limit?: number
  }

  /**
   * Patient.medicalCert
   */
  export type Patient$medicalCertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalCertificate
     */
    select?: MedicalCertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalCertificate
     */
    omit?: MedicalCertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalCertificateInclude<ExtArgs> | null
    where?: MedicalCertificateWhereInput
    orderBy?: MedicalCertificateOrderByWithRelationInput | MedicalCertificateOrderByWithRelationInput[]
    cursor?: MedicalCertificateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicalCertificateScalarFieldEnum | MedicalCertificateScalarFieldEnum[]
  }

  /**
   * Patient.PatientHistory
   */
  export type Patient$PatientHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientHistory
     */
    select?: PatientHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientHistory
     */
    omit?: PatientHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientHistoryInclude<ExtArgs> | null
    where?: PatientHistoryWhereInput
    orderBy?: PatientHistoryOrderByWithRelationInput | PatientHistoryOrderByWithRelationInput[]
    cursor?: PatientHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatientHistoryScalarFieldEnum | PatientHistoryScalarFieldEnum[]
  }

  /**
   * Patient.reports
   */
  export type Patient$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientReport
     */
    select?: PatientReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientReport
     */
    omit?: PatientReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientReportInclude<ExtArgs> | null
    where?: PatientReportWhereInput
    orderBy?: PatientReportOrderByWithRelationInput | PatientReportOrderByWithRelationInput[]
    cursor?: PatientReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatientReportScalarFieldEnum | PatientReportScalarFieldEnum[]
  }

  /**
   * Patient.prescription
   */
  export type Patient$prescriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    where?: PrescriptionWhereInput
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    cursor?: PrescriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * Patient.queueEntry
   */
  export type Patient$queueEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueEntry
     */
    select?: QueueEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueEntry
     */
    omit?: QueueEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueEntryInclude<ExtArgs> | null
    where?: QueueEntryWhereInput
    orderBy?: QueueEntryOrderByWithRelationInput | QueueEntryOrderByWithRelationInput[]
    cursor?: QueueEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QueueEntryScalarFieldEnum | QueueEntryScalarFieldEnum[]
  }

  /**
   * Patient.USSReferral
   */
  export type Patient$USSReferralArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the USSReferral
     */
    select?: USSReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the USSReferral
     */
    omit?: USSReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: USSReferralInclude<ExtArgs> | null
    where?: USSReferralWhereInput
    orderBy?: USSReferralOrderByWithRelationInput | USSReferralOrderByWithRelationInput[]
    cursor?: USSReferralWhereUniqueInput
    take?: number
    skip?: number
    distinct?: USSReferralScalarFieldEnum | USSReferralScalarFieldEnum[]
  }

  /**
   * Patient.referralLetters
   */
  export type Patient$referralLettersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralLetter
     */
    select?: ReferralLetterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferralLetter
     */
    omit?: ReferralLetterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralLetterInclude<ExtArgs> | null
    where?: ReferralLetterWhereInput
    orderBy?: ReferralLetterOrderByWithRelationInput | ReferralLetterOrderByWithRelationInput[]
    cursor?: ReferralLetterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReferralLetterScalarFieldEnum | ReferralLetterScalarFieldEnum[]
  }

  /**
   * Patient without action
   */
  export type PatientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
  }


  /**
   * Model PatientHistory
   */

  export type AggregatePatientHistory = {
    _count: PatientHistoryCountAggregateOutputType | null
    _avg: PatientHistoryAvgAggregateOutputType | null
    _sum: PatientHistorySumAggregateOutputType | null
    _min: PatientHistoryMinAggregateOutputType | null
    _max: PatientHistoryMaxAggregateOutputType | null
  }

  export type PatientHistoryAvgAggregateOutputType = {
    id: number | null
    patientId: number | null
  }

  export type PatientHistorySumAggregateOutputType = {
    id: number | null
    patientId: number | null
  }

  export type PatientHistoryMinAggregateOutputType = {
    id: number | null
    patientId: number | null
    description: string | null
    type: $Enums.PatientHistoryType | null
    time: Date | null
    name: string | null
  }

  export type PatientHistoryMaxAggregateOutputType = {
    id: number | null
    patientId: number | null
    description: string | null
    type: $Enums.PatientHistoryType | null
    time: Date | null
    name: string | null
  }

  export type PatientHistoryCountAggregateOutputType = {
    id: number
    patientId: number
    description: number
    type: number
    time: number
    name: number
    _all: number
  }


  export type PatientHistoryAvgAggregateInputType = {
    id?: true
    patientId?: true
  }

  export type PatientHistorySumAggregateInputType = {
    id?: true
    patientId?: true
  }

  export type PatientHistoryMinAggregateInputType = {
    id?: true
    patientId?: true
    description?: true
    type?: true
    time?: true
    name?: true
  }

  export type PatientHistoryMaxAggregateInputType = {
    id?: true
    patientId?: true
    description?: true
    type?: true
    time?: true
    name?: true
  }

  export type PatientHistoryCountAggregateInputType = {
    id?: true
    patientId?: true
    description?: true
    type?: true
    time?: true
    name?: true
    _all?: true
  }

  export type PatientHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PatientHistory to aggregate.
     */
    where?: PatientHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientHistories to fetch.
     */
    orderBy?: PatientHistoryOrderByWithRelationInput | PatientHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatientHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PatientHistories
    **/
    _count?: true | PatientHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PatientHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PatientHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatientHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatientHistoryMaxAggregateInputType
  }

  export type GetPatientHistoryAggregateType<T extends PatientHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregatePatientHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatientHistory[P]>
      : GetScalarType<T[P], AggregatePatientHistory[P]>
  }




  export type PatientHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientHistoryWhereInput
    orderBy?: PatientHistoryOrderByWithAggregationInput | PatientHistoryOrderByWithAggregationInput[]
    by: PatientHistoryScalarFieldEnum[] | PatientHistoryScalarFieldEnum
    having?: PatientHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatientHistoryCountAggregateInputType | true
    _avg?: PatientHistoryAvgAggregateInputType
    _sum?: PatientHistorySumAggregateInputType
    _min?: PatientHistoryMinAggregateInputType
    _max?: PatientHistoryMaxAggregateInputType
  }

  export type PatientHistoryGroupByOutputType = {
    id: number
    patientId: number
    description: string | null
    type: $Enums.PatientHistoryType
    time: Date
    name: string
    _count: PatientHistoryCountAggregateOutputType | null
    _avg: PatientHistoryAvgAggregateOutputType | null
    _sum: PatientHistorySumAggregateOutputType | null
    _min: PatientHistoryMinAggregateOutputType | null
    _max: PatientHistoryMaxAggregateOutputType | null
  }

  type GetPatientHistoryGroupByPayload<T extends PatientHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatientHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatientHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatientHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], PatientHistoryGroupByOutputType[P]>
        }
      >
    >


  export type PatientHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    description?: boolean
    type?: boolean
    time?: boolean
    name?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patientHistory"]>

  export type PatientHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    description?: boolean
    type?: boolean
    time?: boolean
    name?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patientHistory"]>

  export type PatientHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    description?: boolean
    type?: boolean
    time?: boolean
    name?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patientHistory"]>

  export type PatientHistorySelectScalar = {
    id?: boolean
    patientId?: boolean
    description?: boolean
    type?: boolean
    time?: boolean
    name?: boolean
  }

  export type PatientHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "description" | "type" | "time" | "name", ExtArgs["result"]["patientHistory"]>
  export type PatientHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type PatientHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type PatientHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }

  export type $PatientHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PatientHistory"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      patientId: number
      description: string | null
      type: $Enums.PatientHistoryType
      time: Date
      name: string
    }, ExtArgs["result"]["patientHistory"]>
    composites: {}
  }

  type PatientHistoryGetPayload<S extends boolean | null | undefined | PatientHistoryDefaultArgs> = $Result.GetResult<Prisma.$PatientHistoryPayload, S>

  type PatientHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PatientHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PatientHistoryCountAggregateInputType | true
    }

  export interface PatientHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PatientHistory'], meta: { name: 'PatientHistory' } }
    /**
     * Find zero or one PatientHistory that matches the filter.
     * @param {PatientHistoryFindUniqueArgs} args - Arguments to find a PatientHistory
     * @example
     * // Get one PatientHistory
     * const patientHistory = await prisma.patientHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PatientHistoryFindUniqueArgs>(args: SelectSubset<T, PatientHistoryFindUniqueArgs<ExtArgs>>): Prisma__PatientHistoryClient<$Result.GetResult<Prisma.$PatientHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PatientHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PatientHistoryFindUniqueOrThrowArgs} args - Arguments to find a PatientHistory
     * @example
     * // Get one PatientHistory
     * const patientHistory = await prisma.patientHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PatientHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, PatientHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PatientHistoryClient<$Result.GetResult<Prisma.$PatientHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PatientHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientHistoryFindFirstArgs} args - Arguments to find a PatientHistory
     * @example
     * // Get one PatientHistory
     * const patientHistory = await prisma.patientHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PatientHistoryFindFirstArgs>(args?: SelectSubset<T, PatientHistoryFindFirstArgs<ExtArgs>>): Prisma__PatientHistoryClient<$Result.GetResult<Prisma.$PatientHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PatientHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientHistoryFindFirstOrThrowArgs} args - Arguments to find a PatientHistory
     * @example
     * // Get one PatientHistory
     * const patientHistory = await prisma.patientHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PatientHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, PatientHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__PatientHistoryClient<$Result.GetResult<Prisma.$PatientHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PatientHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PatientHistories
     * const patientHistories = await prisma.patientHistory.findMany()
     * 
     * // Get first 10 PatientHistories
     * const patientHistories = await prisma.patientHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patientHistoryWithIdOnly = await prisma.patientHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PatientHistoryFindManyArgs>(args?: SelectSubset<T, PatientHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PatientHistory.
     * @param {PatientHistoryCreateArgs} args - Arguments to create a PatientHistory.
     * @example
     * // Create one PatientHistory
     * const PatientHistory = await prisma.patientHistory.create({
     *   data: {
     *     // ... data to create a PatientHistory
     *   }
     * })
     * 
     */
    create<T extends PatientHistoryCreateArgs>(args: SelectSubset<T, PatientHistoryCreateArgs<ExtArgs>>): Prisma__PatientHistoryClient<$Result.GetResult<Prisma.$PatientHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PatientHistories.
     * @param {PatientHistoryCreateManyArgs} args - Arguments to create many PatientHistories.
     * @example
     * // Create many PatientHistories
     * const patientHistory = await prisma.patientHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PatientHistoryCreateManyArgs>(args?: SelectSubset<T, PatientHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PatientHistories and returns the data saved in the database.
     * @param {PatientHistoryCreateManyAndReturnArgs} args - Arguments to create many PatientHistories.
     * @example
     * // Create many PatientHistories
     * const patientHistory = await prisma.patientHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PatientHistories and only return the `id`
     * const patientHistoryWithIdOnly = await prisma.patientHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PatientHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, PatientHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PatientHistory.
     * @param {PatientHistoryDeleteArgs} args - Arguments to delete one PatientHistory.
     * @example
     * // Delete one PatientHistory
     * const PatientHistory = await prisma.patientHistory.delete({
     *   where: {
     *     // ... filter to delete one PatientHistory
     *   }
     * })
     * 
     */
    delete<T extends PatientHistoryDeleteArgs>(args: SelectSubset<T, PatientHistoryDeleteArgs<ExtArgs>>): Prisma__PatientHistoryClient<$Result.GetResult<Prisma.$PatientHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PatientHistory.
     * @param {PatientHistoryUpdateArgs} args - Arguments to update one PatientHistory.
     * @example
     * // Update one PatientHistory
     * const patientHistory = await prisma.patientHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PatientHistoryUpdateArgs>(args: SelectSubset<T, PatientHistoryUpdateArgs<ExtArgs>>): Prisma__PatientHistoryClient<$Result.GetResult<Prisma.$PatientHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PatientHistories.
     * @param {PatientHistoryDeleteManyArgs} args - Arguments to filter PatientHistories to delete.
     * @example
     * // Delete a few PatientHistories
     * const { count } = await prisma.patientHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PatientHistoryDeleteManyArgs>(args?: SelectSubset<T, PatientHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PatientHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PatientHistories
     * const patientHistory = await prisma.patientHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PatientHistoryUpdateManyArgs>(args: SelectSubset<T, PatientHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PatientHistories and returns the data updated in the database.
     * @param {PatientHistoryUpdateManyAndReturnArgs} args - Arguments to update many PatientHistories.
     * @example
     * // Update many PatientHistories
     * const patientHistory = await prisma.patientHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PatientHistories and only return the `id`
     * const patientHistoryWithIdOnly = await prisma.patientHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PatientHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, PatientHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PatientHistory.
     * @param {PatientHistoryUpsertArgs} args - Arguments to update or create a PatientHistory.
     * @example
     * // Update or create a PatientHistory
     * const patientHistory = await prisma.patientHistory.upsert({
     *   create: {
     *     // ... data to create a PatientHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PatientHistory we want to update
     *   }
     * })
     */
    upsert<T extends PatientHistoryUpsertArgs>(args: SelectSubset<T, PatientHistoryUpsertArgs<ExtArgs>>): Prisma__PatientHistoryClient<$Result.GetResult<Prisma.$PatientHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PatientHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientHistoryCountArgs} args - Arguments to filter PatientHistories to count.
     * @example
     * // Count the number of PatientHistories
     * const count = await prisma.patientHistory.count({
     *   where: {
     *     // ... the filter for the PatientHistories we want to count
     *   }
     * })
    **/
    count<T extends PatientHistoryCountArgs>(
      args?: Subset<T, PatientHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatientHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PatientHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatientHistoryAggregateArgs>(args: Subset<T, PatientHistoryAggregateArgs>): Prisma.PrismaPromise<GetPatientHistoryAggregateType<T>>

    /**
     * Group by PatientHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatientHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatientHistoryGroupByArgs['orderBy'] }
        : { orderBy?: PatientHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatientHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatientHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PatientHistory model
   */
  readonly fields: PatientHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PatientHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatientHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PatientHistory model
   */ 
  interface PatientHistoryFieldRefs {
    readonly id: FieldRef<"PatientHistory", 'Int'>
    readonly patientId: FieldRef<"PatientHistory", 'Int'>
    readonly description: FieldRef<"PatientHistory", 'String'>
    readonly type: FieldRef<"PatientHistory", 'PatientHistoryType'>
    readonly time: FieldRef<"PatientHistory", 'DateTime'>
    readonly name: FieldRef<"PatientHistory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PatientHistory findUnique
   */
  export type PatientHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientHistory
     */
    select?: PatientHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientHistory
     */
    omit?: PatientHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PatientHistory to fetch.
     */
    where: PatientHistoryWhereUniqueInput
  }

  /**
   * PatientHistory findUniqueOrThrow
   */
  export type PatientHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientHistory
     */
    select?: PatientHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientHistory
     */
    omit?: PatientHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PatientHistory to fetch.
     */
    where: PatientHistoryWhereUniqueInput
  }

  /**
   * PatientHistory findFirst
   */
  export type PatientHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientHistory
     */
    select?: PatientHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientHistory
     */
    omit?: PatientHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PatientHistory to fetch.
     */
    where?: PatientHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientHistories to fetch.
     */
    orderBy?: PatientHistoryOrderByWithRelationInput | PatientHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PatientHistories.
     */
    cursor?: PatientHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PatientHistories.
     */
    distinct?: PatientHistoryScalarFieldEnum | PatientHistoryScalarFieldEnum[]
  }

  /**
   * PatientHistory findFirstOrThrow
   */
  export type PatientHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientHistory
     */
    select?: PatientHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientHistory
     */
    omit?: PatientHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PatientHistory to fetch.
     */
    where?: PatientHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientHistories to fetch.
     */
    orderBy?: PatientHistoryOrderByWithRelationInput | PatientHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PatientHistories.
     */
    cursor?: PatientHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PatientHistories.
     */
    distinct?: PatientHistoryScalarFieldEnum | PatientHistoryScalarFieldEnum[]
  }

  /**
   * PatientHistory findMany
   */
  export type PatientHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientHistory
     */
    select?: PatientHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientHistory
     */
    omit?: PatientHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PatientHistories to fetch.
     */
    where?: PatientHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientHistories to fetch.
     */
    orderBy?: PatientHistoryOrderByWithRelationInput | PatientHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PatientHistories.
     */
    cursor?: PatientHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientHistories.
     */
    skip?: number
    distinct?: PatientHistoryScalarFieldEnum | PatientHistoryScalarFieldEnum[]
  }

  /**
   * PatientHistory create
   */
  export type PatientHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientHistory
     */
    select?: PatientHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientHistory
     */
    omit?: PatientHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a PatientHistory.
     */
    data: XOR<PatientHistoryCreateInput, PatientHistoryUncheckedCreateInput>
  }

  /**
   * PatientHistory createMany
   */
  export type PatientHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PatientHistories.
     */
    data: PatientHistoryCreateManyInput | PatientHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PatientHistory createManyAndReturn
   */
  export type PatientHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientHistory
     */
    select?: PatientHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PatientHistory
     */
    omit?: PatientHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many PatientHistories.
     */
    data: PatientHistoryCreateManyInput | PatientHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PatientHistory update
   */
  export type PatientHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientHistory
     */
    select?: PatientHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientHistory
     */
    omit?: PatientHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a PatientHistory.
     */
    data: XOR<PatientHistoryUpdateInput, PatientHistoryUncheckedUpdateInput>
    /**
     * Choose, which PatientHistory to update.
     */
    where: PatientHistoryWhereUniqueInput
  }

  /**
   * PatientHistory updateMany
   */
  export type PatientHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PatientHistories.
     */
    data: XOR<PatientHistoryUpdateManyMutationInput, PatientHistoryUncheckedUpdateManyInput>
    /**
     * Filter which PatientHistories to update
     */
    where?: PatientHistoryWhereInput
    /**
     * Limit how many PatientHistories to update.
     */
    limit?: number
  }

  /**
   * PatientHistory updateManyAndReturn
   */
  export type PatientHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientHistory
     */
    select?: PatientHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PatientHistory
     */
    omit?: PatientHistoryOmit<ExtArgs> | null
    /**
     * The data used to update PatientHistories.
     */
    data: XOR<PatientHistoryUpdateManyMutationInput, PatientHistoryUncheckedUpdateManyInput>
    /**
     * Filter which PatientHistories to update
     */
    where?: PatientHistoryWhereInput
    /**
     * Limit how many PatientHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PatientHistory upsert
   */
  export type PatientHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientHistory
     */
    select?: PatientHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientHistory
     */
    omit?: PatientHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the PatientHistory to update in case it exists.
     */
    where: PatientHistoryWhereUniqueInput
    /**
     * In case the PatientHistory found by the `where` argument doesn't exist, create a new PatientHistory with this data.
     */
    create: XOR<PatientHistoryCreateInput, PatientHistoryUncheckedCreateInput>
    /**
     * In case the PatientHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatientHistoryUpdateInput, PatientHistoryUncheckedUpdateInput>
  }

  /**
   * PatientHistory delete
   */
  export type PatientHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientHistory
     */
    select?: PatientHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientHistory
     */
    omit?: PatientHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientHistoryInclude<ExtArgs> | null
    /**
     * Filter which PatientHistory to delete.
     */
    where: PatientHistoryWhereUniqueInput
  }

  /**
   * PatientHistory deleteMany
   */
  export type PatientHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PatientHistories to delete
     */
    where?: PatientHistoryWhereInput
    /**
     * Limit how many PatientHistories to delete.
     */
    limit?: number
  }

  /**
   * PatientHistory without action
   */
  export type PatientHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientHistory
     */
    select?: PatientHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientHistory
     */
    omit?: PatientHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientHistoryInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    name: string | null
    gender: $Enums.Gender | null
    image: string | null
    mobile: string | null
    password: string | null
    role: $Enums.Role | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    name: string | null
    gender: $Enums.Gender | null
    image: string | null
    mobile: string | null
    password: string | null
    role: $Enums.Role | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    gender: number
    image: number
    mobile: number
    password: number
    role: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    gender?: true
    image?: true
    mobile?: true
    password?: true
    role?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    gender?: true
    image?: true
    mobile?: true
    password?: true
    role?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    gender?: true
    image?: true
    mobile?: true
    password?: true
    role?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    name: string
    gender: $Enums.Gender
    image: string | null
    mobile: string
    password: string
    role: $Enums.Role
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    gender?: boolean
    image?: boolean
    mobile?: boolean
    password?: boolean
    role?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    gender?: boolean
    image?: boolean
    mobile?: boolean
    password?: boolean
    role?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    gender?: boolean
    image?: boolean
    mobile?: boolean
    password?: boolean
    role?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    gender?: boolean
    image?: boolean
    mobile?: boolean
    password?: boolean
    role?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "gender" | "image" | "mobile" | "password" | "role", ExtArgs["result"]["user"]>

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      name: string
      gender: $Enums.Gender
      image: string | null
      mobile: string
      password: string
      role: $Enums.Role
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly gender: FieldRef<"User", 'Gender'>
    readonly image: FieldRef<"User", 'String'>
    readonly mobile: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
  }


  /**
   * Model Queue
   */

  export type AggregateQueue = {
    _count: QueueCountAggregateOutputType | null
    _avg: QueueAvgAggregateOutputType | null
    _sum: QueueSumAggregateOutputType | null
    _min: QueueMinAggregateOutputType | null
    _max: QueueMaxAggregateOutputType | null
  }

  export type QueueAvgAggregateOutputType = {
    id: number | null
  }

  export type QueueSumAggregateOutputType = {
    id: number | null
  }

  export type QueueMinAggregateOutputType = {
    id: number | null
    start: Date | null
    end: Date | null
    status: $Enums.QueueStatus | null
  }

  export type QueueMaxAggregateOutputType = {
    id: number | null
    start: Date | null
    end: Date | null
    status: $Enums.QueueStatus | null
  }

  export type QueueCountAggregateOutputType = {
    id: number
    start: number
    end: number
    status: number
    _all: number
  }


  export type QueueAvgAggregateInputType = {
    id?: true
  }

  export type QueueSumAggregateInputType = {
    id?: true
  }

  export type QueueMinAggregateInputType = {
    id?: true
    start?: true
    end?: true
    status?: true
  }

  export type QueueMaxAggregateInputType = {
    id?: true
    start?: true
    end?: true
    status?: true
  }

  export type QueueCountAggregateInputType = {
    id?: true
    start?: true
    end?: true
    status?: true
    _all?: true
  }

  export type QueueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Queue to aggregate.
     */
    where?: QueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Queues to fetch.
     */
    orderBy?: QueueOrderByWithRelationInput | QueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Queues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Queues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Queues
    **/
    _count?: true | QueueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QueueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QueueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QueueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QueueMaxAggregateInputType
  }

  export type GetQueueAggregateType<T extends QueueAggregateArgs> = {
        [P in keyof T & keyof AggregateQueue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQueue[P]>
      : GetScalarType<T[P], AggregateQueue[P]>
  }




  export type QueueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QueueWhereInput
    orderBy?: QueueOrderByWithAggregationInput | QueueOrderByWithAggregationInput[]
    by: QueueScalarFieldEnum[] | QueueScalarFieldEnum
    having?: QueueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QueueCountAggregateInputType | true
    _avg?: QueueAvgAggregateInputType
    _sum?: QueueSumAggregateInputType
    _min?: QueueMinAggregateInputType
    _max?: QueueMaxAggregateInputType
  }

  export type QueueGroupByOutputType = {
    id: number
    start: Date
    end: Date | null
    status: $Enums.QueueStatus
    _count: QueueCountAggregateOutputType | null
    _avg: QueueAvgAggregateOutputType | null
    _sum: QueueSumAggregateOutputType | null
    _min: QueueMinAggregateOutputType | null
    _max: QueueMaxAggregateOutputType | null
  }

  type GetQueueGroupByPayload<T extends QueueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QueueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QueueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QueueGroupByOutputType[P]>
            : GetScalarType<T[P], QueueGroupByOutputType[P]>
        }
      >
    >


  export type QueueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    start?: boolean
    end?: boolean
    status?: boolean
    entries?: boolean | Queue$entriesArgs<ExtArgs>
    _count?: boolean | QueueCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["queue"]>

  export type QueueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    start?: boolean
    end?: boolean
    status?: boolean
  }, ExtArgs["result"]["queue"]>

  export type QueueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    start?: boolean
    end?: boolean
    status?: boolean
  }, ExtArgs["result"]["queue"]>

  export type QueueSelectScalar = {
    id?: boolean
    start?: boolean
    end?: boolean
    status?: boolean
  }

  export type QueueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "start" | "end" | "status", ExtArgs["result"]["queue"]>
  export type QueueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entries?: boolean | Queue$entriesArgs<ExtArgs>
    _count?: boolean | QueueCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QueueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type QueueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $QueuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Queue"
    objects: {
      entries: Prisma.$QueueEntryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      start: Date
      end: Date | null
      status: $Enums.QueueStatus
    }, ExtArgs["result"]["queue"]>
    composites: {}
  }

  type QueueGetPayload<S extends boolean | null | undefined | QueueDefaultArgs> = $Result.GetResult<Prisma.$QueuePayload, S>

  type QueueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QueueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QueueCountAggregateInputType | true
    }

  export interface QueueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Queue'], meta: { name: 'Queue' } }
    /**
     * Find zero or one Queue that matches the filter.
     * @param {QueueFindUniqueArgs} args - Arguments to find a Queue
     * @example
     * // Get one Queue
     * const queue = await prisma.queue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QueueFindUniqueArgs>(args: SelectSubset<T, QueueFindUniqueArgs<ExtArgs>>): Prisma__QueueClient<$Result.GetResult<Prisma.$QueuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Queue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QueueFindUniqueOrThrowArgs} args - Arguments to find a Queue
     * @example
     * // Get one Queue
     * const queue = await prisma.queue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QueueFindUniqueOrThrowArgs>(args: SelectSubset<T, QueueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QueueClient<$Result.GetResult<Prisma.$QueuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Queue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueFindFirstArgs} args - Arguments to find a Queue
     * @example
     * // Get one Queue
     * const queue = await prisma.queue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QueueFindFirstArgs>(args?: SelectSubset<T, QueueFindFirstArgs<ExtArgs>>): Prisma__QueueClient<$Result.GetResult<Prisma.$QueuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Queue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueFindFirstOrThrowArgs} args - Arguments to find a Queue
     * @example
     * // Get one Queue
     * const queue = await prisma.queue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QueueFindFirstOrThrowArgs>(args?: SelectSubset<T, QueueFindFirstOrThrowArgs<ExtArgs>>): Prisma__QueueClient<$Result.GetResult<Prisma.$QueuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Queues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Queues
     * const queues = await prisma.queue.findMany()
     * 
     * // Get first 10 Queues
     * const queues = await prisma.queue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const queueWithIdOnly = await prisma.queue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QueueFindManyArgs>(args?: SelectSubset<T, QueueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Queue.
     * @param {QueueCreateArgs} args - Arguments to create a Queue.
     * @example
     * // Create one Queue
     * const Queue = await prisma.queue.create({
     *   data: {
     *     // ... data to create a Queue
     *   }
     * })
     * 
     */
    create<T extends QueueCreateArgs>(args: SelectSubset<T, QueueCreateArgs<ExtArgs>>): Prisma__QueueClient<$Result.GetResult<Prisma.$QueuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Queues.
     * @param {QueueCreateManyArgs} args - Arguments to create many Queues.
     * @example
     * // Create many Queues
     * const queue = await prisma.queue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QueueCreateManyArgs>(args?: SelectSubset<T, QueueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Queues and returns the data saved in the database.
     * @param {QueueCreateManyAndReturnArgs} args - Arguments to create many Queues.
     * @example
     * // Create many Queues
     * const queue = await prisma.queue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Queues and only return the `id`
     * const queueWithIdOnly = await prisma.queue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QueueCreateManyAndReturnArgs>(args?: SelectSubset<T, QueueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueuePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Queue.
     * @param {QueueDeleteArgs} args - Arguments to delete one Queue.
     * @example
     * // Delete one Queue
     * const Queue = await prisma.queue.delete({
     *   where: {
     *     // ... filter to delete one Queue
     *   }
     * })
     * 
     */
    delete<T extends QueueDeleteArgs>(args: SelectSubset<T, QueueDeleteArgs<ExtArgs>>): Prisma__QueueClient<$Result.GetResult<Prisma.$QueuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Queue.
     * @param {QueueUpdateArgs} args - Arguments to update one Queue.
     * @example
     * // Update one Queue
     * const queue = await prisma.queue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QueueUpdateArgs>(args: SelectSubset<T, QueueUpdateArgs<ExtArgs>>): Prisma__QueueClient<$Result.GetResult<Prisma.$QueuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Queues.
     * @param {QueueDeleteManyArgs} args - Arguments to filter Queues to delete.
     * @example
     * // Delete a few Queues
     * const { count } = await prisma.queue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QueueDeleteManyArgs>(args?: SelectSubset<T, QueueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Queues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Queues
     * const queue = await prisma.queue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QueueUpdateManyArgs>(args: SelectSubset<T, QueueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Queues and returns the data updated in the database.
     * @param {QueueUpdateManyAndReturnArgs} args - Arguments to update many Queues.
     * @example
     * // Update many Queues
     * const queue = await prisma.queue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Queues and only return the `id`
     * const queueWithIdOnly = await prisma.queue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QueueUpdateManyAndReturnArgs>(args: SelectSubset<T, QueueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueuePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Queue.
     * @param {QueueUpsertArgs} args - Arguments to update or create a Queue.
     * @example
     * // Update or create a Queue
     * const queue = await prisma.queue.upsert({
     *   create: {
     *     // ... data to create a Queue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Queue we want to update
     *   }
     * })
     */
    upsert<T extends QueueUpsertArgs>(args: SelectSubset<T, QueueUpsertArgs<ExtArgs>>): Prisma__QueueClient<$Result.GetResult<Prisma.$QueuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Queues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueCountArgs} args - Arguments to filter Queues to count.
     * @example
     * // Count the number of Queues
     * const count = await prisma.queue.count({
     *   where: {
     *     // ... the filter for the Queues we want to count
     *   }
     * })
    **/
    count<T extends QueueCountArgs>(
      args?: Subset<T, QueueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QueueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Queue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QueueAggregateArgs>(args: Subset<T, QueueAggregateArgs>): Prisma.PrismaPromise<GetQueueAggregateType<T>>

    /**
     * Group by Queue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QueueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QueueGroupByArgs['orderBy'] }
        : { orderBy?: QueueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QueueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQueueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Queue model
   */
  readonly fields: QueueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Queue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QueueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    entries<T extends Queue$entriesArgs<ExtArgs> = {}>(args?: Subset<T, Queue$entriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueueEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Queue model
   */ 
  interface QueueFieldRefs {
    readonly id: FieldRef<"Queue", 'Int'>
    readonly start: FieldRef<"Queue", 'DateTime'>
    readonly end: FieldRef<"Queue", 'DateTime'>
    readonly status: FieldRef<"Queue", 'QueueStatus'>
  }
    

  // Custom InputTypes
  /**
   * Queue findUnique
   */
  export type QueueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Queue
     */
    select?: QueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Queue
     */
    omit?: QueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueInclude<ExtArgs> | null
    /**
     * Filter, which Queue to fetch.
     */
    where: QueueWhereUniqueInput
  }

  /**
   * Queue findUniqueOrThrow
   */
  export type QueueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Queue
     */
    select?: QueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Queue
     */
    omit?: QueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueInclude<ExtArgs> | null
    /**
     * Filter, which Queue to fetch.
     */
    where: QueueWhereUniqueInput
  }

  /**
   * Queue findFirst
   */
  export type QueueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Queue
     */
    select?: QueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Queue
     */
    omit?: QueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueInclude<ExtArgs> | null
    /**
     * Filter, which Queue to fetch.
     */
    where?: QueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Queues to fetch.
     */
    orderBy?: QueueOrderByWithRelationInput | QueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Queues.
     */
    cursor?: QueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Queues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Queues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Queues.
     */
    distinct?: QueueScalarFieldEnum | QueueScalarFieldEnum[]
  }

  /**
   * Queue findFirstOrThrow
   */
  export type QueueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Queue
     */
    select?: QueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Queue
     */
    omit?: QueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueInclude<ExtArgs> | null
    /**
     * Filter, which Queue to fetch.
     */
    where?: QueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Queues to fetch.
     */
    orderBy?: QueueOrderByWithRelationInput | QueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Queues.
     */
    cursor?: QueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Queues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Queues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Queues.
     */
    distinct?: QueueScalarFieldEnum | QueueScalarFieldEnum[]
  }

  /**
   * Queue findMany
   */
  export type QueueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Queue
     */
    select?: QueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Queue
     */
    omit?: QueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueInclude<ExtArgs> | null
    /**
     * Filter, which Queues to fetch.
     */
    where?: QueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Queues to fetch.
     */
    orderBy?: QueueOrderByWithRelationInput | QueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Queues.
     */
    cursor?: QueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Queues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Queues.
     */
    skip?: number
    distinct?: QueueScalarFieldEnum | QueueScalarFieldEnum[]
  }

  /**
   * Queue create
   */
  export type QueueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Queue
     */
    select?: QueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Queue
     */
    omit?: QueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueInclude<ExtArgs> | null
    /**
     * The data needed to create a Queue.
     */
    data?: XOR<QueueCreateInput, QueueUncheckedCreateInput>
  }

  /**
   * Queue createMany
   */
  export type QueueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Queues.
     */
    data: QueueCreateManyInput | QueueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Queue createManyAndReturn
   */
  export type QueueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Queue
     */
    select?: QueueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Queue
     */
    omit?: QueueOmit<ExtArgs> | null
    /**
     * The data used to create many Queues.
     */
    data: QueueCreateManyInput | QueueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Queue update
   */
  export type QueueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Queue
     */
    select?: QueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Queue
     */
    omit?: QueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueInclude<ExtArgs> | null
    /**
     * The data needed to update a Queue.
     */
    data: XOR<QueueUpdateInput, QueueUncheckedUpdateInput>
    /**
     * Choose, which Queue to update.
     */
    where: QueueWhereUniqueInput
  }

  /**
   * Queue updateMany
   */
  export type QueueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Queues.
     */
    data: XOR<QueueUpdateManyMutationInput, QueueUncheckedUpdateManyInput>
    /**
     * Filter which Queues to update
     */
    where?: QueueWhereInput
    /**
     * Limit how many Queues to update.
     */
    limit?: number
  }

  /**
   * Queue updateManyAndReturn
   */
  export type QueueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Queue
     */
    select?: QueueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Queue
     */
    omit?: QueueOmit<ExtArgs> | null
    /**
     * The data used to update Queues.
     */
    data: XOR<QueueUpdateManyMutationInput, QueueUncheckedUpdateManyInput>
    /**
     * Filter which Queues to update
     */
    where?: QueueWhereInput
    /**
     * Limit how many Queues to update.
     */
    limit?: number
  }

  /**
   * Queue upsert
   */
  export type QueueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Queue
     */
    select?: QueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Queue
     */
    omit?: QueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueInclude<ExtArgs> | null
    /**
     * The filter to search for the Queue to update in case it exists.
     */
    where: QueueWhereUniqueInput
    /**
     * In case the Queue found by the `where` argument doesn't exist, create a new Queue with this data.
     */
    create: XOR<QueueCreateInput, QueueUncheckedCreateInput>
    /**
     * In case the Queue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QueueUpdateInput, QueueUncheckedUpdateInput>
  }

  /**
   * Queue delete
   */
  export type QueueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Queue
     */
    select?: QueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Queue
     */
    omit?: QueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueInclude<ExtArgs> | null
    /**
     * Filter which Queue to delete.
     */
    where: QueueWhereUniqueInput
  }

  /**
   * Queue deleteMany
   */
  export type QueueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Queues to delete
     */
    where?: QueueWhereInput
    /**
     * Limit how many Queues to delete.
     */
    limit?: number
  }

  /**
   * Queue.entries
   */
  export type Queue$entriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueEntry
     */
    select?: QueueEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueEntry
     */
    omit?: QueueEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueEntryInclude<ExtArgs> | null
    where?: QueueEntryWhereInput
    orderBy?: QueueEntryOrderByWithRelationInput | QueueEntryOrderByWithRelationInput[]
    cursor?: QueueEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QueueEntryScalarFieldEnum | QueueEntryScalarFieldEnum[]
  }

  /**
   * Queue without action
   */
  export type QueueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Queue
     */
    select?: QueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Queue
     */
    omit?: QueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueInclude<ExtArgs> | null
  }


  /**
   * Model QueueEntry
   */

  export type AggregateQueueEntry = {
    _count: QueueEntryCountAggregateOutputType | null
    _avg: QueueEntryAvgAggregateOutputType | null
    _sum: QueueEntrySumAggregateOutputType | null
    _min: QueueEntryMinAggregateOutputType | null
    _max: QueueEntryMaxAggregateOutputType | null
  }

  export type QueueEntryAvgAggregateOutputType = {
    id: number | null
    token: number | null
    queueId: number | null
    patientId: number | null
  }

  export type QueueEntrySumAggregateOutputType = {
    id: number | null
    token: number | null
    queueId: number | null
    patientId: number | null
  }

  export type QueueEntryMinAggregateOutputType = {
    id: number | null
    token: number | null
    status: $Enums.VisitStatus | null
    queueId: number | null
    patientId: number | null
    time: Date | null
  }

  export type QueueEntryMaxAggregateOutputType = {
    id: number | null
    token: number | null
    status: $Enums.VisitStatus | null
    queueId: number | null
    patientId: number | null
    time: Date | null
  }

  export type QueueEntryCountAggregateOutputType = {
    id: number
    token: number
    status: number
    queueId: number
    patientId: number
    time: number
    _all: number
  }


  export type QueueEntryAvgAggregateInputType = {
    id?: true
    token?: true
    queueId?: true
    patientId?: true
  }

  export type QueueEntrySumAggregateInputType = {
    id?: true
    token?: true
    queueId?: true
    patientId?: true
  }

  export type QueueEntryMinAggregateInputType = {
    id?: true
    token?: true
    status?: true
    queueId?: true
    patientId?: true
    time?: true
  }

  export type QueueEntryMaxAggregateInputType = {
    id?: true
    token?: true
    status?: true
    queueId?: true
    patientId?: true
    time?: true
  }

  export type QueueEntryCountAggregateInputType = {
    id?: true
    token?: true
    status?: true
    queueId?: true
    patientId?: true
    time?: true
    _all?: true
  }

  export type QueueEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QueueEntry to aggregate.
     */
    where?: QueueEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QueueEntries to fetch.
     */
    orderBy?: QueueEntryOrderByWithRelationInput | QueueEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QueueEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QueueEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QueueEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QueueEntries
    **/
    _count?: true | QueueEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QueueEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QueueEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QueueEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QueueEntryMaxAggregateInputType
  }

  export type GetQueueEntryAggregateType<T extends QueueEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateQueueEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQueueEntry[P]>
      : GetScalarType<T[P], AggregateQueueEntry[P]>
  }




  export type QueueEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QueueEntryWhereInput
    orderBy?: QueueEntryOrderByWithAggregationInput | QueueEntryOrderByWithAggregationInput[]
    by: QueueEntryScalarFieldEnum[] | QueueEntryScalarFieldEnum
    having?: QueueEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QueueEntryCountAggregateInputType | true
    _avg?: QueueEntryAvgAggregateInputType
    _sum?: QueueEntrySumAggregateInputType
    _min?: QueueEntryMinAggregateInputType
    _max?: QueueEntryMaxAggregateInputType
  }

  export type QueueEntryGroupByOutputType = {
    id: number
    token: number
    status: $Enums.VisitStatus
    queueId: number
    patientId: number
    time: Date
    _count: QueueEntryCountAggregateOutputType | null
    _avg: QueueEntryAvgAggregateOutputType | null
    _sum: QueueEntrySumAggregateOutputType | null
    _min: QueueEntryMinAggregateOutputType | null
    _max: QueueEntryMaxAggregateOutputType | null
  }

  type GetQueueEntryGroupByPayload<T extends QueueEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QueueEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QueueEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QueueEntryGroupByOutputType[P]>
            : GetScalarType<T[P], QueueEntryGroupByOutputType[P]>
        }
      >
    >


  export type QueueEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    status?: boolean
    queueId?: boolean
    patientId?: boolean
    time?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    queue?: boolean | QueueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["queueEntry"]>

  export type QueueEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    status?: boolean
    queueId?: boolean
    patientId?: boolean
    time?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    queue?: boolean | QueueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["queueEntry"]>

  export type QueueEntrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    status?: boolean
    queueId?: boolean
    patientId?: boolean
    time?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    queue?: boolean | QueueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["queueEntry"]>

  export type QueueEntrySelectScalar = {
    id?: boolean
    token?: boolean
    status?: boolean
    queueId?: boolean
    patientId?: boolean
    time?: boolean
  }

  export type QueueEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "status" | "queueId" | "patientId" | "time", ExtArgs["result"]["queueEntry"]>
  export type QueueEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    queue?: boolean | QueueDefaultArgs<ExtArgs>
  }
  export type QueueEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    queue?: boolean | QueueDefaultArgs<ExtArgs>
  }
  export type QueueEntryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    queue?: boolean | QueueDefaultArgs<ExtArgs>
  }

  export type $QueueEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QueueEntry"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      queue: Prisma.$QueuePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      token: number
      status: $Enums.VisitStatus
      queueId: number
      patientId: number
      time: Date
    }, ExtArgs["result"]["queueEntry"]>
    composites: {}
  }

  type QueueEntryGetPayload<S extends boolean | null | undefined | QueueEntryDefaultArgs> = $Result.GetResult<Prisma.$QueueEntryPayload, S>

  type QueueEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QueueEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QueueEntryCountAggregateInputType | true
    }

  export interface QueueEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QueueEntry'], meta: { name: 'QueueEntry' } }
    /**
     * Find zero or one QueueEntry that matches the filter.
     * @param {QueueEntryFindUniqueArgs} args - Arguments to find a QueueEntry
     * @example
     * // Get one QueueEntry
     * const queueEntry = await prisma.queueEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QueueEntryFindUniqueArgs>(args: SelectSubset<T, QueueEntryFindUniqueArgs<ExtArgs>>): Prisma__QueueEntryClient<$Result.GetResult<Prisma.$QueueEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QueueEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QueueEntryFindUniqueOrThrowArgs} args - Arguments to find a QueueEntry
     * @example
     * // Get one QueueEntry
     * const queueEntry = await prisma.queueEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QueueEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, QueueEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QueueEntryClient<$Result.GetResult<Prisma.$QueueEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QueueEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueEntryFindFirstArgs} args - Arguments to find a QueueEntry
     * @example
     * // Get one QueueEntry
     * const queueEntry = await prisma.queueEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QueueEntryFindFirstArgs>(args?: SelectSubset<T, QueueEntryFindFirstArgs<ExtArgs>>): Prisma__QueueEntryClient<$Result.GetResult<Prisma.$QueueEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QueueEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueEntryFindFirstOrThrowArgs} args - Arguments to find a QueueEntry
     * @example
     * // Get one QueueEntry
     * const queueEntry = await prisma.queueEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QueueEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, QueueEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__QueueEntryClient<$Result.GetResult<Prisma.$QueueEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QueueEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QueueEntries
     * const queueEntries = await prisma.queueEntry.findMany()
     * 
     * // Get first 10 QueueEntries
     * const queueEntries = await prisma.queueEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const queueEntryWithIdOnly = await prisma.queueEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QueueEntryFindManyArgs>(args?: SelectSubset<T, QueueEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueueEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QueueEntry.
     * @param {QueueEntryCreateArgs} args - Arguments to create a QueueEntry.
     * @example
     * // Create one QueueEntry
     * const QueueEntry = await prisma.queueEntry.create({
     *   data: {
     *     // ... data to create a QueueEntry
     *   }
     * })
     * 
     */
    create<T extends QueueEntryCreateArgs>(args: SelectSubset<T, QueueEntryCreateArgs<ExtArgs>>): Prisma__QueueEntryClient<$Result.GetResult<Prisma.$QueueEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QueueEntries.
     * @param {QueueEntryCreateManyArgs} args - Arguments to create many QueueEntries.
     * @example
     * // Create many QueueEntries
     * const queueEntry = await prisma.queueEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QueueEntryCreateManyArgs>(args?: SelectSubset<T, QueueEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QueueEntries and returns the data saved in the database.
     * @param {QueueEntryCreateManyAndReturnArgs} args - Arguments to create many QueueEntries.
     * @example
     * // Create many QueueEntries
     * const queueEntry = await prisma.queueEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QueueEntries and only return the `id`
     * const queueEntryWithIdOnly = await prisma.queueEntry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QueueEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, QueueEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueueEntryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QueueEntry.
     * @param {QueueEntryDeleteArgs} args - Arguments to delete one QueueEntry.
     * @example
     * // Delete one QueueEntry
     * const QueueEntry = await prisma.queueEntry.delete({
     *   where: {
     *     // ... filter to delete one QueueEntry
     *   }
     * })
     * 
     */
    delete<T extends QueueEntryDeleteArgs>(args: SelectSubset<T, QueueEntryDeleteArgs<ExtArgs>>): Prisma__QueueEntryClient<$Result.GetResult<Prisma.$QueueEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QueueEntry.
     * @param {QueueEntryUpdateArgs} args - Arguments to update one QueueEntry.
     * @example
     * // Update one QueueEntry
     * const queueEntry = await prisma.queueEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QueueEntryUpdateArgs>(args: SelectSubset<T, QueueEntryUpdateArgs<ExtArgs>>): Prisma__QueueEntryClient<$Result.GetResult<Prisma.$QueueEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QueueEntries.
     * @param {QueueEntryDeleteManyArgs} args - Arguments to filter QueueEntries to delete.
     * @example
     * // Delete a few QueueEntries
     * const { count } = await prisma.queueEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QueueEntryDeleteManyArgs>(args?: SelectSubset<T, QueueEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QueueEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QueueEntries
     * const queueEntry = await prisma.queueEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QueueEntryUpdateManyArgs>(args: SelectSubset<T, QueueEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QueueEntries and returns the data updated in the database.
     * @param {QueueEntryUpdateManyAndReturnArgs} args - Arguments to update many QueueEntries.
     * @example
     * // Update many QueueEntries
     * const queueEntry = await prisma.queueEntry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QueueEntries and only return the `id`
     * const queueEntryWithIdOnly = await prisma.queueEntry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QueueEntryUpdateManyAndReturnArgs>(args: SelectSubset<T, QueueEntryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueueEntryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QueueEntry.
     * @param {QueueEntryUpsertArgs} args - Arguments to update or create a QueueEntry.
     * @example
     * // Update or create a QueueEntry
     * const queueEntry = await prisma.queueEntry.upsert({
     *   create: {
     *     // ... data to create a QueueEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QueueEntry we want to update
     *   }
     * })
     */
    upsert<T extends QueueEntryUpsertArgs>(args: SelectSubset<T, QueueEntryUpsertArgs<ExtArgs>>): Prisma__QueueEntryClient<$Result.GetResult<Prisma.$QueueEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QueueEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueEntryCountArgs} args - Arguments to filter QueueEntries to count.
     * @example
     * // Count the number of QueueEntries
     * const count = await prisma.queueEntry.count({
     *   where: {
     *     // ... the filter for the QueueEntries we want to count
     *   }
     * })
    **/
    count<T extends QueueEntryCountArgs>(
      args?: Subset<T, QueueEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QueueEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QueueEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QueueEntryAggregateArgs>(args: Subset<T, QueueEntryAggregateArgs>): Prisma.PrismaPromise<GetQueueEntryAggregateType<T>>

    /**
     * Group by QueueEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QueueEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QueueEntryGroupByArgs['orderBy'] }
        : { orderBy?: QueueEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QueueEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQueueEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QueueEntry model
   */
  readonly fields: QueueEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QueueEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QueueEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    queue<T extends QueueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QueueDefaultArgs<ExtArgs>>): Prisma__QueueClient<$Result.GetResult<Prisma.$QueuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QueueEntry model
   */ 
  interface QueueEntryFieldRefs {
    readonly id: FieldRef<"QueueEntry", 'Int'>
    readonly token: FieldRef<"QueueEntry", 'Int'>
    readonly status: FieldRef<"QueueEntry", 'VisitStatus'>
    readonly queueId: FieldRef<"QueueEntry", 'Int'>
    readonly patientId: FieldRef<"QueueEntry", 'Int'>
    readonly time: FieldRef<"QueueEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QueueEntry findUnique
   */
  export type QueueEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueEntry
     */
    select?: QueueEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueEntry
     */
    omit?: QueueEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueEntryInclude<ExtArgs> | null
    /**
     * Filter, which QueueEntry to fetch.
     */
    where: QueueEntryWhereUniqueInput
  }

  /**
   * QueueEntry findUniqueOrThrow
   */
  export type QueueEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueEntry
     */
    select?: QueueEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueEntry
     */
    omit?: QueueEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueEntryInclude<ExtArgs> | null
    /**
     * Filter, which QueueEntry to fetch.
     */
    where: QueueEntryWhereUniqueInput
  }

  /**
   * QueueEntry findFirst
   */
  export type QueueEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueEntry
     */
    select?: QueueEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueEntry
     */
    omit?: QueueEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueEntryInclude<ExtArgs> | null
    /**
     * Filter, which QueueEntry to fetch.
     */
    where?: QueueEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QueueEntries to fetch.
     */
    orderBy?: QueueEntryOrderByWithRelationInput | QueueEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QueueEntries.
     */
    cursor?: QueueEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QueueEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QueueEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QueueEntries.
     */
    distinct?: QueueEntryScalarFieldEnum | QueueEntryScalarFieldEnum[]
  }

  /**
   * QueueEntry findFirstOrThrow
   */
  export type QueueEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueEntry
     */
    select?: QueueEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueEntry
     */
    omit?: QueueEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueEntryInclude<ExtArgs> | null
    /**
     * Filter, which QueueEntry to fetch.
     */
    where?: QueueEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QueueEntries to fetch.
     */
    orderBy?: QueueEntryOrderByWithRelationInput | QueueEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QueueEntries.
     */
    cursor?: QueueEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QueueEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QueueEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QueueEntries.
     */
    distinct?: QueueEntryScalarFieldEnum | QueueEntryScalarFieldEnum[]
  }

  /**
   * QueueEntry findMany
   */
  export type QueueEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueEntry
     */
    select?: QueueEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueEntry
     */
    omit?: QueueEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueEntryInclude<ExtArgs> | null
    /**
     * Filter, which QueueEntries to fetch.
     */
    where?: QueueEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QueueEntries to fetch.
     */
    orderBy?: QueueEntryOrderByWithRelationInput | QueueEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QueueEntries.
     */
    cursor?: QueueEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QueueEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QueueEntries.
     */
    skip?: number
    distinct?: QueueEntryScalarFieldEnum | QueueEntryScalarFieldEnum[]
  }

  /**
   * QueueEntry create
   */
  export type QueueEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueEntry
     */
    select?: QueueEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueEntry
     */
    omit?: QueueEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a QueueEntry.
     */
    data: XOR<QueueEntryCreateInput, QueueEntryUncheckedCreateInput>
  }

  /**
   * QueueEntry createMany
   */
  export type QueueEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QueueEntries.
     */
    data: QueueEntryCreateManyInput | QueueEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QueueEntry createManyAndReturn
   */
  export type QueueEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueEntry
     */
    select?: QueueEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QueueEntry
     */
    omit?: QueueEntryOmit<ExtArgs> | null
    /**
     * The data used to create many QueueEntries.
     */
    data: QueueEntryCreateManyInput | QueueEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QueueEntry update
   */
  export type QueueEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueEntry
     */
    select?: QueueEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueEntry
     */
    omit?: QueueEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a QueueEntry.
     */
    data: XOR<QueueEntryUpdateInput, QueueEntryUncheckedUpdateInput>
    /**
     * Choose, which QueueEntry to update.
     */
    where: QueueEntryWhereUniqueInput
  }

  /**
   * QueueEntry updateMany
   */
  export type QueueEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QueueEntries.
     */
    data: XOR<QueueEntryUpdateManyMutationInput, QueueEntryUncheckedUpdateManyInput>
    /**
     * Filter which QueueEntries to update
     */
    where?: QueueEntryWhereInput
    /**
     * Limit how many QueueEntries to update.
     */
    limit?: number
  }

  /**
   * QueueEntry updateManyAndReturn
   */
  export type QueueEntryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueEntry
     */
    select?: QueueEntrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QueueEntry
     */
    omit?: QueueEntryOmit<ExtArgs> | null
    /**
     * The data used to update QueueEntries.
     */
    data: XOR<QueueEntryUpdateManyMutationInput, QueueEntryUncheckedUpdateManyInput>
    /**
     * Filter which QueueEntries to update
     */
    where?: QueueEntryWhereInput
    /**
     * Limit how many QueueEntries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueEntryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QueueEntry upsert
   */
  export type QueueEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueEntry
     */
    select?: QueueEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueEntry
     */
    omit?: QueueEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the QueueEntry to update in case it exists.
     */
    where: QueueEntryWhereUniqueInput
    /**
     * In case the QueueEntry found by the `where` argument doesn't exist, create a new QueueEntry with this data.
     */
    create: XOR<QueueEntryCreateInput, QueueEntryUncheckedCreateInput>
    /**
     * In case the QueueEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QueueEntryUpdateInput, QueueEntryUncheckedUpdateInput>
  }

  /**
   * QueueEntry delete
   */
  export type QueueEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueEntry
     */
    select?: QueueEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueEntry
     */
    omit?: QueueEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueEntryInclude<ExtArgs> | null
    /**
     * Filter which QueueEntry to delete.
     */
    where: QueueEntryWhereUniqueInput
  }

  /**
   * QueueEntry deleteMany
   */
  export type QueueEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QueueEntries to delete
     */
    where?: QueueEntryWhereInput
    /**
     * Limit how many QueueEntries to delete.
     */
    limit?: number
  }

  /**
   * QueueEntry without action
   */
  export type QueueEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueEntry
     */
    select?: QueueEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueEntry
     */
    omit?: QueueEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueEntryInclude<ExtArgs> | null
  }


  /**
   * Model DrugBrand
   */

  export type AggregateDrugBrand = {
    _count: DrugBrandCountAggregateOutputType | null
    _avg: DrugBrandAvgAggregateOutputType | null
    _sum: DrugBrandSumAggregateOutputType | null
    _min: DrugBrandMinAggregateOutputType | null
    _max: DrugBrandMaxAggregateOutputType | null
  }

  export type DrugBrandAvgAggregateOutputType = {
    id: number | null
  }

  export type DrugBrandSumAggregateOutputType = {
    id: number | null
  }

  export type DrugBrandMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
  }

  export type DrugBrandMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
  }

  export type DrugBrandCountAggregateOutputType = {
    id: number
    name: number
    description: number
    _all: number
  }


  export type DrugBrandAvgAggregateInputType = {
    id?: true
  }

  export type DrugBrandSumAggregateInputType = {
    id?: true
  }

  export type DrugBrandMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type DrugBrandMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type DrugBrandCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    _all?: true
  }

  export type DrugBrandAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DrugBrand to aggregate.
     */
    where?: DrugBrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DrugBrands to fetch.
     */
    orderBy?: DrugBrandOrderByWithRelationInput | DrugBrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DrugBrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DrugBrands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DrugBrands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DrugBrands
    **/
    _count?: true | DrugBrandCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DrugBrandAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DrugBrandSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DrugBrandMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DrugBrandMaxAggregateInputType
  }

  export type GetDrugBrandAggregateType<T extends DrugBrandAggregateArgs> = {
        [P in keyof T & keyof AggregateDrugBrand]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDrugBrand[P]>
      : GetScalarType<T[P], AggregateDrugBrand[P]>
  }




  export type DrugBrandGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DrugBrandWhereInput
    orderBy?: DrugBrandOrderByWithAggregationInput | DrugBrandOrderByWithAggregationInput[]
    by: DrugBrandScalarFieldEnum[] | DrugBrandScalarFieldEnum
    having?: DrugBrandScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DrugBrandCountAggregateInputType | true
    _avg?: DrugBrandAvgAggregateInputType
    _sum?: DrugBrandSumAggregateInputType
    _min?: DrugBrandMinAggregateInputType
    _max?: DrugBrandMaxAggregateInputType
  }

  export type DrugBrandGroupByOutputType = {
    id: number
    name: string
    description: string | null
    _count: DrugBrandCountAggregateOutputType | null
    _avg: DrugBrandAvgAggregateOutputType | null
    _sum: DrugBrandSumAggregateOutputType | null
    _min: DrugBrandMinAggregateOutputType | null
    _max: DrugBrandMaxAggregateOutputType | null
  }

  type GetDrugBrandGroupByPayload<T extends DrugBrandGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DrugBrandGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DrugBrandGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DrugBrandGroupByOutputType[P]>
            : GetScalarType<T[P], DrugBrandGroupByOutputType[P]>
        }
      >
    >


  export type DrugBrandSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    Batch?: boolean | DrugBrand$BatchArgs<ExtArgs>
    BatchHistory?: boolean | DrugBrand$BatchHistoryArgs<ExtArgs>
    Issue?: boolean | DrugBrand$IssueArgs<ExtArgs>
    _count?: boolean | DrugBrandCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["drugBrand"]>

  export type DrugBrandSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["drugBrand"]>

  export type DrugBrandSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["drugBrand"]>

  export type DrugBrandSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
  }

  export type DrugBrandOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description", ExtArgs["result"]["drugBrand"]>
  export type DrugBrandInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Batch?: boolean | DrugBrand$BatchArgs<ExtArgs>
    BatchHistory?: boolean | DrugBrand$BatchHistoryArgs<ExtArgs>
    Issue?: boolean | DrugBrand$IssueArgs<ExtArgs>
    _count?: boolean | DrugBrandCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DrugBrandIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DrugBrandIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DrugBrandPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DrugBrand"
    objects: {
      Batch: Prisma.$BatchPayload<ExtArgs>[]
      BatchHistory: Prisma.$BatchHistoryPayload<ExtArgs>[]
      Issue: Prisma.$IssuePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
    }, ExtArgs["result"]["drugBrand"]>
    composites: {}
  }

  type DrugBrandGetPayload<S extends boolean | null | undefined | DrugBrandDefaultArgs> = $Result.GetResult<Prisma.$DrugBrandPayload, S>

  type DrugBrandCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DrugBrandFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DrugBrandCountAggregateInputType | true
    }

  export interface DrugBrandDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DrugBrand'], meta: { name: 'DrugBrand' } }
    /**
     * Find zero or one DrugBrand that matches the filter.
     * @param {DrugBrandFindUniqueArgs} args - Arguments to find a DrugBrand
     * @example
     * // Get one DrugBrand
     * const drugBrand = await prisma.drugBrand.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DrugBrandFindUniqueArgs>(args: SelectSubset<T, DrugBrandFindUniqueArgs<ExtArgs>>): Prisma__DrugBrandClient<$Result.GetResult<Prisma.$DrugBrandPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DrugBrand that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DrugBrandFindUniqueOrThrowArgs} args - Arguments to find a DrugBrand
     * @example
     * // Get one DrugBrand
     * const drugBrand = await prisma.drugBrand.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DrugBrandFindUniqueOrThrowArgs>(args: SelectSubset<T, DrugBrandFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DrugBrandClient<$Result.GetResult<Prisma.$DrugBrandPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DrugBrand that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrugBrandFindFirstArgs} args - Arguments to find a DrugBrand
     * @example
     * // Get one DrugBrand
     * const drugBrand = await prisma.drugBrand.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DrugBrandFindFirstArgs>(args?: SelectSubset<T, DrugBrandFindFirstArgs<ExtArgs>>): Prisma__DrugBrandClient<$Result.GetResult<Prisma.$DrugBrandPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DrugBrand that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrugBrandFindFirstOrThrowArgs} args - Arguments to find a DrugBrand
     * @example
     * // Get one DrugBrand
     * const drugBrand = await prisma.drugBrand.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DrugBrandFindFirstOrThrowArgs>(args?: SelectSubset<T, DrugBrandFindFirstOrThrowArgs<ExtArgs>>): Prisma__DrugBrandClient<$Result.GetResult<Prisma.$DrugBrandPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DrugBrands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrugBrandFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DrugBrands
     * const drugBrands = await prisma.drugBrand.findMany()
     * 
     * // Get first 10 DrugBrands
     * const drugBrands = await prisma.drugBrand.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const drugBrandWithIdOnly = await prisma.drugBrand.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DrugBrandFindManyArgs>(args?: SelectSubset<T, DrugBrandFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DrugBrandPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DrugBrand.
     * @param {DrugBrandCreateArgs} args - Arguments to create a DrugBrand.
     * @example
     * // Create one DrugBrand
     * const DrugBrand = await prisma.drugBrand.create({
     *   data: {
     *     // ... data to create a DrugBrand
     *   }
     * })
     * 
     */
    create<T extends DrugBrandCreateArgs>(args: SelectSubset<T, DrugBrandCreateArgs<ExtArgs>>): Prisma__DrugBrandClient<$Result.GetResult<Prisma.$DrugBrandPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DrugBrands.
     * @param {DrugBrandCreateManyArgs} args - Arguments to create many DrugBrands.
     * @example
     * // Create many DrugBrands
     * const drugBrand = await prisma.drugBrand.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DrugBrandCreateManyArgs>(args?: SelectSubset<T, DrugBrandCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DrugBrands and returns the data saved in the database.
     * @param {DrugBrandCreateManyAndReturnArgs} args - Arguments to create many DrugBrands.
     * @example
     * // Create many DrugBrands
     * const drugBrand = await prisma.drugBrand.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DrugBrands and only return the `id`
     * const drugBrandWithIdOnly = await prisma.drugBrand.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DrugBrandCreateManyAndReturnArgs>(args?: SelectSubset<T, DrugBrandCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DrugBrandPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DrugBrand.
     * @param {DrugBrandDeleteArgs} args - Arguments to delete one DrugBrand.
     * @example
     * // Delete one DrugBrand
     * const DrugBrand = await prisma.drugBrand.delete({
     *   where: {
     *     // ... filter to delete one DrugBrand
     *   }
     * })
     * 
     */
    delete<T extends DrugBrandDeleteArgs>(args: SelectSubset<T, DrugBrandDeleteArgs<ExtArgs>>): Prisma__DrugBrandClient<$Result.GetResult<Prisma.$DrugBrandPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DrugBrand.
     * @param {DrugBrandUpdateArgs} args - Arguments to update one DrugBrand.
     * @example
     * // Update one DrugBrand
     * const drugBrand = await prisma.drugBrand.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DrugBrandUpdateArgs>(args: SelectSubset<T, DrugBrandUpdateArgs<ExtArgs>>): Prisma__DrugBrandClient<$Result.GetResult<Prisma.$DrugBrandPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DrugBrands.
     * @param {DrugBrandDeleteManyArgs} args - Arguments to filter DrugBrands to delete.
     * @example
     * // Delete a few DrugBrands
     * const { count } = await prisma.drugBrand.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DrugBrandDeleteManyArgs>(args?: SelectSubset<T, DrugBrandDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DrugBrands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrugBrandUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DrugBrands
     * const drugBrand = await prisma.drugBrand.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DrugBrandUpdateManyArgs>(args: SelectSubset<T, DrugBrandUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DrugBrands and returns the data updated in the database.
     * @param {DrugBrandUpdateManyAndReturnArgs} args - Arguments to update many DrugBrands.
     * @example
     * // Update many DrugBrands
     * const drugBrand = await prisma.drugBrand.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DrugBrands and only return the `id`
     * const drugBrandWithIdOnly = await prisma.drugBrand.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DrugBrandUpdateManyAndReturnArgs>(args: SelectSubset<T, DrugBrandUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DrugBrandPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DrugBrand.
     * @param {DrugBrandUpsertArgs} args - Arguments to update or create a DrugBrand.
     * @example
     * // Update or create a DrugBrand
     * const drugBrand = await prisma.drugBrand.upsert({
     *   create: {
     *     // ... data to create a DrugBrand
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DrugBrand we want to update
     *   }
     * })
     */
    upsert<T extends DrugBrandUpsertArgs>(args: SelectSubset<T, DrugBrandUpsertArgs<ExtArgs>>): Prisma__DrugBrandClient<$Result.GetResult<Prisma.$DrugBrandPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DrugBrands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrugBrandCountArgs} args - Arguments to filter DrugBrands to count.
     * @example
     * // Count the number of DrugBrands
     * const count = await prisma.drugBrand.count({
     *   where: {
     *     // ... the filter for the DrugBrands we want to count
     *   }
     * })
    **/
    count<T extends DrugBrandCountArgs>(
      args?: Subset<T, DrugBrandCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DrugBrandCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DrugBrand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrugBrandAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DrugBrandAggregateArgs>(args: Subset<T, DrugBrandAggregateArgs>): Prisma.PrismaPromise<GetDrugBrandAggregateType<T>>

    /**
     * Group by DrugBrand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrugBrandGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DrugBrandGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DrugBrandGroupByArgs['orderBy'] }
        : { orderBy?: DrugBrandGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DrugBrandGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDrugBrandGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DrugBrand model
   */
  readonly fields: DrugBrandFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DrugBrand.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DrugBrandClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Batch<T extends DrugBrand$BatchArgs<ExtArgs> = {}>(args?: Subset<T, DrugBrand$BatchArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    BatchHistory<T extends DrugBrand$BatchHistoryArgs<ExtArgs> = {}>(args?: Subset<T, DrugBrand$BatchHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Issue<T extends DrugBrand$IssueArgs<ExtArgs> = {}>(args?: Subset<T, DrugBrand$IssueArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DrugBrand model
   */ 
  interface DrugBrandFieldRefs {
    readonly id: FieldRef<"DrugBrand", 'Int'>
    readonly name: FieldRef<"DrugBrand", 'String'>
    readonly description: FieldRef<"DrugBrand", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DrugBrand findUnique
   */
  export type DrugBrandFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrugBrand
     */
    select?: DrugBrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DrugBrand
     */
    omit?: DrugBrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrugBrandInclude<ExtArgs> | null
    /**
     * Filter, which DrugBrand to fetch.
     */
    where: DrugBrandWhereUniqueInput
  }

  /**
   * DrugBrand findUniqueOrThrow
   */
  export type DrugBrandFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrugBrand
     */
    select?: DrugBrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DrugBrand
     */
    omit?: DrugBrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrugBrandInclude<ExtArgs> | null
    /**
     * Filter, which DrugBrand to fetch.
     */
    where: DrugBrandWhereUniqueInput
  }

  /**
   * DrugBrand findFirst
   */
  export type DrugBrandFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrugBrand
     */
    select?: DrugBrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DrugBrand
     */
    omit?: DrugBrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrugBrandInclude<ExtArgs> | null
    /**
     * Filter, which DrugBrand to fetch.
     */
    where?: DrugBrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DrugBrands to fetch.
     */
    orderBy?: DrugBrandOrderByWithRelationInput | DrugBrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DrugBrands.
     */
    cursor?: DrugBrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DrugBrands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DrugBrands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DrugBrands.
     */
    distinct?: DrugBrandScalarFieldEnum | DrugBrandScalarFieldEnum[]
  }

  /**
   * DrugBrand findFirstOrThrow
   */
  export type DrugBrandFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrugBrand
     */
    select?: DrugBrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DrugBrand
     */
    omit?: DrugBrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrugBrandInclude<ExtArgs> | null
    /**
     * Filter, which DrugBrand to fetch.
     */
    where?: DrugBrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DrugBrands to fetch.
     */
    orderBy?: DrugBrandOrderByWithRelationInput | DrugBrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DrugBrands.
     */
    cursor?: DrugBrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DrugBrands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DrugBrands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DrugBrands.
     */
    distinct?: DrugBrandScalarFieldEnum | DrugBrandScalarFieldEnum[]
  }

  /**
   * DrugBrand findMany
   */
  export type DrugBrandFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrugBrand
     */
    select?: DrugBrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DrugBrand
     */
    omit?: DrugBrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrugBrandInclude<ExtArgs> | null
    /**
     * Filter, which DrugBrands to fetch.
     */
    where?: DrugBrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DrugBrands to fetch.
     */
    orderBy?: DrugBrandOrderByWithRelationInput | DrugBrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DrugBrands.
     */
    cursor?: DrugBrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DrugBrands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DrugBrands.
     */
    skip?: number
    distinct?: DrugBrandScalarFieldEnum | DrugBrandScalarFieldEnum[]
  }

  /**
   * DrugBrand create
   */
  export type DrugBrandCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrugBrand
     */
    select?: DrugBrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DrugBrand
     */
    omit?: DrugBrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrugBrandInclude<ExtArgs> | null
    /**
     * The data needed to create a DrugBrand.
     */
    data: XOR<DrugBrandCreateInput, DrugBrandUncheckedCreateInput>
  }

  /**
   * DrugBrand createMany
   */
  export type DrugBrandCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DrugBrands.
     */
    data: DrugBrandCreateManyInput | DrugBrandCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DrugBrand createManyAndReturn
   */
  export type DrugBrandCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrugBrand
     */
    select?: DrugBrandSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DrugBrand
     */
    omit?: DrugBrandOmit<ExtArgs> | null
    /**
     * The data used to create many DrugBrands.
     */
    data: DrugBrandCreateManyInput | DrugBrandCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DrugBrand update
   */
  export type DrugBrandUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrugBrand
     */
    select?: DrugBrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DrugBrand
     */
    omit?: DrugBrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrugBrandInclude<ExtArgs> | null
    /**
     * The data needed to update a DrugBrand.
     */
    data: XOR<DrugBrandUpdateInput, DrugBrandUncheckedUpdateInput>
    /**
     * Choose, which DrugBrand to update.
     */
    where: DrugBrandWhereUniqueInput
  }

  /**
   * DrugBrand updateMany
   */
  export type DrugBrandUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DrugBrands.
     */
    data: XOR<DrugBrandUpdateManyMutationInput, DrugBrandUncheckedUpdateManyInput>
    /**
     * Filter which DrugBrands to update
     */
    where?: DrugBrandWhereInput
    /**
     * Limit how many DrugBrands to update.
     */
    limit?: number
  }

  /**
   * DrugBrand updateManyAndReturn
   */
  export type DrugBrandUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrugBrand
     */
    select?: DrugBrandSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DrugBrand
     */
    omit?: DrugBrandOmit<ExtArgs> | null
    /**
     * The data used to update DrugBrands.
     */
    data: XOR<DrugBrandUpdateManyMutationInput, DrugBrandUncheckedUpdateManyInput>
    /**
     * Filter which DrugBrands to update
     */
    where?: DrugBrandWhereInput
    /**
     * Limit how many DrugBrands to update.
     */
    limit?: number
  }

  /**
   * DrugBrand upsert
   */
  export type DrugBrandUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrugBrand
     */
    select?: DrugBrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DrugBrand
     */
    omit?: DrugBrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrugBrandInclude<ExtArgs> | null
    /**
     * The filter to search for the DrugBrand to update in case it exists.
     */
    where: DrugBrandWhereUniqueInput
    /**
     * In case the DrugBrand found by the `where` argument doesn't exist, create a new DrugBrand with this data.
     */
    create: XOR<DrugBrandCreateInput, DrugBrandUncheckedCreateInput>
    /**
     * In case the DrugBrand was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DrugBrandUpdateInput, DrugBrandUncheckedUpdateInput>
  }

  /**
   * DrugBrand delete
   */
  export type DrugBrandDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrugBrand
     */
    select?: DrugBrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DrugBrand
     */
    omit?: DrugBrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrugBrandInclude<ExtArgs> | null
    /**
     * Filter which DrugBrand to delete.
     */
    where: DrugBrandWhereUniqueInput
  }

  /**
   * DrugBrand deleteMany
   */
  export type DrugBrandDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DrugBrands to delete
     */
    where?: DrugBrandWhereInput
    /**
     * Limit how many DrugBrands to delete.
     */
    limit?: number
  }

  /**
   * DrugBrand.Batch
   */
  export type DrugBrand$BatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    where?: BatchWhereInput
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    cursor?: BatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BatchScalarFieldEnum | BatchScalarFieldEnum[]
  }

  /**
   * DrugBrand.BatchHistory
   */
  export type DrugBrand$BatchHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchHistory
     */
    select?: BatchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchHistory
     */
    omit?: BatchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchHistoryInclude<ExtArgs> | null
    where?: BatchHistoryWhereInput
    orderBy?: BatchHistoryOrderByWithRelationInput | BatchHistoryOrderByWithRelationInput[]
    cursor?: BatchHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BatchHistoryScalarFieldEnum | BatchHistoryScalarFieldEnum[]
  }

  /**
   * DrugBrand.Issue
   */
  export type DrugBrand$IssueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issue
     */
    select?: IssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Issue
     */
    omit?: IssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueInclude<ExtArgs> | null
    where?: IssueWhereInput
    orderBy?: IssueOrderByWithRelationInput | IssueOrderByWithRelationInput[]
    cursor?: IssueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IssueScalarFieldEnum | IssueScalarFieldEnum[]
  }

  /**
   * DrugBrand without action
   */
  export type DrugBrandDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrugBrand
     */
    select?: DrugBrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DrugBrand
     */
    omit?: DrugBrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrugBrandInclude<ExtArgs> | null
  }


  /**
   * Model Drug
   */

  export type AggregateDrug = {
    _count: DrugCountAggregateOutputType | null
    _avg: DrugAvgAggregateOutputType | null
    _sum: DrugSumAggregateOutputType | null
    _min: DrugMinAggregateOutputType | null
    _max: DrugMaxAggregateOutputType | null
  }

  export type DrugAvgAggregateOutputType = {
    id: number | null
  }

  export type DrugSumAggregateOutputType = {
    id: number | null
  }

  export type DrugMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type DrugMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type DrugCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type DrugAvgAggregateInputType = {
    id?: true
  }

  export type DrugSumAggregateInputType = {
    id?: true
  }

  export type DrugMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type DrugMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type DrugCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type DrugAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Drug to aggregate.
     */
    where?: DrugWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drugs to fetch.
     */
    orderBy?: DrugOrderByWithRelationInput | DrugOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DrugWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drugs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drugs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Drugs
    **/
    _count?: true | DrugCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DrugAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DrugSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DrugMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DrugMaxAggregateInputType
  }

  export type GetDrugAggregateType<T extends DrugAggregateArgs> = {
        [P in keyof T & keyof AggregateDrug]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDrug[P]>
      : GetScalarType<T[P], AggregateDrug[P]>
  }




  export type DrugGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DrugWhereInput
    orderBy?: DrugOrderByWithAggregationInput | DrugOrderByWithAggregationInput[]
    by: DrugScalarFieldEnum[] | DrugScalarFieldEnum
    having?: DrugScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DrugCountAggregateInputType | true
    _avg?: DrugAvgAggregateInputType
    _sum?: DrugSumAggregateInputType
    _min?: DrugMinAggregateInputType
    _max?: DrugMaxAggregateInputType
  }

  export type DrugGroupByOutputType = {
    id: number
    name: string
    _count: DrugCountAggregateOutputType | null
    _avg: DrugAvgAggregateOutputType | null
    _sum: DrugSumAggregateOutputType | null
    _min: DrugMinAggregateOutputType | null
    _max: DrugMaxAggregateOutputType | null
  }

  type GetDrugGroupByPayload<T extends DrugGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DrugGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DrugGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DrugGroupByOutputType[P]>
            : GetScalarType<T[P], DrugGroupByOutputType[P]>
        }
      >
    >


  export type DrugSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    batch?: boolean | Drug$batchArgs<ExtArgs>
    BatchHistory?: boolean | Drug$BatchHistoryArgs<ExtArgs>
    Issue?: boolean | Drug$IssueArgs<ExtArgs>
    stratergyHistory?: boolean | Drug$stratergyHistoryArgs<ExtArgs>
    bufferLevels?: boolean | Drug$bufferLevelsArgs<ExtArgs>
    _count?: boolean | DrugCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["drug"]>

  export type DrugSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["drug"]>

  export type DrugSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["drug"]>

  export type DrugSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type DrugOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["drug"]>
  export type DrugInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batch?: boolean | Drug$batchArgs<ExtArgs>
    BatchHistory?: boolean | Drug$BatchHistoryArgs<ExtArgs>
    Issue?: boolean | Drug$IssueArgs<ExtArgs>
    stratergyHistory?: boolean | Drug$stratergyHistoryArgs<ExtArgs>
    bufferLevels?: boolean | Drug$bufferLevelsArgs<ExtArgs>
    _count?: boolean | DrugCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DrugIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DrugIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DrugPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Drug"
    objects: {
      batch: Prisma.$BatchPayload<ExtArgs>[]
      BatchHistory: Prisma.$BatchHistoryPayload<ExtArgs>[]
      Issue: Prisma.$IssuePayload<ExtArgs>[]
      stratergyHistory: Prisma.$StratergyHistoryPayload<ExtArgs> | null
      bufferLevels: Prisma.$BufferLevelPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["drug"]>
    composites: {}
  }

  type DrugGetPayload<S extends boolean | null | undefined | DrugDefaultArgs> = $Result.GetResult<Prisma.$DrugPayload, S>

  type DrugCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DrugFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DrugCountAggregateInputType | true
    }

  export interface DrugDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Drug'], meta: { name: 'Drug' } }
    /**
     * Find zero or one Drug that matches the filter.
     * @param {DrugFindUniqueArgs} args - Arguments to find a Drug
     * @example
     * // Get one Drug
     * const drug = await prisma.drug.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DrugFindUniqueArgs>(args: SelectSubset<T, DrugFindUniqueArgs<ExtArgs>>): Prisma__DrugClient<$Result.GetResult<Prisma.$DrugPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Drug that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DrugFindUniqueOrThrowArgs} args - Arguments to find a Drug
     * @example
     * // Get one Drug
     * const drug = await prisma.drug.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DrugFindUniqueOrThrowArgs>(args: SelectSubset<T, DrugFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DrugClient<$Result.GetResult<Prisma.$DrugPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Drug that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrugFindFirstArgs} args - Arguments to find a Drug
     * @example
     * // Get one Drug
     * const drug = await prisma.drug.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DrugFindFirstArgs>(args?: SelectSubset<T, DrugFindFirstArgs<ExtArgs>>): Prisma__DrugClient<$Result.GetResult<Prisma.$DrugPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Drug that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrugFindFirstOrThrowArgs} args - Arguments to find a Drug
     * @example
     * // Get one Drug
     * const drug = await prisma.drug.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DrugFindFirstOrThrowArgs>(args?: SelectSubset<T, DrugFindFirstOrThrowArgs<ExtArgs>>): Prisma__DrugClient<$Result.GetResult<Prisma.$DrugPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Drugs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrugFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Drugs
     * const drugs = await prisma.drug.findMany()
     * 
     * // Get first 10 Drugs
     * const drugs = await prisma.drug.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const drugWithIdOnly = await prisma.drug.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DrugFindManyArgs>(args?: SelectSubset<T, DrugFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DrugPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Drug.
     * @param {DrugCreateArgs} args - Arguments to create a Drug.
     * @example
     * // Create one Drug
     * const Drug = await prisma.drug.create({
     *   data: {
     *     // ... data to create a Drug
     *   }
     * })
     * 
     */
    create<T extends DrugCreateArgs>(args: SelectSubset<T, DrugCreateArgs<ExtArgs>>): Prisma__DrugClient<$Result.GetResult<Prisma.$DrugPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Drugs.
     * @param {DrugCreateManyArgs} args - Arguments to create many Drugs.
     * @example
     * // Create many Drugs
     * const drug = await prisma.drug.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DrugCreateManyArgs>(args?: SelectSubset<T, DrugCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Drugs and returns the data saved in the database.
     * @param {DrugCreateManyAndReturnArgs} args - Arguments to create many Drugs.
     * @example
     * // Create many Drugs
     * const drug = await prisma.drug.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Drugs and only return the `id`
     * const drugWithIdOnly = await prisma.drug.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DrugCreateManyAndReturnArgs>(args?: SelectSubset<T, DrugCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DrugPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Drug.
     * @param {DrugDeleteArgs} args - Arguments to delete one Drug.
     * @example
     * // Delete one Drug
     * const Drug = await prisma.drug.delete({
     *   where: {
     *     // ... filter to delete one Drug
     *   }
     * })
     * 
     */
    delete<T extends DrugDeleteArgs>(args: SelectSubset<T, DrugDeleteArgs<ExtArgs>>): Prisma__DrugClient<$Result.GetResult<Prisma.$DrugPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Drug.
     * @param {DrugUpdateArgs} args - Arguments to update one Drug.
     * @example
     * // Update one Drug
     * const drug = await prisma.drug.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DrugUpdateArgs>(args: SelectSubset<T, DrugUpdateArgs<ExtArgs>>): Prisma__DrugClient<$Result.GetResult<Prisma.$DrugPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Drugs.
     * @param {DrugDeleteManyArgs} args - Arguments to filter Drugs to delete.
     * @example
     * // Delete a few Drugs
     * const { count } = await prisma.drug.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DrugDeleteManyArgs>(args?: SelectSubset<T, DrugDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Drugs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrugUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Drugs
     * const drug = await prisma.drug.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DrugUpdateManyArgs>(args: SelectSubset<T, DrugUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Drugs and returns the data updated in the database.
     * @param {DrugUpdateManyAndReturnArgs} args - Arguments to update many Drugs.
     * @example
     * // Update many Drugs
     * const drug = await prisma.drug.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Drugs and only return the `id`
     * const drugWithIdOnly = await prisma.drug.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DrugUpdateManyAndReturnArgs>(args: SelectSubset<T, DrugUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DrugPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Drug.
     * @param {DrugUpsertArgs} args - Arguments to update or create a Drug.
     * @example
     * // Update or create a Drug
     * const drug = await prisma.drug.upsert({
     *   create: {
     *     // ... data to create a Drug
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Drug we want to update
     *   }
     * })
     */
    upsert<T extends DrugUpsertArgs>(args: SelectSubset<T, DrugUpsertArgs<ExtArgs>>): Prisma__DrugClient<$Result.GetResult<Prisma.$DrugPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Drugs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrugCountArgs} args - Arguments to filter Drugs to count.
     * @example
     * // Count the number of Drugs
     * const count = await prisma.drug.count({
     *   where: {
     *     // ... the filter for the Drugs we want to count
     *   }
     * })
    **/
    count<T extends DrugCountArgs>(
      args?: Subset<T, DrugCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DrugCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Drug.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrugAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DrugAggregateArgs>(args: Subset<T, DrugAggregateArgs>): Prisma.PrismaPromise<GetDrugAggregateType<T>>

    /**
     * Group by Drug.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrugGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DrugGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DrugGroupByArgs['orderBy'] }
        : { orderBy?: DrugGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DrugGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDrugGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Drug model
   */
  readonly fields: DrugFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Drug.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DrugClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    batch<T extends Drug$batchArgs<ExtArgs> = {}>(args?: Subset<T, Drug$batchArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    BatchHistory<T extends Drug$BatchHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Drug$BatchHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Issue<T extends Drug$IssueArgs<ExtArgs> = {}>(args?: Subset<T, Drug$IssueArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stratergyHistory<T extends Drug$stratergyHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Drug$stratergyHistoryArgs<ExtArgs>>): Prisma__StratergyHistoryClient<$Result.GetResult<Prisma.$StratergyHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    bufferLevels<T extends Drug$bufferLevelsArgs<ExtArgs> = {}>(args?: Subset<T, Drug$bufferLevelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BufferLevelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Drug model
   */ 
  interface DrugFieldRefs {
    readonly id: FieldRef<"Drug", 'Int'>
    readonly name: FieldRef<"Drug", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Drug findUnique
   */
  export type DrugFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Drug
     */
    select?: DrugSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Drug
     */
    omit?: DrugOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrugInclude<ExtArgs> | null
    /**
     * Filter, which Drug to fetch.
     */
    where: DrugWhereUniqueInput
  }

  /**
   * Drug findUniqueOrThrow
   */
  export type DrugFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Drug
     */
    select?: DrugSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Drug
     */
    omit?: DrugOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrugInclude<ExtArgs> | null
    /**
     * Filter, which Drug to fetch.
     */
    where: DrugWhereUniqueInput
  }

  /**
   * Drug findFirst
   */
  export type DrugFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Drug
     */
    select?: DrugSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Drug
     */
    omit?: DrugOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrugInclude<ExtArgs> | null
    /**
     * Filter, which Drug to fetch.
     */
    where?: DrugWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drugs to fetch.
     */
    orderBy?: DrugOrderByWithRelationInput | DrugOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Drugs.
     */
    cursor?: DrugWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drugs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drugs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Drugs.
     */
    distinct?: DrugScalarFieldEnum | DrugScalarFieldEnum[]
  }

  /**
   * Drug findFirstOrThrow
   */
  export type DrugFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Drug
     */
    select?: DrugSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Drug
     */
    omit?: DrugOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrugInclude<ExtArgs> | null
    /**
     * Filter, which Drug to fetch.
     */
    where?: DrugWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drugs to fetch.
     */
    orderBy?: DrugOrderByWithRelationInput | DrugOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Drugs.
     */
    cursor?: DrugWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drugs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drugs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Drugs.
     */
    distinct?: DrugScalarFieldEnum | DrugScalarFieldEnum[]
  }

  /**
   * Drug findMany
   */
  export type DrugFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Drug
     */
    select?: DrugSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Drug
     */
    omit?: DrugOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrugInclude<ExtArgs> | null
    /**
     * Filter, which Drugs to fetch.
     */
    where?: DrugWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drugs to fetch.
     */
    orderBy?: DrugOrderByWithRelationInput | DrugOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Drugs.
     */
    cursor?: DrugWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drugs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drugs.
     */
    skip?: number
    distinct?: DrugScalarFieldEnum | DrugScalarFieldEnum[]
  }

  /**
   * Drug create
   */
  export type DrugCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Drug
     */
    select?: DrugSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Drug
     */
    omit?: DrugOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrugInclude<ExtArgs> | null
    /**
     * The data needed to create a Drug.
     */
    data: XOR<DrugCreateInput, DrugUncheckedCreateInput>
  }

  /**
   * Drug createMany
   */
  export type DrugCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Drugs.
     */
    data: DrugCreateManyInput | DrugCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Drug createManyAndReturn
   */
  export type DrugCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Drug
     */
    select?: DrugSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Drug
     */
    omit?: DrugOmit<ExtArgs> | null
    /**
     * The data used to create many Drugs.
     */
    data: DrugCreateManyInput | DrugCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Drug update
   */
  export type DrugUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Drug
     */
    select?: DrugSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Drug
     */
    omit?: DrugOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrugInclude<ExtArgs> | null
    /**
     * The data needed to update a Drug.
     */
    data: XOR<DrugUpdateInput, DrugUncheckedUpdateInput>
    /**
     * Choose, which Drug to update.
     */
    where: DrugWhereUniqueInput
  }

  /**
   * Drug updateMany
   */
  export type DrugUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Drugs.
     */
    data: XOR<DrugUpdateManyMutationInput, DrugUncheckedUpdateManyInput>
    /**
     * Filter which Drugs to update
     */
    where?: DrugWhereInput
    /**
     * Limit how many Drugs to update.
     */
    limit?: number
  }

  /**
   * Drug updateManyAndReturn
   */
  export type DrugUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Drug
     */
    select?: DrugSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Drug
     */
    omit?: DrugOmit<ExtArgs> | null
    /**
     * The data used to update Drugs.
     */
    data: XOR<DrugUpdateManyMutationInput, DrugUncheckedUpdateManyInput>
    /**
     * Filter which Drugs to update
     */
    where?: DrugWhereInput
    /**
     * Limit how many Drugs to update.
     */
    limit?: number
  }

  /**
   * Drug upsert
   */
  export type DrugUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Drug
     */
    select?: DrugSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Drug
     */
    omit?: DrugOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrugInclude<ExtArgs> | null
    /**
     * The filter to search for the Drug to update in case it exists.
     */
    where: DrugWhereUniqueInput
    /**
     * In case the Drug found by the `where` argument doesn't exist, create a new Drug with this data.
     */
    create: XOR<DrugCreateInput, DrugUncheckedCreateInput>
    /**
     * In case the Drug was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DrugUpdateInput, DrugUncheckedUpdateInput>
  }

  /**
   * Drug delete
   */
  export type DrugDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Drug
     */
    select?: DrugSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Drug
     */
    omit?: DrugOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrugInclude<ExtArgs> | null
    /**
     * Filter which Drug to delete.
     */
    where: DrugWhereUniqueInput
  }

  /**
   * Drug deleteMany
   */
  export type DrugDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Drugs to delete
     */
    where?: DrugWhereInput
    /**
     * Limit how many Drugs to delete.
     */
    limit?: number
  }

  /**
   * Drug.batch
   */
  export type Drug$batchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    where?: BatchWhereInput
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    cursor?: BatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BatchScalarFieldEnum | BatchScalarFieldEnum[]
  }

  /**
   * Drug.BatchHistory
   */
  export type Drug$BatchHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchHistory
     */
    select?: BatchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchHistory
     */
    omit?: BatchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchHistoryInclude<ExtArgs> | null
    where?: BatchHistoryWhereInput
    orderBy?: BatchHistoryOrderByWithRelationInput | BatchHistoryOrderByWithRelationInput[]
    cursor?: BatchHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BatchHistoryScalarFieldEnum | BatchHistoryScalarFieldEnum[]
  }

  /**
   * Drug.Issue
   */
  export type Drug$IssueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issue
     */
    select?: IssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Issue
     */
    omit?: IssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueInclude<ExtArgs> | null
    where?: IssueWhereInput
    orderBy?: IssueOrderByWithRelationInput | IssueOrderByWithRelationInput[]
    cursor?: IssueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IssueScalarFieldEnum | IssueScalarFieldEnum[]
  }

  /**
   * Drug.stratergyHistory
   */
  export type Drug$stratergyHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StratergyHistory
     */
    select?: StratergyHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StratergyHistory
     */
    omit?: StratergyHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StratergyHistoryInclude<ExtArgs> | null
    where?: StratergyHistoryWhereInput
  }

  /**
   * Drug.bufferLevels
   */
  export type Drug$bufferLevelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BufferLevel
     */
    select?: BufferLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BufferLevel
     */
    omit?: BufferLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BufferLevelInclude<ExtArgs> | null
    where?: BufferLevelWhereInput
    orderBy?: BufferLevelOrderByWithRelationInput | BufferLevelOrderByWithRelationInput[]
    cursor?: BufferLevelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BufferLevelScalarFieldEnum | BufferLevelScalarFieldEnum[]
  }

  /**
   * Drug without action
   */
  export type DrugDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Drug
     */
    select?: DrugSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Drug
     */
    omit?: DrugOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrugInclude<ExtArgs> | null
  }


  /**
   * Model BufferLevel
   */

  export type AggregateBufferLevel = {
    _count: BufferLevelCountAggregateOutputType | null
    _avg: BufferLevelAvgAggregateOutputType | null
    _sum: BufferLevelSumAggregateOutputType | null
    _min: BufferLevelMinAggregateOutputType | null
    _max: BufferLevelMaxAggregateOutputType | null
  }

  export type BufferLevelAvgAggregateOutputType = {
    id: number | null
    drugId: number | null
    unitConcentrationId: number | null
    bufferAmount: number | null
  }

  export type BufferLevelSumAggregateOutputType = {
    id: number | null
    drugId: number | null
    unitConcentrationId: number | null
    bufferAmount: number | null
  }

  export type BufferLevelMinAggregateOutputType = {
    id: number | null
    drugId: number | null
    type: $Enums.DrugType | null
    unitConcentrationId: number | null
    bufferAmount: number | null
  }

  export type BufferLevelMaxAggregateOutputType = {
    id: number | null
    drugId: number | null
    type: $Enums.DrugType | null
    unitConcentrationId: number | null
    bufferAmount: number | null
  }

  export type BufferLevelCountAggregateOutputType = {
    id: number
    drugId: number
    type: number
    unitConcentrationId: number
    bufferAmount: number
    _all: number
  }


  export type BufferLevelAvgAggregateInputType = {
    id?: true
    drugId?: true
    unitConcentrationId?: true
    bufferAmount?: true
  }

  export type BufferLevelSumAggregateInputType = {
    id?: true
    drugId?: true
    unitConcentrationId?: true
    bufferAmount?: true
  }

  export type BufferLevelMinAggregateInputType = {
    id?: true
    drugId?: true
    type?: true
    unitConcentrationId?: true
    bufferAmount?: true
  }

  export type BufferLevelMaxAggregateInputType = {
    id?: true
    drugId?: true
    type?: true
    unitConcentrationId?: true
    bufferAmount?: true
  }

  export type BufferLevelCountAggregateInputType = {
    id?: true
    drugId?: true
    type?: true
    unitConcentrationId?: true
    bufferAmount?: true
    _all?: true
  }

  export type BufferLevelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BufferLevel to aggregate.
     */
    where?: BufferLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BufferLevels to fetch.
     */
    orderBy?: BufferLevelOrderByWithRelationInput | BufferLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BufferLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BufferLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BufferLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BufferLevels
    **/
    _count?: true | BufferLevelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BufferLevelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BufferLevelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BufferLevelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BufferLevelMaxAggregateInputType
  }

  export type GetBufferLevelAggregateType<T extends BufferLevelAggregateArgs> = {
        [P in keyof T & keyof AggregateBufferLevel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBufferLevel[P]>
      : GetScalarType<T[P], AggregateBufferLevel[P]>
  }




  export type BufferLevelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BufferLevelWhereInput
    orderBy?: BufferLevelOrderByWithAggregationInput | BufferLevelOrderByWithAggregationInput[]
    by: BufferLevelScalarFieldEnum[] | BufferLevelScalarFieldEnum
    having?: BufferLevelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BufferLevelCountAggregateInputType | true
    _avg?: BufferLevelAvgAggregateInputType
    _sum?: BufferLevelSumAggregateInputType
    _min?: BufferLevelMinAggregateInputType
    _max?: BufferLevelMaxAggregateInputType
  }

  export type BufferLevelGroupByOutputType = {
    id: number
    drugId: number
    type: $Enums.DrugType
    unitConcentrationId: number
    bufferAmount: number
    _count: BufferLevelCountAggregateOutputType | null
    _avg: BufferLevelAvgAggregateOutputType | null
    _sum: BufferLevelSumAggregateOutputType | null
    _min: BufferLevelMinAggregateOutputType | null
    _max: BufferLevelMaxAggregateOutputType | null
  }

  type GetBufferLevelGroupByPayload<T extends BufferLevelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BufferLevelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BufferLevelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BufferLevelGroupByOutputType[P]>
            : GetScalarType<T[P], BufferLevelGroupByOutputType[P]>
        }
      >
    >


  export type BufferLevelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    drugId?: boolean
    type?: boolean
    unitConcentrationId?: boolean
    bufferAmount?: boolean
    drug?: boolean | DrugDefaultArgs<ExtArgs>
    unitConcentration?: boolean | UnitConcentrationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bufferLevel"]>

  export type BufferLevelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    drugId?: boolean
    type?: boolean
    unitConcentrationId?: boolean
    bufferAmount?: boolean
    drug?: boolean | DrugDefaultArgs<ExtArgs>
    unitConcentration?: boolean | UnitConcentrationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bufferLevel"]>

  export type BufferLevelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    drugId?: boolean
    type?: boolean
    unitConcentrationId?: boolean
    bufferAmount?: boolean
    drug?: boolean | DrugDefaultArgs<ExtArgs>
    unitConcentration?: boolean | UnitConcentrationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bufferLevel"]>

  export type BufferLevelSelectScalar = {
    id?: boolean
    drugId?: boolean
    type?: boolean
    unitConcentrationId?: boolean
    bufferAmount?: boolean
  }

  export type BufferLevelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "drugId" | "type" | "unitConcentrationId" | "bufferAmount", ExtArgs["result"]["bufferLevel"]>
  export type BufferLevelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    drug?: boolean | DrugDefaultArgs<ExtArgs>
    unitConcentration?: boolean | UnitConcentrationDefaultArgs<ExtArgs>
  }
  export type BufferLevelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    drug?: boolean | DrugDefaultArgs<ExtArgs>
    unitConcentration?: boolean | UnitConcentrationDefaultArgs<ExtArgs>
  }
  export type BufferLevelIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    drug?: boolean | DrugDefaultArgs<ExtArgs>
    unitConcentration?: boolean | UnitConcentrationDefaultArgs<ExtArgs>
  }

  export type $BufferLevelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BufferLevel"
    objects: {
      drug: Prisma.$DrugPayload<ExtArgs>
      unitConcentration: Prisma.$UnitConcentrationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      drugId: number
      type: $Enums.DrugType
      unitConcentrationId: number
      bufferAmount: number
    }, ExtArgs["result"]["bufferLevel"]>
    composites: {}
  }

  type BufferLevelGetPayload<S extends boolean | null | undefined | BufferLevelDefaultArgs> = $Result.GetResult<Prisma.$BufferLevelPayload, S>

  type BufferLevelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BufferLevelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BufferLevelCountAggregateInputType | true
    }

  export interface BufferLevelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BufferLevel'], meta: { name: 'BufferLevel' } }
    /**
     * Find zero or one BufferLevel that matches the filter.
     * @param {BufferLevelFindUniqueArgs} args - Arguments to find a BufferLevel
     * @example
     * // Get one BufferLevel
     * const bufferLevel = await prisma.bufferLevel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BufferLevelFindUniqueArgs>(args: SelectSubset<T, BufferLevelFindUniqueArgs<ExtArgs>>): Prisma__BufferLevelClient<$Result.GetResult<Prisma.$BufferLevelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BufferLevel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BufferLevelFindUniqueOrThrowArgs} args - Arguments to find a BufferLevel
     * @example
     * // Get one BufferLevel
     * const bufferLevel = await prisma.bufferLevel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BufferLevelFindUniqueOrThrowArgs>(args: SelectSubset<T, BufferLevelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BufferLevelClient<$Result.GetResult<Prisma.$BufferLevelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BufferLevel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BufferLevelFindFirstArgs} args - Arguments to find a BufferLevel
     * @example
     * // Get one BufferLevel
     * const bufferLevel = await prisma.bufferLevel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BufferLevelFindFirstArgs>(args?: SelectSubset<T, BufferLevelFindFirstArgs<ExtArgs>>): Prisma__BufferLevelClient<$Result.GetResult<Prisma.$BufferLevelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BufferLevel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BufferLevelFindFirstOrThrowArgs} args - Arguments to find a BufferLevel
     * @example
     * // Get one BufferLevel
     * const bufferLevel = await prisma.bufferLevel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BufferLevelFindFirstOrThrowArgs>(args?: SelectSubset<T, BufferLevelFindFirstOrThrowArgs<ExtArgs>>): Prisma__BufferLevelClient<$Result.GetResult<Prisma.$BufferLevelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BufferLevels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BufferLevelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BufferLevels
     * const bufferLevels = await prisma.bufferLevel.findMany()
     * 
     * // Get first 10 BufferLevels
     * const bufferLevels = await prisma.bufferLevel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bufferLevelWithIdOnly = await prisma.bufferLevel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BufferLevelFindManyArgs>(args?: SelectSubset<T, BufferLevelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BufferLevelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BufferLevel.
     * @param {BufferLevelCreateArgs} args - Arguments to create a BufferLevel.
     * @example
     * // Create one BufferLevel
     * const BufferLevel = await prisma.bufferLevel.create({
     *   data: {
     *     // ... data to create a BufferLevel
     *   }
     * })
     * 
     */
    create<T extends BufferLevelCreateArgs>(args: SelectSubset<T, BufferLevelCreateArgs<ExtArgs>>): Prisma__BufferLevelClient<$Result.GetResult<Prisma.$BufferLevelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BufferLevels.
     * @param {BufferLevelCreateManyArgs} args - Arguments to create many BufferLevels.
     * @example
     * // Create many BufferLevels
     * const bufferLevel = await prisma.bufferLevel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BufferLevelCreateManyArgs>(args?: SelectSubset<T, BufferLevelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BufferLevels and returns the data saved in the database.
     * @param {BufferLevelCreateManyAndReturnArgs} args - Arguments to create many BufferLevels.
     * @example
     * // Create many BufferLevels
     * const bufferLevel = await prisma.bufferLevel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BufferLevels and only return the `id`
     * const bufferLevelWithIdOnly = await prisma.bufferLevel.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BufferLevelCreateManyAndReturnArgs>(args?: SelectSubset<T, BufferLevelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BufferLevelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BufferLevel.
     * @param {BufferLevelDeleteArgs} args - Arguments to delete one BufferLevel.
     * @example
     * // Delete one BufferLevel
     * const BufferLevel = await prisma.bufferLevel.delete({
     *   where: {
     *     // ... filter to delete one BufferLevel
     *   }
     * })
     * 
     */
    delete<T extends BufferLevelDeleteArgs>(args: SelectSubset<T, BufferLevelDeleteArgs<ExtArgs>>): Prisma__BufferLevelClient<$Result.GetResult<Prisma.$BufferLevelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BufferLevel.
     * @param {BufferLevelUpdateArgs} args - Arguments to update one BufferLevel.
     * @example
     * // Update one BufferLevel
     * const bufferLevel = await prisma.bufferLevel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BufferLevelUpdateArgs>(args: SelectSubset<T, BufferLevelUpdateArgs<ExtArgs>>): Prisma__BufferLevelClient<$Result.GetResult<Prisma.$BufferLevelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BufferLevels.
     * @param {BufferLevelDeleteManyArgs} args - Arguments to filter BufferLevels to delete.
     * @example
     * // Delete a few BufferLevels
     * const { count } = await prisma.bufferLevel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BufferLevelDeleteManyArgs>(args?: SelectSubset<T, BufferLevelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BufferLevels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BufferLevelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BufferLevels
     * const bufferLevel = await prisma.bufferLevel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BufferLevelUpdateManyArgs>(args: SelectSubset<T, BufferLevelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BufferLevels and returns the data updated in the database.
     * @param {BufferLevelUpdateManyAndReturnArgs} args - Arguments to update many BufferLevels.
     * @example
     * // Update many BufferLevels
     * const bufferLevel = await prisma.bufferLevel.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BufferLevels and only return the `id`
     * const bufferLevelWithIdOnly = await prisma.bufferLevel.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BufferLevelUpdateManyAndReturnArgs>(args: SelectSubset<T, BufferLevelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BufferLevelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BufferLevel.
     * @param {BufferLevelUpsertArgs} args - Arguments to update or create a BufferLevel.
     * @example
     * // Update or create a BufferLevel
     * const bufferLevel = await prisma.bufferLevel.upsert({
     *   create: {
     *     // ... data to create a BufferLevel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BufferLevel we want to update
     *   }
     * })
     */
    upsert<T extends BufferLevelUpsertArgs>(args: SelectSubset<T, BufferLevelUpsertArgs<ExtArgs>>): Prisma__BufferLevelClient<$Result.GetResult<Prisma.$BufferLevelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BufferLevels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BufferLevelCountArgs} args - Arguments to filter BufferLevels to count.
     * @example
     * // Count the number of BufferLevels
     * const count = await prisma.bufferLevel.count({
     *   where: {
     *     // ... the filter for the BufferLevels we want to count
     *   }
     * })
    **/
    count<T extends BufferLevelCountArgs>(
      args?: Subset<T, BufferLevelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BufferLevelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BufferLevel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BufferLevelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BufferLevelAggregateArgs>(args: Subset<T, BufferLevelAggregateArgs>): Prisma.PrismaPromise<GetBufferLevelAggregateType<T>>

    /**
     * Group by BufferLevel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BufferLevelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BufferLevelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BufferLevelGroupByArgs['orderBy'] }
        : { orderBy?: BufferLevelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BufferLevelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBufferLevelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BufferLevel model
   */
  readonly fields: BufferLevelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BufferLevel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BufferLevelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    drug<T extends DrugDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DrugDefaultArgs<ExtArgs>>): Prisma__DrugClient<$Result.GetResult<Prisma.$DrugPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    unitConcentration<T extends UnitConcentrationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitConcentrationDefaultArgs<ExtArgs>>): Prisma__UnitConcentrationClient<$Result.GetResult<Prisma.$UnitConcentrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BufferLevel model
   */ 
  interface BufferLevelFieldRefs {
    readonly id: FieldRef<"BufferLevel", 'Int'>
    readonly drugId: FieldRef<"BufferLevel", 'Int'>
    readonly type: FieldRef<"BufferLevel", 'DrugType'>
    readonly unitConcentrationId: FieldRef<"BufferLevel", 'Int'>
    readonly bufferAmount: FieldRef<"BufferLevel", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * BufferLevel findUnique
   */
  export type BufferLevelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BufferLevel
     */
    select?: BufferLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BufferLevel
     */
    omit?: BufferLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BufferLevelInclude<ExtArgs> | null
    /**
     * Filter, which BufferLevel to fetch.
     */
    where: BufferLevelWhereUniqueInput
  }

  /**
   * BufferLevel findUniqueOrThrow
   */
  export type BufferLevelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BufferLevel
     */
    select?: BufferLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BufferLevel
     */
    omit?: BufferLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BufferLevelInclude<ExtArgs> | null
    /**
     * Filter, which BufferLevel to fetch.
     */
    where: BufferLevelWhereUniqueInput
  }

  /**
   * BufferLevel findFirst
   */
  export type BufferLevelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BufferLevel
     */
    select?: BufferLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BufferLevel
     */
    omit?: BufferLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BufferLevelInclude<ExtArgs> | null
    /**
     * Filter, which BufferLevel to fetch.
     */
    where?: BufferLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BufferLevels to fetch.
     */
    orderBy?: BufferLevelOrderByWithRelationInput | BufferLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BufferLevels.
     */
    cursor?: BufferLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BufferLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BufferLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BufferLevels.
     */
    distinct?: BufferLevelScalarFieldEnum | BufferLevelScalarFieldEnum[]
  }

  /**
   * BufferLevel findFirstOrThrow
   */
  export type BufferLevelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BufferLevel
     */
    select?: BufferLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BufferLevel
     */
    omit?: BufferLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BufferLevelInclude<ExtArgs> | null
    /**
     * Filter, which BufferLevel to fetch.
     */
    where?: BufferLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BufferLevels to fetch.
     */
    orderBy?: BufferLevelOrderByWithRelationInput | BufferLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BufferLevels.
     */
    cursor?: BufferLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BufferLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BufferLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BufferLevels.
     */
    distinct?: BufferLevelScalarFieldEnum | BufferLevelScalarFieldEnum[]
  }

  /**
   * BufferLevel findMany
   */
  export type BufferLevelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BufferLevel
     */
    select?: BufferLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BufferLevel
     */
    omit?: BufferLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BufferLevelInclude<ExtArgs> | null
    /**
     * Filter, which BufferLevels to fetch.
     */
    where?: BufferLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BufferLevels to fetch.
     */
    orderBy?: BufferLevelOrderByWithRelationInput | BufferLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BufferLevels.
     */
    cursor?: BufferLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BufferLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BufferLevels.
     */
    skip?: number
    distinct?: BufferLevelScalarFieldEnum | BufferLevelScalarFieldEnum[]
  }

  /**
   * BufferLevel create
   */
  export type BufferLevelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BufferLevel
     */
    select?: BufferLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BufferLevel
     */
    omit?: BufferLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BufferLevelInclude<ExtArgs> | null
    /**
     * The data needed to create a BufferLevel.
     */
    data: XOR<BufferLevelCreateInput, BufferLevelUncheckedCreateInput>
  }

  /**
   * BufferLevel createMany
   */
  export type BufferLevelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BufferLevels.
     */
    data: BufferLevelCreateManyInput | BufferLevelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BufferLevel createManyAndReturn
   */
  export type BufferLevelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BufferLevel
     */
    select?: BufferLevelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BufferLevel
     */
    omit?: BufferLevelOmit<ExtArgs> | null
    /**
     * The data used to create many BufferLevels.
     */
    data: BufferLevelCreateManyInput | BufferLevelCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BufferLevelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BufferLevel update
   */
  export type BufferLevelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BufferLevel
     */
    select?: BufferLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BufferLevel
     */
    omit?: BufferLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BufferLevelInclude<ExtArgs> | null
    /**
     * The data needed to update a BufferLevel.
     */
    data: XOR<BufferLevelUpdateInput, BufferLevelUncheckedUpdateInput>
    /**
     * Choose, which BufferLevel to update.
     */
    where: BufferLevelWhereUniqueInput
  }

  /**
   * BufferLevel updateMany
   */
  export type BufferLevelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BufferLevels.
     */
    data: XOR<BufferLevelUpdateManyMutationInput, BufferLevelUncheckedUpdateManyInput>
    /**
     * Filter which BufferLevels to update
     */
    where?: BufferLevelWhereInput
    /**
     * Limit how many BufferLevels to update.
     */
    limit?: number
  }

  /**
   * BufferLevel updateManyAndReturn
   */
  export type BufferLevelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BufferLevel
     */
    select?: BufferLevelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BufferLevel
     */
    omit?: BufferLevelOmit<ExtArgs> | null
    /**
     * The data used to update BufferLevels.
     */
    data: XOR<BufferLevelUpdateManyMutationInput, BufferLevelUncheckedUpdateManyInput>
    /**
     * Filter which BufferLevels to update
     */
    where?: BufferLevelWhereInput
    /**
     * Limit how many BufferLevels to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BufferLevelIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BufferLevel upsert
   */
  export type BufferLevelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BufferLevel
     */
    select?: BufferLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BufferLevel
     */
    omit?: BufferLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BufferLevelInclude<ExtArgs> | null
    /**
     * The filter to search for the BufferLevel to update in case it exists.
     */
    where: BufferLevelWhereUniqueInput
    /**
     * In case the BufferLevel found by the `where` argument doesn't exist, create a new BufferLevel with this data.
     */
    create: XOR<BufferLevelCreateInput, BufferLevelUncheckedCreateInput>
    /**
     * In case the BufferLevel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BufferLevelUpdateInput, BufferLevelUncheckedUpdateInput>
  }

  /**
   * BufferLevel delete
   */
  export type BufferLevelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BufferLevel
     */
    select?: BufferLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BufferLevel
     */
    omit?: BufferLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BufferLevelInclude<ExtArgs> | null
    /**
     * Filter which BufferLevel to delete.
     */
    where: BufferLevelWhereUniqueInput
  }

  /**
   * BufferLevel deleteMany
   */
  export type BufferLevelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BufferLevels to delete
     */
    where?: BufferLevelWhereInput
    /**
     * Limit how many BufferLevels to delete.
     */
    limit?: number
  }

  /**
   * BufferLevel without action
   */
  export type BufferLevelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BufferLevel
     */
    select?: BufferLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BufferLevel
     */
    omit?: BufferLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BufferLevelInclude<ExtArgs> | null
  }


  /**
   * Model Supplier
   */

  export type AggregateSupplier = {
    _count: SupplierCountAggregateOutputType | null
    _avg: SupplierAvgAggregateOutputType | null
    _sum: SupplierSumAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  export type SupplierAvgAggregateOutputType = {
    id: number | null
  }

  export type SupplierSumAggregateOutputType = {
    id: number | null
  }

  export type SupplierMinAggregateOutputType = {
    id: number | null
    name: string | null
    contact: string | null
  }

  export type SupplierMaxAggregateOutputType = {
    id: number | null
    name: string | null
    contact: string | null
  }

  export type SupplierCountAggregateOutputType = {
    id: number
    name: number
    contact: number
    _all: number
  }


  export type SupplierAvgAggregateInputType = {
    id?: true
  }

  export type SupplierSumAggregateInputType = {
    id?: true
  }

  export type SupplierMinAggregateInputType = {
    id?: true
    name?: true
    contact?: true
  }

  export type SupplierMaxAggregateInputType = {
    id?: true
    name?: true
    contact?: true
  }

  export type SupplierCountAggregateInputType = {
    id?: true
    name?: true
    contact?: true
    _all?: true
  }

  export type SupplierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Supplier to aggregate.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Suppliers
    **/
    _count?: true | SupplierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SupplierAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SupplierSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierMaxAggregateInputType
  }

  export type GetSupplierAggregateType<T extends SupplierAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplier[P]>
      : GetScalarType<T[P], AggregateSupplier[P]>
  }




  export type SupplierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierWhereInput
    orderBy?: SupplierOrderByWithAggregationInput | SupplierOrderByWithAggregationInput[]
    by: SupplierScalarFieldEnum[] | SupplierScalarFieldEnum
    having?: SupplierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierCountAggregateInputType | true
    _avg?: SupplierAvgAggregateInputType
    _sum?: SupplierSumAggregateInputType
    _min?: SupplierMinAggregateInputType
    _max?: SupplierMaxAggregateInputType
  }

  export type SupplierGroupByOutputType = {
    id: number
    name: string
    contact: string | null
    _count: SupplierCountAggregateOutputType | null
    _avg: SupplierAvgAggregateOutputType | null
    _sum: SupplierSumAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  type GetSupplierGroupByPayload<T extends SupplierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierGroupByOutputType[P]>
        }
      >
    >


  export type SupplierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contact?: boolean
    batches?: boolean | Supplier$batchesArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contact?: boolean
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contact?: boolean
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectScalar = {
    id?: boolean
    name?: boolean
    contact?: boolean
  }

  export type SupplierOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "contact", ExtArgs["result"]["supplier"]>
  export type SupplierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batches?: boolean | Supplier$batchesArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SupplierIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SupplierIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SupplierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Supplier"
    objects: {
      batches: Prisma.$BatchPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      contact: string | null
    }, ExtArgs["result"]["supplier"]>
    composites: {}
  }

  type SupplierGetPayload<S extends boolean | null | undefined | SupplierDefaultArgs> = $Result.GetResult<Prisma.$SupplierPayload, S>

  type SupplierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SupplierFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SupplierCountAggregateInputType | true
    }

  export interface SupplierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Supplier'], meta: { name: 'Supplier' } }
    /**
     * Find zero or one Supplier that matches the filter.
     * @param {SupplierFindUniqueArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupplierFindUniqueArgs>(args: SelectSubset<T, SupplierFindUniqueArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Supplier that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SupplierFindUniqueOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupplierFindUniqueOrThrowArgs>(args: SelectSubset<T, SupplierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Supplier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupplierFindFirstArgs>(args?: SelectSubset<T, SupplierFindFirstArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Supplier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupplierFindFirstOrThrowArgs>(args?: SelectSubset<T, SupplierFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Suppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Suppliers
     * const suppliers = await prisma.supplier.findMany()
     * 
     * // Get first 10 Suppliers
     * const suppliers = await prisma.supplier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supplierWithIdOnly = await prisma.supplier.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupplierFindManyArgs>(args?: SelectSubset<T, SupplierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Supplier.
     * @param {SupplierCreateArgs} args - Arguments to create a Supplier.
     * @example
     * // Create one Supplier
     * const Supplier = await prisma.supplier.create({
     *   data: {
     *     // ... data to create a Supplier
     *   }
     * })
     * 
     */
    create<T extends SupplierCreateArgs>(args: SelectSubset<T, SupplierCreateArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Suppliers.
     * @param {SupplierCreateManyArgs} args - Arguments to create many Suppliers.
     * @example
     * // Create many Suppliers
     * const supplier = await prisma.supplier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupplierCreateManyArgs>(args?: SelectSubset<T, SupplierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Suppliers and returns the data saved in the database.
     * @param {SupplierCreateManyAndReturnArgs} args - Arguments to create many Suppliers.
     * @example
     * // Create many Suppliers
     * const supplier = await prisma.supplier.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Suppliers and only return the `id`
     * const supplierWithIdOnly = await prisma.supplier.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupplierCreateManyAndReturnArgs>(args?: SelectSubset<T, SupplierCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Supplier.
     * @param {SupplierDeleteArgs} args - Arguments to delete one Supplier.
     * @example
     * // Delete one Supplier
     * const Supplier = await prisma.supplier.delete({
     *   where: {
     *     // ... filter to delete one Supplier
     *   }
     * })
     * 
     */
    delete<T extends SupplierDeleteArgs>(args: SelectSubset<T, SupplierDeleteArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Supplier.
     * @param {SupplierUpdateArgs} args - Arguments to update one Supplier.
     * @example
     * // Update one Supplier
     * const supplier = await prisma.supplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupplierUpdateArgs>(args: SelectSubset<T, SupplierUpdateArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Suppliers.
     * @param {SupplierDeleteManyArgs} args - Arguments to filter Suppliers to delete.
     * @example
     * // Delete a few Suppliers
     * const { count } = await prisma.supplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupplierDeleteManyArgs>(args?: SelectSubset<T, SupplierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupplierUpdateManyArgs>(args: SelectSubset<T, SupplierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers and returns the data updated in the database.
     * @param {SupplierUpdateManyAndReturnArgs} args - Arguments to update many Suppliers.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Suppliers and only return the `id`
     * const supplierWithIdOnly = await prisma.supplier.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SupplierUpdateManyAndReturnArgs>(args: SelectSubset<T, SupplierUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Supplier.
     * @param {SupplierUpsertArgs} args - Arguments to update or create a Supplier.
     * @example
     * // Update or create a Supplier
     * const supplier = await prisma.supplier.upsert({
     *   create: {
     *     // ... data to create a Supplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Supplier we want to update
     *   }
     * })
     */
    upsert<T extends SupplierUpsertArgs>(args: SelectSubset<T, SupplierUpsertArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierCountArgs} args - Arguments to filter Suppliers to count.
     * @example
     * // Count the number of Suppliers
     * const count = await prisma.supplier.count({
     *   where: {
     *     // ... the filter for the Suppliers we want to count
     *   }
     * })
    **/
    count<T extends SupplierCountArgs>(
      args?: Subset<T, SupplierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierAggregateArgs>(args: Subset<T, SupplierAggregateArgs>): Prisma.PrismaPromise<GetSupplierAggregateType<T>>

    /**
     * Group by Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupplierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplierGroupByArgs['orderBy'] }
        : { orderBy?: SupplierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupplierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Supplier model
   */
  readonly fields: SupplierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Supplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupplierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    batches<T extends Supplier$batchesArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$batchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Supplier model
   */ 
  interface SupplierFieldRefs {
    readonly id: FieldRef<"Supplier", 'Int'>
    readonly name: FieldRef<"Supplier", 'String'>
    readonly contact: FieldRef<"Supplier", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Supplier findUnique
   */
  export type SupplierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier findUniqueOrThrow
   */
  export type SupplierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier findFirst
   */
  export type SupplierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier findFirstOrThrow
   */
  export type SupplierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier findMany
   */
  export type SupplierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Suppliers to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier create
   */
  export type SupplierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to create a Supplier.
     */
    data: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
  }

  /**
   * Supplier createMany
   */
  export type SupplierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Suppliers.
     */
    data: SupplierCreateManyInput | SupplierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Supplier createManyAndReturn
   */
  export type SupplierCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * The data used to create many Suppliers.
     */
    data: SupplierCreateManyInput | SupplierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Supplier update
   */
  export type SupplierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to update a Supplier.
     */
    data: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
    /**
     * Choose, which Supplier to update.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier updateMany
   */
  export type SupplierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Suppliers.
     */
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyInput>
    /**
     * Filter which Suppliers to update
     */
    where?: SupplierWhereInput
    /**
     * Limit how many Suppliers to update.
     */
    limit?: number
  }

  /**
   * Supplier updateManyAndReturn
   */
  export type SupplierUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * The data used to update Suppliers.
     */
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyInput>
    /**
     * Filter which Suppliers to update
     */
    where?: SupplierWhereInput
    /**
     * Limit how many Suppliers to update.
     */
    limit?: number
  }

  /**
   * Supplier upsert
   */
  export type SupplierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The filter to search for the Supplier to update in case it exists.
     */
    where: SupplierWhereUniqueInput
    /**
     * In case the Supplier found by the `where` argument doesn't exist, create a new Supplier with this data.
     */
    create: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
    /**
     * In case the Supplier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
  }

  /**
   * Supplier delete
   */
  export type SupplierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter which Supplier to delete.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier deleteMany
   */
  export type SupplierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Suppliers to delete
     */
    where?: SupplierWhereInput
    /**
     * Limit how many Suppliers to delete.
     */
    limit?: number
  }

  /**
   * Supplier.batches
   */
  export type Supplier$batchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    where?: BatchWhereInput
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    cursor?: BatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BatchScalarFieldEnum | BatchScalarFieldEnum[]
  }

  /**
   * Supplier without action
   */
  export type SupplierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
  }


  /**
   * Model Batch
   */

  export type AggregateBatch = {
    _count: BatchCountAggregateOutputType | null
    _avg: BatchAvgAggregateOutputType | null
    _sum: BatchSumAggregateOutputType | null
    _min: BatchMinAggregateOutputType | null
    _max: BatchMaxAggregateOutputType | null
  }

  export type BatchAvgAggregateOutputType = {
    id: number | null
    drugId: number | null
    drugBrandId: number | null
    fullAmount: number | null
    remainingQuantity: number | null
    wholesalePrice: number | null
    retailPrice: number | null
    unitConcentrationId: number | null
    supplierId: number | null
  }

  export type BatchSumAggregateOutputType = {
    id: number | null
    drugId: number | null
    drugBrandId: number | null
    fullAmount: number | null
    remainingQuantity: number | null
    wholesalePrice: number | null
    retailPrice: number | null
    unitConcentrationId: number | null
    supplierId: number | null
  }

  export type BatchMinAggregateOutputType = {
    id: number | null
    number: string | null
    drugId: number | null
    drugBrandId: number | null
    type: $Enums.DrugType | null
    fullAmount: number | null
    expiry: Date | null
    stockDate: Date | null
    remainingQuantity: number | null
    wholesalePrice: number | null
    retailPrice: number | null
    status: $Enums.BatchStatus | null
    unitConcentrationId: number | null
    supplierId: number | null
  }

  export type BatchMaxAggregateOutputType = {
    id: number | null
    number: string | null
    drugId: number | null
    drugBrandId: number | null
    type: $Enums.DrugType | null
    fullAmount: number | null
    expiry: Date | null
    stockDate: Date | null
    remainingQuantity: number | null
    wholesalePrice: number | null
    retailPrice: number | null
    status: $Enums.BatchStatus | null
    unitConcentrationId: number | null
    supplierId: number | null
  }

  export type BatchCountAggregateOutputType = {
    id: number
    number: number
    drugId: number
    drugBrandId: number
    type: number
    fullAmount: number
    expiry: number
    stockDate: number
    remainingQuantity: number
    wholesalePrice: number
    retailPrice: number
    status: number
    unitConcentrationId: number
    supplierId: number
    _all: number
  }


  export type BatchAvgAggregateInputType = {
    id?: true
    drugId?: true
    drugBrandId?: true
    fullAmount?: true
    remainingQuantity?: true
    wholesalePrice?: true
    retailPrice?: true
    unitConcentrationId?: true
    supplierId?: true
  }

  export type BatchSumAggregateInputType = {
    id?: true
    drugId?: true
    drugBrandId?: true
    fullAmount?: true
    remainingQuantity?: true
    wholesalePrice?: true
    retailPrice?: true
    unitConcentrationId?: true
    supplierId?: true
  }

  export type BatchMinAggregateInputType = {
    id?: true
    number?: true
    drugId?: true
    drugBrandId?: true
    type?: true
    fullAmount?: true
    expiry?: true
    stockDate?: true
    remainingQuantity?: true
    wholesalePrice?: true
    retailPrice?: true
    status?: true
    unitConcentrationId?: true
    supplierId?: true
  }

  export type BatchMaxAggregateInputType = {
    id?: true
    number?: true
    drugId?: true
    drugBrandId?: true
    type?: true
    fullAmount?: true
    expiry?: true
    stockDate?: true
    remainingQuantity?: true
    wholesalePrice?: true
    retailPrice?: true
    status?: true
    unitConcentrationId?: true
    supplierId?: true
  }

  export type BatchCountAggregateInputType = {
    id?: true
    number?: true
    drugId?: true
    drugBrandId?: true
    type?: true
    fullAmount?: true
    expiry?: true
    stockDate?: true
    remainingQuantity?: true
    wholesalePrice?: true
    retailPrice?: true
    status?: true
    unitConcentrationId?: true
    supplierId?: true
    _all?: true
  }

  export type BatchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Batch to aggregate.
     */
    where?: BatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Batches to fetch.
     */
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Batches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Batches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Batches
    **/
    _count?: true | BatchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BatchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BatchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BatchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BatchMaxAggregateInputType
  }

  export type GetBatchAggregateType<T extends BatchAggregateArgs> = {
        [P in keyof T & keyof AggregateBatch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBatch[P]>
      : GetScalarType<T[P], AggregateBatch[P]>
  }




  export type BatchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchWhereInput
    orderBy?: BatchOrderByWithAggregationInput | BatchOrderByWithAggregationInput[]
    by: BatchScalarFieldEnum[] | BatchScalarFieldEnum
    having?: BatchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BatchCountAggregateInputType | true
    _avg?: BatchAvgAggregateInputType
    _sum?: BatchSumAggregateInputType
    _min?: BatchMinAggregateInputType
    _max?: BatchMaxAggregateInputType
  }

  export type BatchGroupByOutputType = {
    id: number
    number: string
    drugId: number
    drugBrandId: number
    type: $Enums.DrugType
    fullAmount: number
    expiry: Date
    stockDate: Date
    remainingQuantity: number
    wholesalePrice: number
    retailPrice: number
    status: $Enums.BatchStatus
    unitConcentrationId: number
    supplierId: number
    _count: BatchCountAggregateOutputType | null
    _avg: BatchAvgAggregateOutputType | null
    _sum: BatchSumAggregateOutputType | null
    _min: BatchMinAggregateOutputType | null
    _max: BatchMaxAggregateOutputType | null
  }

  type GetBatchGroupByPayload<T extends BatchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BatchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BatchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BatchGroupByOutputType[P]>
            : GetScalarType<T[P], BatchGroupByOutputType[P]>
        }
      >
    >


  export type BatchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    drugId?: boolean
    drugBrandId?: boolean
    type?: boolean
    fullAmount?: boolean
    expiry?: boolean
    stockDate?: boolean
    remainingQuantity?: boolean
    wholesalePrice?: boolean
    retailPrice?: boolean
    status?: boolean
    unitConcentrationId?: boolean
    supplierId?: boolean
    drugBrand?: boolean | DrugBrandDefaultArgs<ExtArgs>
    drug?: boolean | DrugDefaultArgs<ExtArgs>
    Supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    unitConcentration?: boolean | UnitConcentrationDefaultArgs<ExtArgs>
    BatchHistory?: boolean | Batch$BatchHistoryArgs<ExtArgs>
    Issue?: boolean | Batch$IssueArgs<ExtArgs>
    _count?: boolean | BatchCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["batch"]>

  export type BatchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    drugId?: boolean
    drugBrandId?: boolean
    type?: boolean
    fullAmount?: boolean
    expiry?: boolean
    stockDate?: boolean
    remainingQuantity?: boolean
    wholesalePrice?: boolean
    retailPrice?: boolean
    status?: boolean
    unitConcentrationId?: boolean
    supplierId?: boolean
    drugBrand?: boolean | DrugBrandDefaultArgs<ExtArgs>
    drug?: boolean | DrugDefaultArgs<ExtArgs>
    Supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    unitConcentration?: boolean | UnitConcentrationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["batch"]>

  export type BatchSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    drugId?: boolean
    drugBrandId?: boolean
    type?: boolean
    fullAmount?: boolean
    expiry?: boolean
    stockDate?: boolean
    remainingQuantity?: boolean
    wholesalePrice?: boolean
    retailPrice?: boolean
    status?: boolean
    unitConcentrationId?: boolean
    supplierId?: boolean
    drugBrand?: boolean | DrugBrandDefaultArgs<ExtArgs>
    drug?: boolean | DrugDefaultArgs<ExtArgs>
    Supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    unitConcentration?: boolean | UnitConcentrationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["batch"]>

  export type BatchSelectScalar = {
    id?: boolean
    number?: boolean
    drugId?: boolean
    drugBrandId?: boolean
    type?: boolean
    fullAmount?: boolean
    expiry?: boolean
    stockDate?: boolean
    remainingQuantity?: boolean
    wholesalePrice?: boolean
    retailPrice?: boolean
    status?: boolean
    unitConcentrationId?: boolean
    supplierId?: boolean
  }

  export type BatchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "number" | "drugId" | "drugBrandId" | "type" | "fullAmount" | "expiry" | "stockDate" | "remainingQuantity" | "wholesalePrice" | "retailPrice" | "status" | "unitConcentrationId" | "supplierId", ExtArgs["result"]["batch"]>
  export type BatchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    drugBrand?: boolean | DrugBrandDefaultArgs<ExtArgs>
    drug?: boolean | DrugDefaultArgs<ExtArgs>
    Supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    unitConcentration?: boolean | UnitConcentrationDefaultArgs<ExtArgs>
    BatchHistory?: boolean | Batch$BatchHistoryArgs<ExtArgs>
    Issue?: boolean | Batch$IssueArgs<ExtArgs>
    _count?: boolean | BatchCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BatchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    drugBrand?: boolean | DrugBrandDefaultArgs<ExtArgs>
    drug?: boolean | DrugDefaultArgs<ExtArgs>
    Supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    unitConcentration?: boolean | UnitConcentrationDefaultArgs<ExtArgs>
  }
  export type BatchIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    drugBrand?: boolean | DrugBrandDefaultArgs<ExtArgs>
    drug?: boolean | DrugDefaultArgs<ExtArgs>
    Supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    unitConcentration?: boolean | UnitConcentrationDefaultArgs<ExtArgs>
  }

  export type $BatchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Batch"
    objects: {
      drugBrand: Prisma.$DrugBrandPayload<ExtArgs>
      drug: Prisma.$DrugPayload<ExtArgs>
      Supplier: Prisma.$SupplierPayload<ExtArgs>
      unitConcentration: Prisma.$UnitConcentrationPayload<ExtArgs>
      BatchHistory: Prisma.$BatchHistoryPayload<ExtArgs>[]
      Issue: Prisma.$IssuePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      number: string
      drugId: number
      drugBrandId: number
      type: $Enums.DrugType
      fullAmount: number
      expiry: Date
      stockDate: Date
      remainingQuantity: number
      wholesalePrice: number
      retailPrice: number
      status: $Enums.BatchStatus
      unitConcentrationId: number
      supplierId: number
    }, ExtArgs["result"]["batch"]>
    composites: {}
  }

  type BatchGetPayload<S extends boolean | null | undefined | BatchDefaultArgs> = $Result.GetResult<Prisma.$BatchPayload, S>

  type BatchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BatchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BatchCountAggregateInputType | true
    }

  export interface BatchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Batch'], meta: { name: 'Batch' } }
    /**
     * Find zero or one Batch that matches the filter.
     * @param {BatchFindUniqueArgs} args - Arguments to find a Batch
     * @example
     * // Get one Batch
     * const batch = await prisma.batch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BatchFindUniqueArgs>(args: SelectSubset<T, BatchFindUniqueArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Batch that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BatchFindUniqueOrThrowArgs} args - Arguments to find a Batch
     * @example
     * // Get one Batch
     * const batch = await prisma.batch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BatchFindUniqueOrThrowArgs>(args: SelectSubset<T, BatchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Batch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchFindFirstArgs} args - Arguments to find a Batch
     * @example
     * // Get one Batch
     * const batch = await prisma.batch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BatchFindFirstArgs>(args?: SelectSubset<T, BatchFindFirstArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Batch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchFindFirstOrThrowArgs} args - Arguments to find a Batch
     * @example
     * // Get one Batch
     * const batch = await prisma.batch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BatchFindFirstOrThrowArgs>(args?: SelectSubset<T, BatchFindFirstOrThrowArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Batches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Batches
     * const batches = await prisma.batch.findMany()
     * 
     * // Get first 10 Batches
     * const batches = await prisma.batch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const batchWithIdOnly = await prisma.batch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BatchFindManyArgs>(args?: SelectSubset<T, BatchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Batch.
     * @param {BatchCreateArgs} args - Arguments to create a Batch.
     * @example
     * // Create one Batch
     * const Batch = await prisma.batch.create({
     *   data: {
     *     // ... data to create a Batch
     *   }
     * })
     * 
     */
    create<T extends BatchCreateArgs>(args: SelectSubset<T, BatchCreateArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Batches.
     * @param {BatchCreateManyArgs} args - Arguments to create many Batches.
     * @example
     * // Create many Batches
     * const batch = await prisma.batch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BatchCreateManyArgs>(args?: SelectSubset<T, BatchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Batches and returns the data saved in the database.
     * @param {BatchCreateManyAndReturnArgs} args - Arguments to create many Batches.
     * @example
     * // Create many Batches
     * const batch = await prisma.batch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Batches and only return the `id`
     * const batchWithIdOnly = await prisma.batch.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BatchCreateManyAndReturnArgs>(args?: SelectSubset<T, BatchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Batch.
     * @param {BatchDeleteArgs} args - Arguments to delete one Batch.
     * @example
     * // Delete one Batch
     * const Batch = await prisma.batch.delete({
     *   where: {
     *     // ... filter to delete one Batch
     *   }
     * })
     * 
     */
    delete<T extends BatchDeleteArgs>(args: SelectSubset<T, BatchDeleteArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Batch.
     * @param {BatchUpdateArgs} args - Arguments to update one Batch.
     * @example
     * // Update one Batch
     * const batch = await prisma.batch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BatchUpdateArgs>(args: SelectSubset<T, BatchUpdateArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Batches.
     * @param {BatchDeleteManyArgs} args - Arguments to filter Batches to delete.
     * @example
     * // Delete a few Batches
     * const { count } = await prisma.batch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BatchDeleteManyArgs>(args?: SelectSubset<T, BatchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Batches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Batches
     * const batch = await prisma.batch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BatchUpdateManyArgs>(args: SelectSubset<T, BatchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Batches and returns the data updated in the database.
     * @param {BatchUpdateManyAndReturnArgs} args - Arguments to update many Batches.
     * @example
     * // Update many Batches
     * const batch = await prisma.batch.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Batches and only return the `id`
     * const batchWithIdOnly = await prisma.batch.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BatchUpdateManyAndReturnArgs>(args: SelectSubset<T, BatchUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Batch.
     * @param {BatchUpsertArgs} args - Arguments to update or create a Batch.
     * @example
     * // Update or create a Batch
     * const batch = await prisma.batch.upsert({
     *   create: {
     *     // ... data to create a Batch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Batch we want to update
     *   }
     * })
     */
    upsert<T extends BatchUpsertArgs>(args: SelectSubset<T, BatchUpsertArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Batches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchCountArgs} args - Arguments to filter Batches to count.
     * @example
     * // Count the number of Batches
     * const count = await prisma.batch.count({
     *   where: {
     *     // ... the filter for the Batches we want to count
     *   }
     * })
    **/
    count<T extends BatchCountArgs>(
      args?: Subset<T, BatchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BatchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Batch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BatchAggregateArgs>(args: Subset<T, BatchAggregateArgs>): Prisma.PrismaPromise<GetBatchAggregateType<T>>

    /**
     * Group by Batch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BatchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BatchGroupByArgs['orderBy'] }
        : { orderBy?: BatchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BatchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBatchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Batch model
   */
  readonly fields: BatchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Batch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BatchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    drugBrand<T extends DrugBrandDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DrugBrandDefaultArgs<ExtArgs>>): Prisma__DrugBrandClient<$Result.GetResult<Prisma.$DrugBrandPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    drug<T extends DrugDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DrugDefaultArgs<ExtArgs>>): Prisma__DrugClient<$Result.GetResult<Prisma.$DrugPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Supplier<T extends SupplierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SupplierDefaultArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    unitConcentration<T extends UnitConcentrationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitConcentrationDefaultArgs<ExtArgs>>): Prisma__UnitConcentrationClient<$Result.GetResult<Prisma.$UnitConcentrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    BatchHistory<T extends Batch$BatchHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Batch$BatchHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Issue<T extends Batch$IssueArgs<ExtArgs> = {}>(args?: Subset<T, Batch$IssueArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Batch model
   */ 
  interface BatchFieldRefs {
    readonly id: FieldRef<"Batch", 'Int'>
    readonly number: FieldRef<"Batch", 'String'>
    readonly drugId: FieldRef<"Batch", 'Int'>
    readonly drugBrandId: FieldRef<"Batch", 'Int'>
    readonly type: FieldRef<"Batch", 'DrugType'>
    readonly fullAmount: FieldRef<"Batch", 'Float'>
    readonly expiry: FieldRef<"Batch", 'DateTime'>
    readonly stockDate: FieldRef<"Batch", 'DateTime'>
    readonly remainingQuantity: FieldRef<"Batch", 'Float'>
    readonly wholesalePrice: FieldRef<"Batch", 'Float'>
    readonly retailPrice: FieldRef<"Batch", 'Float'>
    readonly status: FieldRef<"Batch", 'BatchStatus'>
    readonly unitConcentrationId: FieldRef<"Batch", 'Int'>
    readonly supplierId: FieldRef<"Batch", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Batch findUnique
   */
  export type BatchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * Filter, which Batch to fetch.
     */
    where: BatchWhereUniqueInput
  }

  /**
   * Batch findUniqueOrThrow
   */
  export type BatchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * Filter, which Batch to fetch.
     */
    where: BatchWhereUniqueInput
  }

  /**
   * Batch findFirst
   */
  export type BatchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * Filter, which Batch to fetch.
     */
    where?: BatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Batches to fetch.
     */
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Batches.
     */
    cursor?: BatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Batches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Batches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Batches.
     */
    distinct?: BatchScalarFieldEnum | BatchScalarFieldEnum[]
  }

  /**
   * Batch findFirstOrThrow
   */
  export type BatchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * Filter, which Batch to fetch.
     */
    where?: BatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Batches to fetch.
     */
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Batches.
     */
    cursor?: BatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Batches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Batches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Batches.
     */
    distinct?: BatchScalarFieldEnum | BatchScalarFieldEnum[]
  }

  /**
   * Batch findMany
   */
  export type BatchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * Filter, which Batches to fetch.
     */
    where?: BatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Batches to fetch.
     */
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Batches.
     */
    cursor?: BatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Batches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Batches.
     */
    skip?: number
    distinct?: BatchScalarFieldEnum | BatchScalarFieldEnum[]
  }

  /**
   * Batch create
   */
  export type BatchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * The data needed to create a Batch.
     */
    data: XOR<BatchCreateInput, BatchUncheckedCreateInput>
  }

  /**
   * Batch createMany
   */
  export type BatchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Batches.
     */
    data: BatchCreateManyInput | BatchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Batch createManyAndReturn
   */
  export type BatchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * The data used to create many Batches.
     */
    data: BatchCreateManyInput | BatchCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Batch update
   */
  export type BatchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * The data needed to update a Batch.
     */
    data: XOR<BatchUpdateInput, BatchUncheckedUpdateInput>
    /**
     * Choose, which Batch to update.
     */
    where: BatchWhereUniqueInput
  }

  /**
   * Batch updateMany
   */
  export type BatchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Batches.
     */
    data: XOR<BatchUpdateManyMutationInput, BatchUncheckedUpdateManyInput>
    /**
     * Filter which Batches to update
     */
    where?: BatchWhereInput
    /**
     * Limit how many Batches to update.
     */
    limit?: number
  }

  /**
   * Batch updateManyAndReturn
   */
  export type BatchUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * The data used to update Batches.
     */
    data: XOR<BatchUpdateManyMutationInput, BatchUncheckedUpdateManyInput>
    /**
     * Filter which Batches to update
     */
    where?: BatchWhereInput
    /**
     * Limit how many Batches to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Batch upsert
   */
  export type BatchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * The filter to search for the Batch to update in case it exists.
     */
    where: BatchWhereUniqueInput
    /**
     * In case the Batch found by the `where` argument doesn't exist, create a new Batch with this data.
     */
    create: XOR<BatchCreateInput, BatchUncheckedCreateInput>
    /**
     * In case the Batch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BatchUpdateInput, BatchUncheckedUpdateInput>
  }

  /**
   * Batch delete
   */
  export type BatchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * Filter which Batch to delete.
     */
    where: BatchWhereUniqueInput
  }

  /**
   * Batch deleteMany
   */
  export type BatchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Batches to delete
     */
    where?: BatchWhereInput
    /**
     * Limit how many Batches to delete.
     */
    limit?: number
  }

  /**
   * Batch.BatchHistory
   */
  export type Batch$BatchHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchHistory
     */
    select?: BatchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchHistory
     */
    omit?: BatchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchHistoryInclude<ExtArgs> | null
    where?: BatchHistoryWhereInput
    orderBy?: BatchHistoryOrderByWithRelationInput | BatchHistoryOrderByWithRelationInput[]
    cursor?: BatchHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BatchHistoryScalarFieldEnum | BatchHistoryScalarFieldEnum[]
  }

  /**
   * Batch.Issue
   */
  export type Batch$IssueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issue
     */
    select?: IssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Issue
     */
    omit?: IssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueInclude<ExtArgs> | null
    where?: IssueWhereInput
    orderBy?: IssueOrderByWithRelationInput | IssueOrderByWithRelationInput[]
    cursor?: IssueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IssueScalarFieldEnum | IssueScalarFieldEnum[]
  }

  /**
   * Batch without action
   */
  export type BatchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
  }


  /**
   * Model UnitConcentration
   */

  export type AggregateUnitConcentration = {
    _count: UnitConcentrationCountAggregateOutputType | null
    _avg: UnitConcentrationAvgAggregateOutputType | null
    _sum: UnitConcentrationSumAggregateOutputType | null
    _min: UnitConcentrationMinAggregateOutputType | null
    _max: UnitConcentrationMaxAggregateOutputType | null
  }

  export type UnitConcentrationAvgAggregateOutputType = {
    id: number | null
    concentration: number | null
  }

  export type UnitConcentrationSumAggregateOutputType = {
    id: number | null
    concentration: number | null
  }

  export type UnitConcentrationMinAggregateOutputType = {
    id: number | null
    concentration: number | null
  }

  export type UnitConcentrationMaxAggregateOutputType = {
    id: number | null
    concentration: number | null
  }

  export type UnitConcentrationCountAggregateOutputType = {
    id: number
    concentration: number
    _all: number
  }


  export type UnitConcentrationAvgAggregateInputType = {
    id?: true
    concentration?: true
  }

  export type UnitConcentrationSumAggregateInputType = {
    id?: true
    concentration?: true
  }

  export type UnitConcentrationMinAggregateInputType = {
    id?: true
    concentration?: true
  }

  export type UnitConcentrationMaxAggregateInputType = {
    id?: true
    concentration?: true
  }

  export type UnitConcentrationCountAggregateInputType = {
    id?: true
    concentration?: true
    _all?: true
  }

  export type UnitConcentrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitConcentration to aggregate.
     */
    where?: UnitConcentrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitConcentrations to fetch.
     */
    orderBy?: UnitConcentrationOrderByWithRelationInput | UnitConcentrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitConcentrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitConcentrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitConcentrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UnitConcentrations
    **/
    _count?: true | UnitConcentrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UnitConcentrationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UnitConcentrationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitConcentrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitConcentrationMaxAggregateInputType
  }

  export type GetUnitConcentrationAggregateType<T extends UnitConcentrationAggregateArgs> = {
        [P in keyof T & keyof AggregateUnitConcentration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnitConcentration[P]>
      : GetScalarType<T[P], AggregateUnitConcentration[P]>
  }




  export type UnitConcentrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitConcentrationWhereInput
    orderBy?: UnitConcentrationOrderByWithAggregationInput | UnitConcentrationOrderByWithAggregationInput[]
    by: UnitConcentrationScalarFieldEnum[] | UnitConcentrationScalarFieldEnum
    having?: UnitConcentrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitConcentrationCountAggregateInputType | true
    _avg?: UnitConcentrationAvgAggregateInputType
    _sum?: UnitConcentrationSumAggregateInputType
    _min?: UnitConcentrationMinAggregateInputType
    _max?: UnitConcentrationMaxAggregateInputType
  }

  export type UnitConcentrationGroupByOutputType = {
    id: number
    concentration: number
    _count: UnitConcentrationCountAggregateOutputType | null
    _avg: UnitConcentrationAvgAggregateOutputType | null
    _sum: UnitConcentrationSumAggregateOutputType | null
    _min: UnitConcentrationMinAggregateOutputType | null
    _max: UnitConcentrationMaxAggregateOutputType | null
  }

  type GetUnitConcentrationGroupByPayload<T extends UnitConcentrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitConcentrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitConcentrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitConcentrationGroupByOutputType[P]>
            : GetScalarType<T[P], UnitConcentrationGroupByOutputType[P]>
        }
      >
    >


  export type UnitConcentrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    concentration?: boolean
    Batch?: boolean | UnitConcentration$BatchArgs<ExtArgs>
    BatchHistory?: boolean | UnitConcentration$BatchHistoryArgs<ExtArgs>
    Issue?: boolean | UnitConcentration$IssueArgs<ExtArgs>
    BufferLevel?: boolean | UnitConcentration$BufferLevelArgs<ExtArgs>
    _count?: boolean | UnitConcentrationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitConcentration"]>

  export type UnitConcentrationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    concentration?: boolean
  }, ExtArgs["result"]["unitConcentration"]>

  export type UnitConcentrationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    concentration?: boolean
  }, ExtArgs["result"]["unitConcentration"]>

  export type UnitConcentrationSelectScalar = {
    id?: boolean
    concentration?: boolean
  }

  export type UnitConcentrationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "concentration", ExtArgs["result"]["unitConcentration"]>
  export type UnitConcentrationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Batch?: boolean | UnitConcentration$BatchArgs<ExtArgs>
    BatchHistory?: boolean | UnitConcentration$BatchHistoryArgs<ExtArgs>
    Issue?: boolean | UnitConcentration$IssueArgs<ExtArgs>
    BufferLevel?: boolean | UnitConcentration$BufferLevelArgs<ExtArgs>
    _count?: boolean | UnitConcentrationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UnitConcentrationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UnitConcentrationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UnitConcentrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UnitConcentration"
    objects: {
      Batch: Prisma.$BatchPayload<ExtArgs>[]
      BatchHistory: Prisma.$BatchHistoryPayload<ExtArgs>[]
      Issue: Prisma.$IssuePayload<ExtArgs>[]
      BufferLevel: Prisma.$BufferLevelPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      concentration: number
    }, ExtArgs["result"]["unitConcentration"]>
    composites: {}
  }

  type UnitConcentrationGetPayload<S extends boolean | null | undefined | UnitConcentrationDefaultArgs> = $Result.GetResult<Prisma.$UnitConcentrationPayload, S>

  type UnitConcentrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UnitConcentrationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UnitConcentrationCountAggregateInputType | true
    }

  export interface UnitConcentrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UnitConcentration'], meta: { name: 'UnitConcentration' } }
    /**
     * Find zero or one UnitConcentration that matches the filter.
     * @param {UnitConcentrationFindUniqueArgs} args - Arguments to find a UnitConcentration
     * @example
     * // Get one UnitConcentration
     * const unitConcentration = await prisma.unitConcentration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnitConcentrationFindUniqueArgs>(args: SelectSubset<T, UnitConcentrationFindUniqueArgs<ExtArgs>>): Prisma__UnitConcentrationClient<$Result.GetResult<Prisma.$UnitConcentrationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UnitConcentration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UnitConcentrationFindUniqueOrThrowArgs} args - Arguments to find a UnitConcentration
     * @example
     * // Get one UnitConcentration
     * const unitConcentration = await prisma.unitConcentration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnitConcentrationFindUniqueOrThrowArgs>(args: SelectSubset<T, UnitConcentrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnitConcentrationClient<$Result.GetResult<Prisma.$UnitConcentrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitConcentration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitConcentrationFindFirstArgs} args - Arguments to find a UnitConcentration
     * @example
     * // Get one UnitConcentration
     * const unitConcentration = await prisma.unitConcentration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnitConcentrationFindFirstArgs>(args?: SelectSubset<T, UnitConcentrationFindFirstArgs<ExtArgs>>): Prisma__UnitConcentrationClient<$Result.GetResult<Prisma.$UnitConcentrationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitConcentration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitConcentrationFindFirstOrThrowArgs} args - Arguments to find a UnitConcentration
     * @example
     * // Get one UnitConcentration
     * const unitConcentration = await prisma.unitConcentration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnitConcentrationFindFirstOrThrowArgs>(args?: SelectSubset<T, UnitConcentrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnitConcentrationClient<$Result.GetResult<Prisma.$UnitConcentrationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UnitConcentrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitConcentrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UnitConcentrations
     * const unitConcentrations = await prisma.unitConcentration.findMany()
     * 
     * // Get first 10 UnitConcentrations
     * const unitConcentrations = await prisma.unitConcentration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitConcentrationWithIdOnly = await prisma.unitConcentration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnitConcentrationFindManyArgs>(args?: SelectSubset<T, UnitConcentrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitConcentrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UnitConcentration.
     * @param {UnitConcentrationCreateArgs} args - Arguments to create a UnitConcentration.
     * @example
     * // Create one UnitConcentration
     * const UnitConcentration = await prisma.unitConcentration.create({
     *   data: {
     *     // ... data to create a UnitConcentration
     *   }
     * })
     * 
     */
    create<T extends UnitConcentrationCreateArgs>(args: SelectSubset<T, UnitConcentrationCreateArgs<ExtArgs>>): Prisma__UnitConcentrationClient<$Result.GetResult<Prisma.$UnitConcentrationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UnitConcentrations.
     * @param {UnitConcentrationCreateManyArgs} args - Arguments to create many UnitConcentrations.
     * @example
     * // Create many UnitConcentrations
     * const unitConcentration = await prisma.unitConcentration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnitConcentrationCreateManyArgs>(args?: SelectSubset<T, UnitConcentrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UnitConcentrations and returns the data saved in the database.
     * @param {UnitConcentrationCreateManyAndReturnArgs} args - Arguments to create many UnitConcentrations.
     * @example
     * // Create many UnitConcentrations
     * const unitConcentration = await prisma.unitConcentration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UnitConcentrations and only return the `id`
     * const unitConcentrationWithIdOnly = await prisma.unitConcentration.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UnitConcentrationCreateManyAndReturnArgs>(args?: SelectSubset<T, UnitConcentrationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitConcentrationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UnitConcentration.
     * @param {UnitConcentrationDeleteArgs} args - Arguments to delete one UnitConcentration.
     * @example
     * // Delete one UnitConcentration
     * const UnitConcentration = await prisma.unitConcentration.delete({
     *   where: {
     *     // ... filter to delete one UnitConcentration
     *   }
     * })
     * 
     */
    delete<T extends UnitConcentrationDeleteArgs>(args: SelectSubset<T, UnitConcentrationDeleteArgs<ExtArgs>>): Prisma__UnitConcentrationClient<$Result.GetResult<Prisma.$UnitConcentrationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UnitConcentration.
     * @param {UnitConcentrationUpdateArgs} args - Arguments to update one UnitConcentration.
     * @example
     * // Update one UnitConcentration
     * const unitConcentration = await prisma.unitConcentration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnitConcentrationUpdateArgs>(args: SelectSubset<T, UnitConcentrationUpdateArgs<ExtArgs>>): Prisma__UnitConcentrationClient<$Result.GetResult<Prisma.$UnitConcentrationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UnitConcentrations.
     * @param {UnitConcentrationDeleteManyArgs} args - Arguments to filter UnitConcentrations to delete.
     * @example
     * // Delete a few UnitConcentrations
     * const { count } = await prisma.unitConcentration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnitConcentrationDeleteManyArgs>(args?: SelectSubset<T, UnitConcentrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitConcentrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitConcentrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UnitConcentrations
     * const unitConcentration = await prisma.unitConcentration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnitConcentrationUpdateManyArgs>(args: SelectSubset<T, UnitConcentrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitConcentrations and returns the data updated in the database.
     * @param {UnitConcentrationUpdateManyAndReturnArgs} args - Arguments to update many UnitConcentrations.
     * @example
     * // Update many UnitConcentrations
     * const unitConcentration = await prisma.unitConcentration.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UnitConcentrations and only return the `id`
     * const unitConcentrationWithIdOnly = await prisma.unitConcentration.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UnitConcentrationUpdateManyAndReturnArgs>(args: SelectSubset<T, UnitConcentrationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitConcentrationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UnitConcentration.
     * @param {UnitConcentrationUpsertArgs} args - Arguments to update or create a UnitConcentration.
     * @example
     * // Update or create a UnitConcentration
     * const unitConcentration = await prisma.unitConcentration.upsert({
     *   create: {
     *     // ... data to create a UnitConcentration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UnitConcentration we want to update
     *   }
     * })
     */
    upsert<T extends UnitConcentrationUpsertArgs>(args: SelectSubset<T, UnitConcentrationUpsertArgs<ExtArgs>>): Prisma__UnitConcentrationClient<$Result.GetResult<Prisma.$UnitConcentrationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UnitConcentrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitConcentrationCountArgs} args - Arguments to filter UnitConcentrations to count.
     * @example
     * // Count the number of UnitConcentrations
     * const count = await prisma.unitConcentration.count({
     *   where: {
     *     // ... the filter for the UnitConcentrations we want to count
     *   }
     * })
    **/
    count<T extends UnitConcentrationCountArgs>(
      args?: Subset<T, UnitConcentrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitConcentrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UnitConcentration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitConcentrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitConcentrationAggregateArgs>(args: Subset<T, UnitConcentrationAggregateArgs>): Prisma.PrismaPromise<GetUnitConcentrationAggregateType<T>>

    /**
     * Group by UnitConcentration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitConcentrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitConcentrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitConcentrationGroupByArgs['orderBy'] }
        : { orderBy?: UnitConcentrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitConcentrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitConcentrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UnitConcentration model
   */
  readonly fields: UnitConcentrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UnitConcentration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitConcentrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Batch<T extends UnitConcentration$BatchArgs<ExtArgs> = {}>(args?: Subset<T, UnitConcentration$BatchArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    BatchHistory<T extends UnitConcentration$BatchHistoryArgs<ExtArgs> = {}>(args?: Subset<T, UnitConcentration$BatchHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Issue<T extends UnitConcentration$IssueArgs<ExtArgs> = {}>(args?: Subset<T, UnitConcentration$IssueArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    BufferLevel<T extends UnitConcentration$BufferLevelArgs<ExtArgs> = {}>(args?: Subset<T, UnitConcentration$BufferLevelArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BufferLevelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UnitConcentration model
   */ 
  interface UnitConcentrationFieldRefs {
    readonly id: FieldRef<"UnitConcentration", 'Int'>
    readonly concentration: FieldRef<"UnitConcentration", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * UnitConcentration findUnique
   */
  export type UnitConcentrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitConcentration
     */
    select?: UnitConcentrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitConcentration
     */
    omit?: UnitConcentrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitConcentrationInclude<ExtArgs> | null
    /**
     * Filter, which UnitConcentration to fetch.
     */
    where: UnitConcentrationWhereUniqueInput
  }

  /**
   * UnitConcentration findUniqueOrThrow
   */
  export type UnitConcentrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitConcentration
     */
    select?: UnitConcentrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitConcentration
     */
    omit?: UnitConcentrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitConcentrationInclude<ExtArgs> | null
    /**
     * Filter, which UnitConcentration to fetch.
     */
    where: UnitConcentrationWhereUniqueInput
  }

  /**
   * UnitConcentration findFirst
   */
  export type UnitConcentrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitConcentration
     */
    select?: UnitConcentrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitConcentration
     */
    omit?: UnitConcentrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitConcentrationInclude<ExtArgs> | null
    /**
     * Filter, which UnitConcentration to fetch.
     */
    where?: UnitConcentrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitConcentrations to fetch.
     */
    orderBy?: UnitConcentrationOrderByWithRelationInput | UnitConcentrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitConcentrations.
     */
    cursor?: UnitConcentrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitConcentrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitConcentrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitConcentrations.
     */
    distinct?: UnitConcentrationScalarFieldEnum | UnitConcentrationScalarFieldEnum[]
  }

  /**
   * UnitConcentration findFirstOrThrow
   */
  export type UnitConcentrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitConcentration
     */
    select?: UnitConcentrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitConcentration
     */
    omit?: UnitConcentrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitConcentrationInclude<ExtArgs> | null
    /**
     * Filter, which UnitConcentration to fetch.
     */
    where?: UnitConcentrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitConcentrations to fetch.
     */
    orderBy?: UnitConcentrationOrderByWithRelationInput | UnitConcentrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitConcentrations.
     */
    cursor?: UnitConcentrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitConcentrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitConcentrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitConcentrations.
     */
    distinct?: UnitConcentrationScalarFieldEnum | UnitConcentrationScalarFieldEnum[]
  }

  /**
   * UnitConcentration findMany
   */
  export type UnitConcentrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitConcentration
     */
    select?: UnitConcentrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitConcentration
     */
    omit?: UnitConcentrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitConcentrationInclude<ExtArgs> | null
    /**
     * Filter, which UnitConcentrations to fetch.
     */
    where?: UnitConcentrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitConcentrations to fetch.
     */
    orderBy?: UnitConcentrationOrderByWithRelationInput | UnitConcentrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UnitConcentrations.
     */
    cursor?: UnitConcentrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitConcentrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitConcentrations.
     */
    skip?: number
    distinct?: UnitConcentrationScalarFieldEnum | UnitConcentrationScalarFieldEnum[]
  }

  /**
   * UnitConcentration create
   */
  export type UnitConcentrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitConcentration
     */
    select?: UnitConcentrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitConcentration
     */
    omit?: UnitConcentrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitConcentrationInclude<ExtArgs> | null
    /**
     * The data needed to create a UnitConcentration.
     */
    data: XOR<UnitConcentrationCreateInput, UnitConcentrationUncheckedCreateInput>
  }

  /**
   * UnitConcentration createMany
   */
  export type UnitConcentrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UnitConcentrations.
     */
    data: UnitConcentrationCreateManyInput | UnitConcentrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UnitConcentration createManyAndReturn
   */
  export type UnitConcentrationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitConcentration
     */
    select?: UnitConcentrationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UnitConcentration
     */
    omit?: UnitConcentrationOmit<ExtArgs> | null
    /**
     * The data used to create many UnitConcentrations.
     */
    data: UnitConcentrationCreateManyInput | UnitConcentrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UnitConcentration update
   */
  export type UnitConcentrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitConcentration
     */
    select?: UnitConcentrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitConcentration
     */
    omit?: UnitConcentrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitConcentrationInclude<ExtArgs> | null
    /**
     * The data needed to update a UnitConcentration.
     */
    data: XOR<UnitConcentrationUpdateInput, UnitConcentrationUncheckedUpdateInput>
    /**
     * Choose, which UnitConcentration to update.
     */
    where: UnitConcentrationWhereUniqueInput
  }

  /**
   * UnitConcentration updateMany
   */
  export type UnitConcentrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UnitConcentrations.
     */
    data: XOR<UnitConcentrationUpdateManyMutationInput, UnitConcentrationUncheckedUpdateManyInput>
    /**
     * Filter which UnitConcentrations to update
     */
    where?: UnitConcentrationWhereInput
    /**
     * Limit how many UnitConcentrations to update.
     */
    limit?: number
  }

  /**
   * UnitConcentration updateManyAndReturn
   */
  export type UnitConcentrationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitConcentration
     */
    select?: UnitConcentrationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UnitConcentration
     */
    omit?: UnitConcentrationOmit<ExtArgs> | null
    /**
     * The data used to update UnitConcentrations.
     */
    data: XOR<UnitConcentrationUpdateManyMutationInput, UnitConcentrationUncheckedUpdateManyInput>
    /**
     * Filter which UnitConcentrations to update
     */
    where?: UnitConcentrationWhereInput
    /**
     * Limit how many UnitConcentrations to update.
     */
    limit?: number
  }

  /**
   * UnitConcentration upsert
   */
  export type UnitConcentrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitConcentration
     */
    select?: UnitConcentrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitConcentration
     */
    omit?: UnitConcentrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitConcentrationInclude<ExtArgs> | null
    /**
     * The filter to search for the UnitConcentration to update in case it exists.
     */
    where: UnitConcentrationWhereUniqueInput
    /**
     * In case the UnitConcentration found by the `where` argument doesn't exist, create a new UnitConcentration with this data.
     */
    create: XOR<UnitConcentrationCreateInput, UnitConcentrationUncheckedCreateInput>
    /**
     * In case the UnitConcentration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitConcentrationUpdateInput, UnitConcentrationUncheckedUpdateInput>
  }

  /**
   * UnitConcentration delete
   */
  export type UnitConcentrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitConcentration
     */
    select?: UnitConcentrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitConcentration
     */
    omit?: UnitConcentrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitConcentrationInclude<ExtArgs> | null
    /**
     * Filter which UnitConcentration to delete.
     */
    where: UnitConcentrationWhereUniqueInput
  }

  /**
   * UnitConcentration deleteMany
   */
  export type UnitConcentrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitConcentrations to delete
     */
    where?: UnitConcentrationWhereInput
    /**
     * Limit how many UnitConcentrations to delete.
     */
    limit?: number
  }

  /**
   * UnitConcentration.Batch
   */
  export type UnitConcentration$BatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    where?: BatchWhereInput
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    cursor?: BatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BatchScalarFieldEnum | BatchScalarFieldEnum[]
  }

  /**
   * UnitConcentration.BatchHistory
   */
  export type UnitConcentration$BatchHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchHistory
     */
    select?: BatchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchHistory
     */
    omit?: BatchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchHistoryInclude<ExtArgs> | null
    where?: BatchHistoryWhereInput
    orderBy?: BatchHistoryOrderByWithRelationInput | BatchHistoryOrderByWithRelationInput[]
    cursor?: BatchHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BatchHistoryScalarFieldEnum | BatchHistoryScalarFieldEnum[]
  }

  /**
   * UnitConcentration.Issue
   */
  export type UnitConcentration$IssueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issue
     */
    select?: IssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Issue
     */
    omit?: IssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueInclude<ExtArgs> | null
    where?: IssueWhereInput
    orderBy?: IssueOrderByWithRelationInput | IssueOrderByWithRelationInput[]
    cursor?: IssueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IssueScalarFieldEnum | IssueScalarFieldEnum[]
  }

  /**
   * UnitConcentration.BufferLevel
   */
  export type UnitConcentration$BufferLevelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BufferLevel
     */
    select?: BufferLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BufferLevel
     */
    omit?: BufferLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BufferLevelInclude<ExtArgs> | null
    where?: BufferLevelWhereInput
    orderBy?: BufferLevelOrderByWithRelationInput | BufferLevelOrderByWithRelationInput[]
    cursor?: BufferLevelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BufferLevelScalarFieldEnum | BufferLevelScalarFieldEnum[]
  }

  /**
   * UnitConcentration without action
   */
  export type UnitConcentrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitConcentration
     */
    select?: UnitConcentrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitConcentration
     */
    omit?: UnitConcentrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitConcentrationInclude<ExtArgs> | null
  }


  /**
   * Model Prescription
   */

  export type AggregatePrescription = {
    _count: PrescriptionCountAggregateOutputType | null
    _avg: PrescriptionAvgAggregateOutputType | null
    _sum: PrescriptionSumAggregateOutputType | null
    _min: PrescriptionMinAggregateOutputType | null
    _max: PrescriptionMaxAggregateOutputType | null
  }

  export type PrescriptionAvgAggregateOutputType = {
    id: number | null
    patientId: number | null
    finalPrice: number | null
  }

  export type PrescriptionSumAggregateOutputType = {
    id: number | null
    patientId: number | null
    finalPrice: number | null
  }

  export type PrescriptionMinAggregateOutputType = {
    id: number | null
    time: Date | null
    presentingSymptoms: string | null
    status: $Enums.PrescriptionStatus | null
    details: string | null
    patientId: number | null
    finalPrice: number | null
  }

  export type PrescriptionMaxAggregateOutputType = {
    id: number | null
    time: Date | null
    presentingSymptoms: string | null
    status: $Enums.PrescriptionStatus | null
    details: string | null
    patientId: number | null
    finalPrice: number | null
  }

  export type PrescriptionCountAggregateOutputType = {
    id: number
    time: number
    presentingSymptoms: number
    status: number
    details: number
    patientId: number
    finalPrice: number
    _all: number
  }


  export type PrescriptionAvgAggregateInputType = {
    id?: true
    patientId?: true
    finalPrice?: true
  }

  export type PrescriptionSumAggregateInputType = {
    id?: true
    patientId?: true
    finalPrice?: true
  }

  export type PrescriptionMinAggregateInputType = {
    id?: true
    time?: true
    presentingSymptoms?: true
    status?: true
    details?: true
    patientId?: true
    finalPrice?: true
  }

  export type PrescriptionMaxAggregateInputType = {
    id?: true
    time?: true
    presentingSymptoms?: true
    status?: true
    details?: true
    patientId?: true
    finalPrice?: true
  }

  export type PrescriptionCountAggregateInputType = {
    id?: true
    time?: true
    presentingSymptoms?: true
    status?: true
    details?: true
    patientId?: true
    finalPrice?: true
    _all?: true
  }

  export type PrescriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prescription to aggregate.
     */
    where?: PrescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prescriptions to fetch.
     */
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Prescriptions
    **/
    _count?: true | PrescriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PrescriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PrescriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrescriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrescriptionMaxAggregateInputType
  }

  export type GetPrescriptionAggregateType<T extends PrescriptionAggregateArgs> = {
        [P in keyof T & keyof AggregatePrescription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrescription[P]>
      : GetScalarType<T[P], AggregatePrescription[P]>
  }




  export type PrescriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionWhereInput
    orderBy?: PrescriptionOrderByWithAggregationInput | PrescriptionOrderByWithAggregationInput[]
    by: PrescriptionScalarFieldEnum[] | PrescriptionScalarFieldEnum
    having?: PrescriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrescriptionCountAggregateInputType | true
    _avg?: PrescriptionAvgAggregateInputType
    _sum?: PrescriptionSumAggregateInputType
    _min?: PrescriptionMinAggregateInputType
    _max?: PrescriptionMaxAggregateInputType
  }

  export type PrescriptionGroupByOutputType = {
    id: number
    time: Date
    presentingSymptoms: string
    status: $Enums.PrescriptionStatus
    details: string | null
    patientId: number
    finalPrice: number | null
    _count: PrescriptionCountAggregateOutputType | null
    _avg: PrescriptionAvgAggregateOutputType | null
    _sum: PrescriptionSumAggregateOutputType | null
    _min: PrescriptionMinAggregateOutputType | null
    _max: PrescriptionMaxAggregateOutputType | null
  }

  type GetPrescriptionGroupByPayload<T extends PrescriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrescriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrescriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrescriptionGroupByOutputType[P]>
            : GetScalarType<T[P], PrescriptionGroupByOutputType[P]>
        }
      >
    >


  export type PrescriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    time?: boolean
    presentingSymptoms?: boolean
    status?: boolean
    details?: boolean
    patientId?: boolean
    finalPrice?: boolean
    issues?: boolean | Prescription$issuesArgs<ExtArgs>
    OffRecordMeds?: boolean | Prescription$OffRecordMedsArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    PrescriptionVitals?: boolean | Prescription$PrescriptionVitalsArgs<ExtArgs>
    Charges?: boolean | Prescription$ChargesArgs<ExtArgs>
    _count?: boolean | PrescriptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prescription"]>

  export type PrescriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    time?: boolean
    presentingSymptoms?: boolean
    status?: boolean
    details?: boolean
    patientId?: boolean
    finalPrice?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prescription"]>

  export type PrescriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    time?: boolean
    presentingSymptoms?: boolean
    status?: boolean
    details?: boolean
    patientId?: boolean
    finalPrice?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prescription"]>

  export type PrescriptionSelectScalar = {
    id?: boolean
    time?: boolean
    presentingSymptoms?: boolean
    status?: boolean
    details?: boolean
    patientId?: boolean
    finalPrice?: boolean
  }

  export type PrescriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "time" | "presentingSymptoms" | "status" | "details" | "patientId" | "finalPrice", ExtArgs["result"]["prescription"]>
  export type PrescriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    issues?: boolean | Prescription$issuesArgs<ExtArgs>
    OffRecordMeds?: boolean | Prescription$OffRecordMedsArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    PrescriptionVitals?: boolean | Prescription$PrescriptionVitalsArgs<ExtArgs>
    Charges?: boolean | Prescription$ChargesArgs<ExtArgs>
    _count?: boolean | PrescriptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PrescriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type PrescriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }

  export type $PrescriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Prescription"
    objects: {
      issues: Prisma.$IssuePayload<ExtArgs>[]
      OffRecordMeds: Prisma.$OffRecordMedsPayload<ExtArgs>[]
      patient: Prisma.$PatientPayload<ExtArgs>
      PrescriptionVitals: Prisma.$PrescriptionVitalsPayload<ExtArgs>[]
      Charges: Prisma.$PrescriptionChargesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      time: Date
      presentingSymptoms: string
      status: $Enums.PrescriptionStatus
      details: string | null
      patientId: number
      finalPrice: number | null
    }, ExtArgs["result"]["prescription"]>
    composites: {}
  }

  type PrescriptionGetPayload<S extends boolean | null | undefined | PrescriptionDefaultArgs> = $Result.GetResult<Prisma.$PrescriptionPayload, S>

  type PrescriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PrescriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PrescriptionCountAggregateInputType | true
    }

  export interface PrescriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Prescription'], meta: { name: 'Prescription' } }
    /**
     * Find zero or one Prescription that matches the filter.
     * @param {PrescriptionFindUniqueArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PrescriptionFindUniqueArgs>(args: SelectSubset<T, PrescriptionFindUniqueArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Prescription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PrescriptionFindUniqueOrThrowArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PrescriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, PrescriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Prescription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionFindFirstArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PrescriptionFindFirstArgs>(args?: SelectSubset<T, PrescriptionFindFirstArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Prescription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionFindFirstOrThrowArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PrescriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, PrescriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Prescriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prescriptions
     * const prescriptions = await prisma.prescription.findMany()
     * 
     * // Get first 10 Prescriptions
     * const prescriptions = await prisma.prescription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const prescriptionWithIdOnly = await prisma.prescription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PrescriptionFindManyArgs>(args?: SelectSubset<T, PrescriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Prescription.
     * @param {PrescriptionCreateArgs} args - Arguments to create a Prescription.
     * @example
     * // Create one Prescription
     * const Prescription = await prisma.prescription.create({
     *   data: {
     *     // ... data to create a Prescription
     *   }
     * })
     * 
     */
    create<T extends PrescriptionCreateArgs>(args: SelectSubset<T, PrescriptionCreateArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Prescriptions.
     * @param {PrescriptionCreateManyArgs} args - Arguments to create many Prescriptions.
     * @example
     * // Create many Prescriptions
     * const prescription = await prisma.prescription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PrescriptionCreateManyArgs>(args?: SelectSubset<T, PrescriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Prescriptions and returns the data saved in the database.
     * @param {PrescriptionCreateManyAndReturnArgs} args - Arguments to create many Prescriptions.
     * @example
     * // Create many Prescriptions
     * const prescription = await prisma.prescription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Prescriptions and only return the `id`
     * const prescriptionWithIdOnly = await prisma.prescription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PrescriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, PrescriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Prescription.
     * @param {PrescriptionDeleteArgs} args - Arguments to delete one Prescription.
     * @example
     * // Delete one Prescription
     * const Prescription = await prisma.prescription.delete({
     *   where: {
     *     // ... filter to delete one Prescription
     *   }
     * })
     * 
     */
    delete<T extends PrescriptionDeleteArgs>(args: SelectSubset<T, PrescriptionDeleteArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Prescription.
     * @param {PrescriptionUpdateArgs} args - Arguments to update one Prescription.
     * @example
     * // Update one Prescription
     * const prescription = await prisma.prescription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PrescriptionUpdateArgs>(args: SelectSubset<T, PrescriptionUpdateArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Prescriptions.
     * @param {PrescriptionDeleteManyArgs} args - Arguments to filter Prescriptions to delete.
     * @example
     * // Delete a few Prescriptions
     * const { count } = await prisma.prescription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PrescriptionDeleteManyArgs>(args?: SelectSubset<T, PrescriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prescriptions
     * const prescription = await prisma.prescription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PrescriptionUpdateManyArgs>(args: SelectSubset<T, PrescriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prescriptions and returns the data updated in the database.
     * @param {PrescriptionUpdateManyAndReturnArgs} args - Arguments to update many Prescriptions.
     * @example
     * // Update many Prescriptions
     * const prescription = await prisma.prescription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Prescriptions and only return the `id`
     * const prescriptionWithIdOnly = await prisma.prescription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PrescriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, PrescriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Prescription.
     * @param {PrescriptionUpsertArgs} args - Arguments to update or create a Prescription.
     * @example
     * // Update or create a Prescription
     * const prescription = await prisma.prescription.upsert({
     *   create: {
     *     // ... data to create a Prescription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prescription we want to update
     *   }
     * })
     */
    upsert<T extends PrescriptionUpsertArgs>(args: SelectSubset<T, PrescriptionUpsertArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Prescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionCountArgs} args - Arguments to filter Prescriptions to count.
     * @example
     * // Count the number of Prescriptions
     * const count = await prisma.prescription.count({
     *   where: {
     *     // ... the filter for the Prescriptions we want to count
     *   }
     * })
    **/
    count<T extends PrescriptionCountArgs>(
      args?: Subset<T, PrescriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrescriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Prescription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrescriptionAggregateArgs>(args: Subset<T, PrescriptionAggregateArgs>): Prisma.PrismaPromise<GetPrescriptionAggregateType<T>>

    /**
     * Group by Prescription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrescriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrescriptionGroupByArgs['orderBy'] }
        : { orderBy?: PrescriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrescriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrescriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Prescription model
   */
  readonly fields: PrescriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Prescription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PrescriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    issues<T extends Prescription$issuesArgs<ExtArgs> = {}>(args?: Subset<T, Prescription$issuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    OffRecordMeds<T extends Prescription$OffRecordMedsArgs<ExtArgs> = {}>(args?: Subset<T, Prescription$OffRecordMedsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OffRecordMedsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    PrescriptionVitals<T extends Prescription$PrescriptionVitalsArgs<ExtArgs> = {}>(args?: Subset<T, Prescription$PrescriptionVitalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionVitalsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Charges<T extends Prescription$ChargesArgs<ExtArgs> = {}>(args?: Subset<T, Prescription$ChargesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionChargesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Prescription model
   */ 
  interface PrescriptionFieldRefs {
    readonly id: FieldRef<"Prescription", 'Int'>
    readonly time: FieldRef<"Prescription", 'DateTime'>
    readonly presentingSymptoms: FieldRef<"Prescription", 'String'>
    readonly status: FieldRef<"Prescription", 'PrescriptionStatus'>
    readonly details: FieldRef<"Prescription", 'String'>
    readonly patientId: FieldRef<"Prescription", 'Int'>
    readonly finalPrice: FieldRef<"Prescription", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Prescription findUnique
   */
  export type PrescriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescription to fetch.
     */
    where: PrescriptionWhereUniqueInput
  }

  /**
   * Prescription findUniqueOrThrow
   */
  export type PrescriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescription to fetch.
     */
    where: PrescriptionWhereUniqueInput
  }

  /**
   * Prescription findFirst
   */
  export type PrescriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescription to fetch.
     */
    where?: PrescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prescriptions to fetch.
     */
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prescriptions.
     */
    cursor?: PrescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prescriptions.
     */
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * Prescription findFirstOrThrow
   */
  export type PrescriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescription to fetch.
     */
    where?: PrescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prescriptions to fetch.
     */
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prescriptions.
     */
    cursor?: PrescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prescriptions.
     */
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * Prescription findMany
   */
  export type PrescriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescriptions to fetch.
     */
    where?: PrescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prescriptions to fetch.
     */
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Prescriptions.
     */
    cursor?: PrescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prescriptions.
     */
    skip?: number
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * Prescription create
   */
  export type PrescriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Prescription.
     */
    data: XOR<PrescriptionCreateInput, PrescriptionUncheckedCreateInput>
  }

  /**
   * Prescription createMany
   */
  export type PrescriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Prescriptions.
     */
    data: PrescriptionCreateManyInput | PrescriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Prescription createManyAndReturn
   */
  export type PrescriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * The data used to create many Prescriptions.
     */
    data: PrescriptionCreateManyInput | PrescriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Prescription update
   */
  export type PrescriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Prescription.
     */
    data: XOR<PrescriptionUpdateInput, PrescriptionUncheckedUpdateInput>
    /**
     * Choose, which Prescription to update.
     */
    where: PrescriptionWhereUniqueInput
  }

  /**
   * Prescription updateMany
   */
  export type PrescriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Prescriptions.
     */
    data: XOR<PrescriptionUpdateManyMutationInput, PrescriptionUncheckedUpdateManyInput>
    /**
     * Filter which Prescriptions to update
     */
    where?: PrescriptionWhereInput
    /**
     * Limit how many Prescriptions to update.
     */
    limit?: number
  }

  /**
   * Prescription updateManyAndReturn
   */
  export type PrescriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * The data used to update Prescriptions.
     */
    data: XOR<PrescriptionUpdateManyMutationInput, PrescriptionUncheckedUpdateManyInput>
    /**
     * Filter which Prescriptions to update
     */
    where?: PrescriptionWhereInput
    /**
     * Limit how many Prescriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Prescription upsert
   */
  export type PrescriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Prescription to update in case it exists.
     */
    where: PrescriptionWhereUniqueInput
    /**
     * In case the Prescription found by the `where` argument doesn't exist, create a new Prescription with this data.
     */
    create: XOR<PrescriptionCreateInput, PrescriptionUncheckedCreateInput>
    /**
     * In case the Prescription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrescriptionUpdateInput, PrescriptionUncheckedUpdateInput>
  }

  /**
   * Prescription delete
   */
  export type PrescriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter which Prescription to delete.
     */
    where: PrescriptionWhereUniqueInput
  }

  /**
   * Prescription deleteMany
   */
  export type PrescriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prescriptions to delete
     */
    where?: PrescriptionWhereInput
    /**
     * Limit how many Prescriptions to delete.
     */
    limit?: number
  }

  /**
   * Prescription.issues
   */
  export type Prescription$issuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issue
     */
    select?: IssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Issue
     */
    omit?: IssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueInclude<ExtArgs> | null
    where?: IssueWhereInput
    orderBy?: IssueOrderByWithRelationInput | IssueOrderByWithRelationInput[]
    cursor?: IssueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IssueScalarFieldEnum | IssueScalarFieldEnum[]
  }

  /**
   * Prescription.OffRecordMeds
   */
  export type Prescription$OffRecordMedsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OffRecordMeds
     */
    select?: OffRecordMedsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OffRecordMeds
     */
    omit?: OffRecordMedsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OffRecordMedsInclude<ExtArgs> | null
    where?: OffRecordMedsWhereInput
    orderBy?: OffRecordMedsOrderByWithRelationInput | OffRecordMedsOrderByWithRelationInput[]
    cursor?: OffRecordMedsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OffRecordMedsScalarFieldEnum | OffRecordMedsScalarFieldEnum[]
  }

  /**
   * Prescription.PrescriptionVitals
   */
  export type Prescription$PrescriptionVitalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionVitals
     */
    select?: PrescriptionVitalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionVitals
     */
    omit?: PrescriptionVitalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionVitalsInclude<ExtArgs> | null
    where?: PrescriptionVitalsWhereInput
    orderBy?: PrescriptionVitalsOrderByWithRelationInput | PrescriptionVitalsOrderByWithRelationInput[]
    cursor?: PrescriptionVitalsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrescriptionVitalsScalarFieldEnum | PrescriptionVitalsScalarFieldEnum[]
  }

  /**
   * Prescription.Charges
   */
  export type Prescription$ChargesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionCharges
     */
    select?: PrescriptionChargesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionCharges
     */
    omit?: PrescriptionChargesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionChargesInclude<ExtArgs> | null
    where?: PrescriptionChargesWhereInput
    orderBy?: PrescriptionChargesOrderByWithRelationInput | PrescriptionChargesOrderByWithRelationInput[]
    cursor?: PrescriptionChargesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrescriptionChargesScalarFieldEnum | PrescriptionChargesScalarFieldEnum[]
  }

  /**
   * Prescription without action
   */
  export type PrescriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
  }


  /**
   * Model PrescriptionCharges
   */

  export type AggregatePrescriptionCharges = {
    _count: PrescriptionChargesCountAggregateOutputType | null
    _avg: PrescriptionChargesAvgAggregateOutputType | null
    _sum: PrescriptionChargesSumAggregateOutputType | null
    _min: PrescriptionChargesMinAggregateOutputType | null
    _max: PrescriptionChargesMaxAggregateOutputType | null
  }

  export type PrescriptionChargesAvgAggregateOutputType = {
    id: number | null
    prescriptionId: number | null
    value: number | null
  }

  export type PrescriptionChargesSumAggregateOutputType = {
    id: number | null
    prescriptionId: number | null
    value: number | null
  }

  export type PrescriptionChargesMinAggregateOutputType = {
    id: number | null
    prescriptionId: number | null
    name: string | null
    type: $Enums.ChargeType | null
    value: number | null
    description: string | null
  }

  export type PrescriptionChargesMaxAggregateOutputType = {
    id: number | null
    prescriptionId: number | null
    name: string | null
    type: $Enums.ChargeType | null
    value: number | null
    description: string | null
  }

  export type PrescriptionChargesCountAggregateOutputType = {
    id: number
    prescriptionId: number
    name: number
    type: number
    value: number
    description: number
    _all: number
  }


  export type PrescriptionChargesAvgAggregateInputType = {
    id?: true
    prescriptionId?: true
    value?: true
  }

  export type PrescriptionChargesSumAggregateInputType = {
    id?: true
    prescriptionId?: true
    value?: true
  }

  export type PrescriptionChargesMinAggregateInputType = {
    id?: true
    prescriptionId?: true
    name?: true
    type?: true
    value?: true
    description?: true
  }

  export type PrescriptionChargesMaxAggregateInputType = {
    id?: true
    prescriptionId?: true
    name?: true
    type?: true
    value?: true
    description?: true
  }

  export type PrescriptionChargesCountAggregateInputType = {
    id?: true
    prescriptionId?: true
    name?: true
    type?: true
    value?: true
    description?: true
    _all?: true
  }

  export type PrescriptionChargesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrescriptionCharges to aggregate.
     */
    where?: PrescriptionChargesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrescriptionCharges to fetch.
     */
    orderBy?: PrescriptionChargesOrderByWithRelationInput | PrescriptionChargesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrescriptionChargesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrescriptionCharges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrescriptionCharges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PrescriptionCharges
    **/
    _count?: true | PrescriptionChargesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PrescriptionChargesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PrescriptionChargesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrescriptionChargesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrescriptionChargesMaxAggregateInputType
  }

  export type GetPrescriptionChargesAggregateType<T extends PrescriptionChargesAggregateArgs> = {
        [P in keyof T & keyof AggregatePrescriptionCharges]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrescriptionCharges[P]>
      : GetScalarType<T[P], AggregatePrescriptionCharges[P]>
  }




  export type PrescriptionChargesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionChargesWhereInput
    orderBy?: PrescriptionChargesOrderByWithAggregationInput | PrescriptionChargesOrderByWithAggregationInput[]
    by: PrescriptionChargesScalarFieldEnum[] | PrescriptionChargesScalarFieldEnum
    having?: PrescriptionChargesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrescriptionChargesCountAggregateInputType | true
    _avg?: PrescriptionChargesAvgAggregateInputType
    _sum?: PrescriptionChargesSumAggregateInputType
    _min?: PrescriptionChargesMinAggregateInputType
    _max?: PrescriptionChargesMaxAggregateInputType
  }

  export type PrescriptionChargesGroupByOutputType = {
    id: number
    prescriptionId: number
    name: string
    type: $Enums.ChargeType
    value: number
    description: string | null
    _count: PrescriptionChargesCountAggregateOutputType | null
    _avg: PrescriptionChargesAvgAggregateOutputType | null
    _sum: PrescriptionChargesSumAggregateOutputType | null
    _min: PrescriptionChargesMinAggregateOutputType | null
    _max: PrescriptionChargesMaxAggregateOutputType | null
  }

  type GetPrescriptionChargesGroupByPayload<T extends PrescriptionChargesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrescriptionChargesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrescriptionChargesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrescriptionChargesGroupByOutputType[P]>
            : GetScalarType<T[P], PrescriptionChargesGroupByOutputType[P]>
        }
      >
    >


  export type PrescriptionChargesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prescriptionId?: boolean
    name?: boolean
    type?: boolean
    value?: boolean
    description?: boolean
    Prescription?: boolean | PrescriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prescriptionCharges"]>

  export type PrescriptionChargesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prescriptionId?: boolean
    name?: boolean
    type?: boolean
    value?: boolean
    description?: boolean
    Prescription?: boolean | PrescriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prescriptionCharges"]>

  export type PrescriptionChargesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prescriptionId?: boolean
    name?: boolean
    type?: boolean
    value?: boolean
    description?: boolean
    Prescription?: boolean | PrescriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prescriptionCharges"]>

  export type PrescriptionChargesSelectScalar = {
    id?: boolean
    prescriptionId?: boolean
    name?: boolean
    type?: boolean
    value?: boolean
    description?: boolean
  }

  export type PrescriptionChargesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "prescriptionId" | "name" | "type" | "value" | "description", ExtArgs["result"]["prescriptionCharges"]>
  export type PrescriptionChargesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Prescription?: boolean | PrescriptionDefaultArgs<ExtArgs>
  }
  export type PrescriptionChargesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Prescription?: boolean | PrescriptionDefaultArgs<ExtArgs>
  }
  export type PrescriptionChargesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Prescription?: boolean | PrescriptionDefaultArgs<ExtArgs>
  }

  export type $PrescriptionChargesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PrescriptionCharges"
    objects: {
      Prescription: Prisma.$PrescriptionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      prescriptionId: number
      name: string
      type: $Enums.ChargeType
      value: number
      description: string | null
    }, ExtArgs["result"]["prescriptionCharges"]>
    composites: {}
  }

  type PrescriptionChargesGetPayload<S extends boolean | null | undefined | PrescriptionChargesDefaultArgs> = $Result.GetResult<Prisma.$PrescriptionChargesPayload, S>

  type PrescriptionChargesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PrescriptionChargesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PrescriptionChargesCountAggregateInputType | true
    }

  export interface PrescriptionChargesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PrescriptionCharges'], meta: { name: 'PrescriptionCharges' } }
    /**
     * Find zero or one PrescriptionCharges that matches the filter.
     * @param {PrescriptionChargesFindUniqueArgs} args - Arguments to find a PrescriptionCharges
     * @example
     * // Get one PrescriptionCharges
     * const prescriptionCharges = await prisma.prescriptionCharges.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PrescriptionChargesFindUniqueArgs>(args: SelectSubset<T, PrescriptionChargesFindUniqueArgs<ExtArgs>>): Prisma__PrescriptionChargesClient<$Result.GetResult<Prisma.$PrescriptionChargesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PrescriptionCharges that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PrescriptionChargesFindUniqueOrThrowArgs} args - Arguments to find a PrescriptionCharges
     * @example
     * // Get one PrescriptionCharges
     * const prescriptionCharges = await prisma.prescriptionCharges.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PrescriptionChargesFindUniqueOrThrowArgs>(args: SelectSubset<T, PrescriptionChargesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PrescriptionChargesClient<$Result.GetResult<Prisma.$PrescriptionChargesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PrescriptionCharges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionChargesFindFirstArgs} args - Arguments to find a PrescriptionCharges
     * @example
     * // Get one PrescriptionCharges
     * const prescriptionCharges = await prisma.prescriptionCharges.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PrescriptionChargesFindFirstArgs>(args?: SelectSubset<T, PrescriptionChargesFindFirstArgs<ExtArgs>>): Prisma__PrescriptionChargesClient<$Result.GetResult<Prisma.$PrescriptionChargesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PrescriptionCharges that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionChargesFindFirstOrThrowArgs} args - Arguments to find a PrescriptionCharges
     * @example
     * // Get one PrescriptionCharges
     * const prescriptionCharges = await prisma.prescriptionCharges.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PrescriptionChargesFindFirstOrThrowArgs>(args?: SelectSubset<T, PrescriptionChargesFindFirstOrThrowArgs<ExtArgs>>): Prisma__PrescriptionChargesClient<$Result.GetResult<Prisma.$PrescriptionChargesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PrescriptionCharges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionChargesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PrescriptionCharges
     * const prescriptionCharges = await prisma.prescriptionCharges.findMany()
     * 
     * // Get first 10 PrescriptionCharges
     * const prescriptionCharges = await prisma.prescriptionCharges.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const prescriptionChargesWithIdOnly = await prisma.prescriptionCharges.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PrescriptionChargesFindManyArgs>(args?: SelectSubset<T, PrescriptionChargesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionChargesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PrescriptionCharges.
     * @param {PrescriptionChargesCreateArgs} args - Arguments to create a PrescriptionCharges.
     * @example
     * // Create one PrescriptionCharges
     * const PrescriptionCharges = await prisma.prescriptionCharges.create({
     *   data: {
     *     // ... data to create a PrescriptionCharges
     *   }
     * })
     * 
     */
    create<T extends PrescriptionChargesCreateArgs>(args: SelectSubset<T, PrescriptionChargesCreateArgs<ExtArgs>>): Prisma__PrescriptionChargesClient<$Result.GetResult<Prisma.$PrescriptionChargesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PrescriptionCharges.
     * @param {PrescriptionChargesCreateManyArgs} args - Arguments to create many PrescriptionCharges.
     * @example
     * // Create many PrescriptionCharges
     * const prescriptionCharges = await prisma.prescriptionCharges.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PrescriptionChargesCreateManyArgs>(args?: SelectSubset<T, PrescriptionChargesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PrescriptionCharges and returns the data saved in the database.
     * @param {PrescriptionChargesCreateManyAndReturnArgs} args - Arguments to create many PrescriptionCharges.
     * @example
     * // Create many PrescriptionCharges
     * const prescriptionCharges = await prisma.prescriptionCharges.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PrescriptionCharges and only return the `id`
     * const prescriptionChargesWithIdOnly = await prisma.prescriptionCharges.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PrescriptionChargesCreateManyAndReturnArgs>(args?: SelectSubset<T, PrescriptionChargesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionChargesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PrescriptionCharges.
     * @param {PrescriptionChargesDeleteArgs} args - Arguments to delete one PrescriptionCharges.
     * @example
     * // Delete one PrescriptionCharges
     * const PrescriptionCharges = await prisma.prescriptionCharges.delete({
     *   where: {
     *     // ... filter to delete one PrescriptionCharges
     *   }
     * })
     * 
     */
    delete<T extends PrescriptionChargesDeleteArgs>(args: SelectSubset<T, PrescriptionChargesDeleteArgs<ExtArgs>>): Prisma__PrescriptionChargesClient<$Result.GetResult<Prisma.$PrescriptionChargesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PrescriptionCharges.
     * @param {PrescriptionChargesUpdateArgs} args - Arguments to update one PrescriptionCharges.
     * @example
     * // Update one PrescriptionCharges
     * const prescriptionCharges = await prisma.prescriptionCharges.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PrescriptionChargesUpdateArgs>(args: SelectSubset<T, PrescriptionChargesUpdateArgs<ExtArgs>>): Prisma__PrescriptionChargesClient<$Result.GetResult<Prisma.$PrescriptionChargesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PrescriptionCharges.
     * @param {PrescriptionChargesDeleteManyArgs} args - Arguments to filter PrescriptionCharges to delete.
     * @example
     * // Delete a few PrescriptionCharges
     * const { count } = await prisma.prescriptionCharges.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PrescriptionChargesDeleteManyArgs>(args?: SelectSubset<T, PrescriptionChargesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PrescriptionCharges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionChargesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PrescriptionCharges
     * const prescriptionCharges = await prisma.prescriptionCharges.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PrescriptionChargesUpdateManyArgs>(args: SelectSubset<T, PrescriptionChargesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PrescriptionCharges and returns the data updated in the database.
     * @param {PrescriptionChargesUpdateManyAndReturnArgs} args - Arguments to update many PrescriptionCharges.
     * @example
     * // Update many PrescriptionCharges
     * const prescriptionCharges = await prisma.prescriptionCharges.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PrescriptionCharges and only return the `id`
     * const prescriptionChargesWithIdOnly = await prisma.prescriptionCharges.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PrescriptionChargesUpdateManyAndReturnArgs>(args: SelectSubset<T, PrescriptionChargesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionChargesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PrescriptionCharges.
     * @param {PrescriptionChargesUpsertArgs} args - Arguments to update or create a PrescriptionCharges.
     * @example
     * // Update or create a PrescriptionCharges
     * const prescriptionCharges = await prisma.prescriptionCharges.upsert({
     *   create: {
     *     // ... data to create a PrescriptionCharges
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PrescriptionCharges we want to update
     *   }
     * })
     */
    upsert<T extends PrescriptionChargesUpsertArgs>(args: SelectSubset<T, PrescriptionChargesUpsertArgs<ExtArgs>>): Prisma__PrescriptionChargesClient<$Result.GetResult<Prisma.$PrescriptionChargesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PrescriptionCharges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionChargesCountArgs} args - Arguments to filter PrescriptionCharges to count.
     * @example
     * // Count the number of PrescriptionCharges
     * const count = await prisma.prescriptionCharges.count({
     *   where: {
     *     // ... the filter for the PrescriptionCharges we want to count
     *   }
     * })
    **/
    count<T extends PrescriptionChargesCountArgs>(
      args?: Subset<T, PrescriptionChargesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrescriptionChargesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PrescriptionCharges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionChargesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrescriptionChargesAggregateArgs>(args: Subset<T, PrescriptionChargesAggregateArgs>): Prisma.PrismaPromise<GetPrescriptionChargesAggregateType<T>>

    /**
     * Group by PrescriptionCharges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionChargesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrescriptionChargesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrescriptionChargesGroupByArgs['orderBy'] }
        : { orderBy?: PrescriptionChargesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrescriptionChargesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrescriptionChargesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PrescriptionCharges model
   */
  readonly fields: PrescriptionChargesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PrescriptionCharges.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PrescriptionChargesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Prescription<T extends PrescriptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PrescriptionDefaultArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PrescriptionCharges model
   */ 
  interface PrescriptionChargesFieldRefs {
    readonly id: FieldRef<"PrescriptionCharges", 'Int'>
    readonly prescriptionId: FieldRef<"PrescriptionCharges", 'Int'>
    readonly name: FieldRef<"PrescriptionCharges", 'String'>
    readonly type: FieldRef<"PrescriptionCharges", 'ChargeType'>
    readonly value: FieldRef<"PrescriptionCharges", 'Float'>
    readonly description: FieldRef<"PrescriptionCharges", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PrescriptionCharges findUnique
   */
  export type PrescriptionChargesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionCharges
     */
    select?: PrescriptionChargesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionCharges
     */
    omit?: PrescriptionChargesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionChargesInclude<ExtArgs> | null
    /**
     * Filter, which PrescriptionCharges to fetch.
     */
    where: PrescriptionChargesWhereUniqueInput
  }

  /**
   * PrescriptionCharges findUniqueOrThrow
   */
  export type PrescriptionChargesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionCharges
     */
    select?: PrescriptionChargesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionCharges
     */
    omit?: PrescriptionChargesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionChargesInclude<ExtArgs> | null
    /**
     * Filter, which PrescriptionCharges to fetch.
     */
    where: PrescriptionChargesWhereUniqueInput
  }

  /**
   * PrescriptionCharges findFirst
   */
  export type PrescriptionChargesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionCharges
     */
    select?: PrescriptionChargesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionCharges
     */
    omit?: PrescriptionChargesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionChargesInclude<ExtArgs> | null
    /**
     * Filter, which PrescriptionCharges to fetch.
     */
    where?: PrescriptionChargesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrescriptionCharges to fetch.
     */
    orderBy?: PrescriptionChargesOrderByWithRelationInput | PrescriptionChargesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrescriptionCharges.
     */
    cursor?: PrescriptionChargesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrescriptionCharges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrescriptionCharges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrescriptionCharges.
     */
    distinct?: PrescriptionChargesScalarFieldEnum | PrescriptionChargesScalarFieldEnum[]
  }

  /**
   * PrescriptionCharges findFirstOrThrow
   */
  export type PrescriptionChargesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionCharges
     */
    select?: PrescriptionChargesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionCharges
     */
    omit?: PrescriptionChargesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionChargesInclude<ExtArgs> | null
    /**
     * Filter, which PrescriptionCharges to fetch.
     */
    where?: PrescriptionChargesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrescriptionCharges to fetch.
     */
    orderBy?: PrescriptionChargesOrderByWithRelationInput | PrescriptionChargesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrescriptionCharges.
     */
    cursor?: PrescriptionChargesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrescriptionCharges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrescriptionCharges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrescriptionCharges.
     */
    distinct?: PrescriptionChargesScalarFieldEnum | PrescriptionChargesScalarFieldEnum[]
  }

  /**
   * PrescriptionCharges findMany
   */
  export type PrescriptionChargesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionCharges
     */
    select?: PrescriptionChargesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionCharges
     */
    omit?: PrescriptionChargesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionChargesInclude<ExtArgs> | null
    /**
     * Filter, which PrescriptionCharges to fetch.
     */
    where?: PrescriptionChargesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrescriptionCharges to fetch.
     */
    orderBy?: PrescriptionChargesOrderByWithRelationInput | PrescriptionChargesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PrescriptionCharges.
     */
    cursor?: PrescriptionChargesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrescriptionCharges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrescriptionCharges.
     */
    skip?: number
    distinct?: PrescriptionChargesScalarFieldEnum | PrescriptionChargesScalarFieldEnum[]
  }

  /**
   * PrescriptionCharges create
   */
  export type PrescriptionChargesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionCharges
     */
    select?: PrescriptionChargesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionCharges
     */
    omit?: PrescriptionChargesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionChargesInclude<ExtArgs> | null
    /**
     * The data needed to create a PrescriptionCharges.
     */
    data: XOR<PrescriptionChargesCreateInput, PrescriptionChargesUncheckedCreateInput>
  }

  /**
   * PrescriptionCharges createMany
   */
  export type PrescriptionChargesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PrescriptionCharges.
     */
    data: PrescriptionChargesCreateManyInput | PrescriptionChargesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PrescriptionCharges createManyAndReturn
   */
  export type PrescriptionChargesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionCharges
     */
    select?: PrescriptionChargesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionCharges
     */
    omit?: PrescriptionChargesOmit<ExtArgs> | null
    /**
     * The data used to create many PrescriptionCharges.
     */
    data: PrescriptionChargesCreateManyInput | PrescriptionChargesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionChargesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PrescriptionCharges update
   */
  export type PrescriptionChargesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionCharges
     */
    select?: PrescriptionChargesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionCharges
     */
    omit?: PrescriptionChargesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionChargesInclude<ExtArgs> | null
    /**
     * The data needed to update a PrescriptionCharges.
     */
    data: XOR<PrescriptionChargesUpdateInput, PrescriptionChargesUncheckedUpdateInput>
    /**
     * Choose, which PrescriptionCharges to update.
     */
    where: PrescriptionChargesWhereUniqueInput
  }

  /**
   * PrescriptionCharges updateMany
   */
  export type PrescriptionChargesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PrescriptionCharges.
     */
    data: XOR<PrescriptionChargesUpdateManyMutationInput, PrescriptionChargesUncheckedUpdateManyInput>
    /**
     * Filter which PrescriptionCharges to update
     */
    where?: PrescriptionChargesWhereInput
    /**
     * Limit how many PrescriptionCharges to update.
     */
    limit?: number
  }

  /**
   * PrescriptionCharges updateManyAndReturn
   */
  export type PrescriptionChargesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionCharges
     */
    select?: PrescriptionChargesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionCharges
     */
    omit?: PrescriptionChargesOmit<ExtArgs> | null
    /**
     * The data used to update PrescriptionCharges.
     */
    data: XOR<PrescriptionChargesUpdateManyMutationInput, PrescriptionChargesUncheckedUpdateManyInput>
    /**
     * Filter which PrescriptionCharges to update
     */
    where?: PrescriptionChargesWhereInput
    /**
     * Limit how many PrescriptionCharges to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionChargesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PrescriptionCharges upsert
   */
  export type PrescriptionChargesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionCharges
     */
    select?: PrescriptionChargesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionCharges
     */
    omit?: PrescriptionChargesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionChargesInclude<ExtArgs> | null
    /**
     * The filter to search for the PrescriptionCharges to update in case it exists.
     */
    where: PrescriptionChargesWhereUniqueInput
    /**
     * In case the PrescriptionCharges found by the `where` argument doesn't exist, create a new PrescriptionCharges with this data.
     */
    create: XOR<PrescriptionChargesCreateInput, PrescriptionChargesUncheckedCreateInput>
    /**
     * In case the PrescriptionCharges was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrescriptionChargesUpdateInput, PrescriptionChargesUncheckedUpdateInput>
  }

  /**
   * PrescriptionCharges delete
   */
  export type PrescriptionChargesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionCharges
     */
    select?: PrescriptionChargesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionCharges
     */
    omit?: PrescriptionChargesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionChargesInclude<ExtArgs> | null
    /**
     * Filter which PrescriptionCharges to delete.
     */
    where: PrescriptionChargesWhereUniqueInput
  }

  /**
   * PrescriptionCharges deleteMany
   */
  export type PrescriptionChargesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrescriptionCharges to delete
     */
    where?: PrescriptionChargesWhereInput
    /**
     * Limit how many PrescriptionCharges to delete.
     */
    limit?: number
  }

  /**
   * PrescriptionCharges without action
   */
  export type PrescriptionChargesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionCharges
     */
    select?: PrescriptionChargesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionCharges
     */
    omit?: PrescriptionChargesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionChargesInclude<ExtArgs> | null
  }


  /**
   * Model Vitals
   */

  export type AggregateVitals = {
    _count: VitalsCountAggregateOutputType | null
    _avg: VitalsAvgAggregateOutputType | null
    _sum: VitalsSumAggregateOutputType | null
    _min: VitalsMinAggregateOutputType | null
    _max: VitalsMaxAggregateOutputType | null
  }

  export type VitalsAvgAggregateOutputType = {
    id: number | null
  }

  export type VitalsSumAggregateOutputType = {
    id: number | null
  }

  export type VitalsMinAggregateOutputType = {
    id: number | null
    name: string | null
    icon: string | null
    color: string | null
    placeholder: string | null
    forGender: $Enums.Gender | null
    type: $Enums.VitalType | null
  }

  export type VitalsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    icon: string | null
    color: string | null
    placeholder: string | null
    forGender: $Enums.Gender | null
    type: $Enums.VitalType | null
  }

  export type VitalsCountAggregateOutputType = {
    id: number
    name: number
    icon: number
    color: number
    placeholder: number
    forGender: number
    type: number
    _all: number
  }


  export type VitalsAvgAggregateInputType = {
    id?: true
  }

  export type VitalsSumAggregateInputType = {
    id?: true
  }

  export type VitalsMinAggregateInputType = {
    id?: true
    name?: true
    icon?: true
    color?: true
    placeholder?: true
    forGender?: true
    type?: true
  }

  export type VitalsMaxAggregateInputType = {
    id?: true
    name?: true
    icon?: true
    color?: true
    placeholder?: true
    forGender?: true
    type?: true
  }

  export type VitalsCountAggregateInputType = {
    id?: true
    name?: true
    icon?: true
    color?: true
    placeholder?: true
    forGender?: true
    type?: true
    _all?: true
  }

  export type VitalsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vitals to aggregate.
     */
    where?: VitalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vitals to fetch.
     */
    orderBy?: VitalsOrderByWithRelationInput | VitalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VitalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vitals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vitals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vitals
    **/
    _count?: true | VitalsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VitalsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VitalsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VitalsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VitalsMaxAggregateInputType
  }

  export type GetVitalsAggregateType<T extends VitalsAggregateArgs> = {
        [P in keyof T & keyof AggregateVitals]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVitals[P]>
      : GetScalarType<T[P], AggregateVitals[P]>
  }




  export type VitalsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VitalsWhereInput
    orderBy?: VitalsOrderByWithAggregationInput | VitalsOrderByWithAggregationInput[]
    by: VitalsScalarFieldEnum[] | VitalsScalarFieldEnum
    having?: VitalsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VitalsCountAggregateInputType | true
    _avg?: VitalsAvgAggregateInputType
    _sum?: VitalsSumAggregateInputType
    _min?: VitalsMinAggregateInputType
    _max?: VitalsMaxAggregateInputType
  }

  export type VitalsGroupByOutputType = {
    id: number
    name: string
    icon: string
    color: string
    placeholder: string
    forGender: $Enums.Gender | null
    type: $Enums.VitalType
    _count: VitalsCountAggregateOutputType | null
    _avg: VitalsAvgAggregateOutputType | null
    _sum: VitalsSumAggregateOutputType | null
    _min: VitalsMinAggregateOutputType | null
    _max: VitalsMaxAggregateOutputType | null
  }

  type GetVitalsGroupByPayload<T extends VitalsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VitalsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VitalsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VitalsGroupByOutputType[P]>
            : GetScalarType<T[P], VitalsGroupByOutputType[P]>
        }
      >
    >


  export type VitalsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    icon?: boolean
    color?: boolean
    placeholder?: boolean
    forGender?: boolean
    type?: boolean
    PrescriptionVitals?: boolean | Vitals$PrescriptionVitalsArgs<ExtArgs>
    _count?: boolean | VitalsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vitals"]>

  export type VitalsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    icon?: boolean
    color?: boolean
    placeholder?: boolean
    forGender?: boolean
    type?: boolean
  }, ExtArgs["result"]["vitals"]>

  export type VitalsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    icon?: boolean
    color?: boolean
    placeholder?: boolean
    forGender?: boolean
    type?: boolean
  }, ExtArgs["result"]["vitals"]>

  export type VitalsSelectScalar = {
    id?: boolean
    name?: boolean
    icon?: boolean
    color?: boolean
    placeholder?: boolean
    forGender?: boolean
    type?: boolean
  }

  export type VitalsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "icon" | "color" | "placeholder" | "forGender" | "type", ExtArgs["result"]["vitals"]>
  export type VitalsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PrescriptionVitals?: boolean | Vitals$PrescriptionVitalsArgs<ExtArgs>
    _count?: boolean | VitalsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VitalsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type VitalsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $VitalsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vitals"
    objects: {
      PrescriptionVitals: Prisma.$PrescriptionVitalsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      icon: string
      color: string
      placeholder: string
      forGender: $Enums.Gender | null
      type: $Enums.VitalType
    }, ExtArgs["result"]["vitals"]>
    composites: {}
  }

  type VitalsGetPayload<S extends boolean | null | undefined | VitalsDefaultArgs> = $Result.GetResult<Prisma.$VitalsPayload, S>

  type VitalsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VitalsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VitalsCountAggregateInputType | true
    }

  export interface VitalsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vitals'], meta: { name: 'Vitals' } }
    /**
     * Find zero or one Vitals that matches the filter.
     * @param {VitalsFindUniqueArgs} args - Arguments to find a Vitals
     * @example
     * // Get one Vitals
     * const vitals = await prisma.vitals.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VitalsFindUniqueArgs>(args: SelectSubset<T, VitalsFindUniqueArgs<ExtArgs>>): Prisma__VitalsClient<$Result.GetResult<Prisma.$VitalsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vitals that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VitalsFindUniqueOrThrowArgs} args - Arguments to find a Vitals
     * @example
     * // Get one Vitals
     * const vitals = await prisma.vitals.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VitalsFindUniqueOrThrowArgs>(args: SelectSubset<T, VitalsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VitalsClient<$Result.GetResult<Prisma.$VitalsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vitals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitalsFindFirstArgs} args - Arguments to find a Vitals
     * @example
     * // Get one Vitals
     * const vitals = await prisma.vitals.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VitalsFindFirstArgs>(args?: SelectSubset<T, VitalsFindFirstArgs<ExtArgs>>): Prisma__VitalsClient<$Result.GetResult<Prisma.$VitalsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vitals that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitalsFindFirstOrThrowArgs} args - Arguments to find a Vitals
     * @example
     * // Get one Vitals
     * const vitals = await prisma.vitals.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VitalsFindFirstOrThrowArgs>(args?: SelectSubset<T, VitalsFindFirstOrThrowArgs<ExtArgs>>): Prisma__VitalsClient<$Result.GetResult<Prisma.$VitalsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vitals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitalsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vitals
     * const vitals = await prisma.vitals.findMany()
     * 
     * // Get first 10 Vitals
     * const vitals = await prisma.vitals.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vitalsWithIdOnly = await prisma.vitals.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VitalsFindManyArgs>(args?: SelectSubset<T, VitalsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VitalsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vitals.
     * @param {VitalsCreateArgs} args - Arguments to create a Vitals.
     * @example
     * // Create one Vitals
     * const Vitals = await prisma.vitals.create({
     *   data: {
     *     // ... data to create a Vitals
     *   }
     * })
     * 
     */
    create<T extends VitalsCreateArgs>(args: SelectSubset<T, VitalsCreateArgs<ExtArgs>>): Prisma__VitalsClient<$Result.GetResult<Prisma.$VitalsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vitals.
     * @param {VitalsCreateManyArgs} args - Arguments to create many Vitals.
     * @example
     * // Create many Vitals
     * const vitals = await prisma.vitals.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VitalsCreateManyArgs>(args?: SelectSubset<T, VitalsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Vitals and returns the data saved in the database.
     * @param {VitalsCreateManyAndReturnArgs} args - Arguments to create many Vitals.
     * @example
     * // Create many Vitals
     * const vitals = await prisma.vitals.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Vitals and only return the `id`
     * const vitalsWithIdOnly = await prisma.vitals.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VitalsCreateManyAndReturnArgs>(args?: SelectSubset<T, VitalsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VitalsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Vitals.
     * @param {VitalsDeleteArgs} args - Arguments to delete one Vitals.
     * @example
     * // Delete one Vitals
     * const Vitals = await prisma.vitals.delete({
     *   where: {
     *     // ... filter to delete one Vitals
     *   }
     * })
     * 
     */
    delete<T extends VitalsDeleteArgs>(args: SelectSubset<T, VitalsDeleteArgs<ExtArgs>>): Prisma__VitalsClient<$Result.GetResult<Prisma.$VitalsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vitals.
     * @param {VitalsUpdateArgs} args - Arguments to update one Vitals.
     * @example
     * // Update one Vitals
     * const vitals = await prisma.vitals.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VitalsUpdateArgs>(args: SelectSubset<T, VitalsUpdateArgs<ExtArgs>>): Prisma__VitalsClient<$Result.GetResult<Prisma.$VitalsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vitals.
     * @param {VitalsDeleteManyArgs} args - Arguments to filter Vitals to delete.
     * @example
     * // Delete a few Vitals
     * const { count } = await prisma.vitals.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VitalsDeleteManyArgs>(args?: SelectSubset<T, VitalsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vitals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitalsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vitals
     * const vitals = await prisma.vitals.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VitalsUpdateManyArgs>(args: SelectSubset<T, VitalsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vitals and returns the data updated in the database.
     * @param {VitalsUpdateManyAndReturnArgs} args - Arguments to update many Vitals.
     * @example
     * // Update many Vitals
     * const vitals = await prisma.vitals.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Vitals and only return the `id`
     * const vitalsWithIdOnly = await prisma.vitals.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VitalsUpdateManyAndReturnArgs>(args: SelectSubset<T, VitalsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VitalsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Vitals.
     * @param {VitalsUpsertArgs} args - Arguments to update or create a Vitals.
     * @example
     * // Update or create a Vitals
     * const vitals = await prisma.vitals.upsert({
     *   create: {
     *     // ... data to create a Vitals
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vitals we want to update
     *   }
     * })
     */
    upsert<T extends VitalsUpsertArgs>(args: SelectSubset<T, VitalsUpsertArgs<ExtArgs>>): Prisma__VitalsClient<$Result.GetResult<Prisma.$VitalsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Vitals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitalsCountArgs} args - Arguments to filter Vitals to count.
     * @example
     * // Count the number of Vitals
     * const count = await prisma.vitals.count({
     *   where: {
     *     // ... the filter for the Vitals we want to count
     *   }
     * })
    **/
    count<T extends VitalsCountArgs>(
      args?: Subset<T, VitalsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VitalsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vitals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitalsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VitalsAggregateArgs>(args: Subset<T, VitalsAggregateArgs>): Prisma.PrismaPromise<GetVitalsAggregateType<T>>

    /**
     * Group by Vitals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitalsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VitalsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VitalsGroupByArgs['orderBy'] }
        : { orderBy?: VitalsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VitalsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVitalsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vitals model
   */
  readonly fields: VitalsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vitals.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VitalsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    PrescriptionVitals<T extends Vitals$PrescriptionVitalsArgs<ExtArgs> = {}>(args?: Subset<T, Vitals$PrescriptionVitalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionVitalsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vitals model
   */ 
  interface VitalsFieldRefs {
    readonly id: FieldRef<"Vitals", 'Int'>
    readonly name: FieldRef<"Vitals", 'String'>
    readonly icon: FieldRef<"Vitals", 'String'>
    readonly color: FieldRef<"Vitals", 'String'>
    readonly placeholder: FieldRef<"Vitals", 'String'>
    readonly forGender: FieldRef<"Vitals", 'Gender'>
    readonly type: FieldRef<"Vitals", 'VitalType'>
  }
    

  // Custom InputTypes
  /**
   * Vitals findUnique
   */
  export type VitalsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vitals
     */
    select?: VitalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vitals
     */
    omit?: VitalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalsInclude<ExtArgs> | null
    /**
     * Filter, which Vitals to fetch.
     */
    where: VitalsWhereUniqueInput
  }

  /**
   * Vitals findUniqueOrThrow
   */
  export type VitalsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vitals
     */
    select?: VitalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vitals
     */
    omit?: VitalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalsInclude<ExtArgs> | null
    /**
     * Filter, which Vitals to fetch.
     */
    where: VitalsWhereUniqueInput
  }

  /**
   * Vitals findFirst
   */
  export type VitalsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vitals
     */
    select?: VitalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vitals
     */
    omit?: VitalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalsInclude<ExtArgs> | null
    /**
     * Filter, which Vitals to fetch.
     */
    where?: VitalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vitals to fetch.
     */
    orderBy?: VitalsOrderByWithRelationInput | VitalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vitals.
     */
    cursor?: VitalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vitals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vitals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vitals.
     */
    distinct?: VitalsScalarFieldEnum | VitalsScalarFieldEnum[]
  }

  /**
   * Vitals findFirstOrThrow
   */
  export type VitalsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vitals
     */
    select?: VitalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vitals
     */
    omit?: VitalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalsInclude<ExtArgs> | null
    /**
     * Filter, which Vitals to fetch.
     */
    where?: VitalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vitals to fetch.
     */
    orderBy?: VitalsOrderByWithRelationInput | VitalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vitals.
     */
    cursor?: VitalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vitals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vitals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vitals.
     */
    distinct?: VitalsScalarFieldEnum | VitalsScalarFieldEnum[]
  }

  /**
   * Vitals findMany
   */
  export type VitalsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vitals
     */
    select?: VitalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vitals
     */
    omit?: VitalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalsInclude<ExtArgs> | null
    /**
     * Filter, which Vitals to fetch.
     */
    where?: VitalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vitals to fetch.
     */
    orderBy?: VitalsOrderByWithRelationInput | VitalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vitals.
     */
    cursor?: VitalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vitals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vitals.
     */
    skip?: number
    distinct?: VitalsScalarFieldEnum | VitalsScalarFieldEnum[]
  }

  /**
   * Vitals create
   */
  export type VitalsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vitals
     */
    select?: VitalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vitals
     */
    omit?: VitalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalsInclude<ExtArgs> | null
    /**
     * The data needed to create a Vitals.
     */
    data: XOR<VitalsCreateInput, VitalsUncheckedCreateInput>
  }

  /**
   * Vitals createMany
   */
  export type VitalsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vitals.
     */
    data: VitalsCreateManyInput | VitalsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vitals createManyAndReturn
   */
  export type VitalsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vitals
     */
    select?: VitalsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vitals
     */
    omit?: VitalsOmit<ExtArgs> | null
    /**
     * The data used to create many Vitals.
     */
    data: VitalsCreateManyInput | VitalsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vitals update
   */
  export type VitalsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vitals
     */
    select?: VitalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vitals
     */
    omit?: VitalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalsInclude<ExtArgs> | null
    /**
     * The data needed to update a Vitals.
     */
    data: XOR<VitalsUpdateInput, VitalsUncheckedUpdateInput>
    /**
     * Choose, which Vitals to update.
     */
    where: VitalsWhereUniqueInput
  }

  /**
   * Vitals updateMany
   */
  export type VitalsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vitals.
     */
    data: XOR<VitalsUpdateManyMutationInput, VitalsUncheckedUpdateManyInput>
    /**
     * Filter which Vitals to update
     */
    where?: VitalsWhereInput
    /**
     * Limit how many Vitals to update.
     */
    limit?: number
  }

  /**
   * Vitals updateManyAndReturn
   */
  export type VitalsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vitals
     */
    select?: VitalsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vitals
     */
    omit?: VitalsOmit<ExtArgs> | null
    /**
     * The data used to update Vitals.
     */
    data: XOR<VitalsUpdateManyMutationInput, VitalsUncheckedUpdateManyInput>
    /**
     * Filter which Vitals to update
     */
    where?: VitalsWhereInput
    /**
     * Limit how many Vitals to update.
     */
    limit?: number
  }

  /**
   * Vitals upsert
   */
  export type VitalsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vitals
     */
    select?: VitalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vitals
     */
    omit?: VitalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalsInclude<ExtArgs> | null
    /**
     * The filter to search for the Vitals to update in case it exists.
     */
    where: VitalsWhereUniqueInput
    /**
     * In case the Vitals found by the `where` argument doesn't exist, create a new Vitals with this data.
     */
    create: XOR<VitalsCreateInput, VitalsUncheckedCreateInput>
    /**
     * In case the Vitals was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VitalsUpdateInput, VitalsUncheckedUpdateInput>
  }

  /**
   * Vitals delete
   */
  export type VitalsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vitals
     */
    select?: VitalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vitals
     */
    omit?: VitalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalsInclude<ExtArgs> | null
    /**
     * Filter which Vitals to delete.
     */
    where: VitalsWhereUniqueInput
  }

  /**
   * Vitals deleteMany
   */
  export type VitalsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vitals to delete
     */
    where?: VitalsWhereInput
    /**
     * Limit how many Vitals to delete.
     */
    limit?: number
  }

  /**
   * Vitals.PrescriptionVitals
   */
  export type Vitals$PrescriptionVitalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionVitals
     */
    select?: PrescriptionVitalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionVitals
     */
    omit?: PrescriptionVitalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionVitalsInclude<ExtArgs> | null
    where?: PrescriptionVitalsWhereInput
    orderBy?: PrescriptionVitalsOrderByWithRelationInput | PrescriptionVitalsOrderByWithRelationInput[]
    cursor?: PrescriptionVitalsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrescriptionVitalsScalarFieldEnum | PrescriptionVitalsScalarFieldEnum[]
  }

  /**
   * Vitals without action
   */
  export type VitalsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vitals
     */
    select?: VitalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vitals
     */
    omit?: VitalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalsInclude<ExtArgs> | null
  }


  /**
   * Model PrescriptionVitals
   */

  export type AggregatePrescriptionVitals = {
    _count: PrescriptionVitalsCountAggregateOutputType | null
    _avg: PrescriptionVitalsAvgAggregateOutputType | null
    _sum: PrescriptionVitalsSumAggregateOutputType | null
    _min: PrescriptionVitalsMinAggregateOutputType | null
    _max: PrescriptionVitalsMaxAggregateOutputType | null
  }

  export type PrescriptionVitalsAvgAggregateOutputType = {
    id: number | null
    prescriptionId: number | null
    vitalId: number | null
  }

  export type PrescriptionVitalsSumAggregateOutputType = {
    id: number | null
    prescriptionId: number | null
    vitalId: number | null
  }

  export type PrescriptionVitalsMinAggregateOutputType = {
    id: number | null
    prescriptionId: number | null
    vitalId: number | null
    value: string | null
  }

  export type PrescriptionVitalsMaxAggregateOutputType = {
    id: number | null
    prescriptionId: number | null
    vitalId: number | null
    value: string | null
  }

  export type PrescriptionVitalsCountAggregateOutputType = {
    id: number
    prescriptionId: number
    vitalId: number
    value: number
    _all: number
  }


  export type PrescriptionVitalsAvgAggregateInputType = {
    id?: true
    prescriptionId?: true
    vitalId?: true
  }

  export type PrescriptionVitalsSumAggregateInputType = {
    id?: true
    prescriptionId?: true
    vitalId?: true
  }

  export type PrescriptionVitalsMinAggregateInputType = {
    id?: true
    prescriptionId?: true
    vitalId?: true
    value?: true
  }

  export type PrescriptionVitalsMaxAggregateInputType = {
    id?: true
    prescriptionId?: true
    vitalId?: true
    value?: true
  }

  export type PrescriptionVitalsCountAggregateInputType = {
    id?: true
    prescriptionId?: true
    vitalId?: true
    value?: true
    _all?: true
  }

  export type PrescriptionVitalsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrescriptionVitals to aggregate.
     */
    where?: PrescriptionVitalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrescriptionVitals to fetch.
     */
    orderBy?: PrescriptionVitalsOrderByWithRelationInput | PrescriptionVitalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrescriptionVitalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrescriptionVitals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrescriptionVitals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PrescriptionVitals
    **/
    _count?: true | PrescriptionVitalsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PrescriptionVitalsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PrescriptionVitalsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrescriptionVitalsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrescriptionVitalsMaxAggregateInputType
  }

  export type GetPrescriptionVitalsAggregateType<T extends PrescriptionVitalsAggregateArgs> = {
        [P in keyof T & keyof AggregatePrescriptionVitals]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrescriptionVitals[P]>
      : GetScalarType<T[P], AggregatePrescriptionVitals[P]>
  }




  export type PrescriptionVitalsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionVitalsWhereInput
    orderBy?: PrescriptionVitalsOrderByWithAggregationInput | PrescriptionVitalsOrderByWithAggregationInput[]
    by: PrescriptionVitalsScalarFieldEnum[] | PrescriptionVitalsScalarFieldEnum
    having?: PrescriptionVitalsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrescriptionVitalsCountAggregateInputType | true
    _avg?: PrescriptionVitalsAvgAggregateInputType
    _sum?: PrescriptionVitalsSumAggregateInputType
    _min?: PrescriptionVitalsMinAggregateInputType
    _max?: PrescriptionVitalsMaxAggregateInputType
  }

  export type PrescriptionVitalsGroupByOutputType = {
    id: number
    prescriptionId: number
    vitalId: number
    value: string
    _count: PrescriptionVitalsCountAggregateOutputType | null
    _avg: PrescriptionVitalsAvgAggregateOutputType | null
    _sum: PrescriptionVitalsSumAggregateOutputType | null
    _min: PrescriptionVitalsMinAggregateOutputType | null
    _max: PrescriptionVitalsMaxAggregateOutputType | null
  }

  type GetPrescriptionVitalsGroupByPayload<T extends PrescriptionVitalsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrescriptionVitalsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrescriptionVitalsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrescriptionVitalsGroupByOutputType[P]>
            : GetScalarType<T[P], PrescriptionVitalsGroupByOutputType[P]>
        }
      >
    >


  export type PrescriptionVitalsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prescriptionId?: boolean
    vitalId?: boolean
    value?: boolean
    prescription?: boolean | PrescriptionDefaultArgs<ExtArgs>
    vital?: boolean | VitalsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prescriptionVitals"]>

  export type PrescriptionVitalsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prescriptionId?: boolean
    vitalId?: boolean
    value?: boolean
    prescription?: boolean | PrescriptionDefaultArgs<ExtArgs>
    vital?: boolean | VitalsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prescriptionVitals"]>

  export type PrescriptionVitalsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prescriptionId?: boolean
    vitalId?: boolean
    value?: boolean
    prescription?: boolean | PrescriptionDefaultArgs<ExtArgs>
    vital?: boolean | VitalsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prescriptionVitals"]>

  export type PrescriptionVitalsSelectScalar = {
    id?: boolean
    prescriptionId?: boolean
    vitalId?: boolean
    value?: boolean
  }

  export type PrescriptionVitalsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "prescriptionId" | "vitalId" | "value", ExtArgs["result"]["prescriptionVitals"]>
  export type PrescriptionVitalsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prescription?: boolean | PrescriptionDefaultArgs<ExtArgs>
    vital?: boolean | VitalsDefaultArgs<ExtArgs>
  }
  export type PrescriptionVitalsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prescription?: boolean | PrescriptionDefaultArgs<ExtArgs>
    vital?: boolean | VitalsDefaultArgs<ExtArgs>
  }
  export type PrescriptionVitalsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prescription?: boolean | PrescriptionDefaultArgs<ExtArgs>
    vital?: boolean | VitalsDefaultArgs<ExtArgs>
  }

  export type $PrescriptionVitalsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PrescriptionVitals"
    objects: {
      prescription: Prisma.$PrescriptionPayload<ExtArgs>
      vital: Prisma.$VitalsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      prescriptionId: number
      vitalId: number
      value: string
    }, ExtArgs["result"]["prescriptionVitals"]>
    composites: {}
  }

  type PrescriptionVitalsGetPayload<S extends boolean | null | undefined | PrescriptionVitalsDefaultArgs> = $Result.GetResult<Prisma.$PrescriptionVitalsPayload, S>

  type PrescriptionVitalsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PrescriptionVitalsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PrescriptionVitalsCountAggregateInputType | true
    }

  export interface PrescriptionVitalsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PrescriptionVitals'], meta: { name: 'PrescriptionVitals' } }
    /**
     * Find zero or one PrescriptionVitals that matches the filter.
     * @param {PrescriptionVitalsFindUniqueArgs} args - Arguments to find a PrescriptionVitals
     * @example
     * // Get one PrescriptionVitals
     * const prescriptionVitals = await prisma.prescriptionVitals.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PrescriptionVitalsFindUniqueArgs>(args: SelectSubset<T, PrescriptionVitalsFindUniqueArgs<ExtArgs>>): Prisma__PrescriptionVitalsClient<$Result.GetResult<Prisma.$PrescriptionVitalsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PrescriptionVitals that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PrescriptionVitalsFindUniqueOrThrowArgs} args - Arguments to find a PrescriptionVitals
     * @example
     * // Get one PrescriptionVitals
     * const prescriptionVitals = await prisma.prescriptionVitals.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PrescriptionVitalsFindUniqueOrThrowArgs>(args: SelectSubset<T, PrescriptionVitalsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PrescriptionVitalsClient<$Result.GetResult<Prisma.$PrescriptionVitalsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PrescriptionVitals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionVitalsFindFirstArgs} args - Arguments to find a PrescriptionVitals
     * @example
     * // Get one PrescriptionVitals
     * const prescriptionVitals = await prisma.prescriptionVitals.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PrescriptionVitalsFindFirstArgs>(args?: SelectSubset<T, PrescriptionVitalsFindFirstArgs<ExtArgs>>): Prisma__PrescriptionVitalsClient<$Result.GetResult<Prisma.$PrescriptionVitalsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PrescriptionVitals that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionVitalsFindFirstOrThrowArgs} args - Arguments to find a PrescriptionVitals
     * @example
     * // Get one PrescriptionVitals
     * const prescriptionVitals = await prisma.prescriptionVitals.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PrescriptionVitalsFindFirstOrThrowArgs>(args?: SelectSubset<T, PrescriptionVitalsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PrescriptionVitalsClient<$Result.GetResult<Prisma.$PrescriptionVitalsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PrescriptionVitals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionVitalsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PrescriptionVitals
     * const prescriptionVitals = await prisma.prescriptionVitals.findMany()
     * 
     * // Get first 10 PrescriptionVitals
     * const prescriptionVitals = await prisma.prescriptionVitals.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const prescriptionVitalsWithIdOnly = await prisma.prescriptionVitals.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PrescriptionVitalsFindManyArgs>(args?: SelectSubset<T, PrescriptionVitalsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionVitalsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PrescriptionVitals.
     * @param {PrescriptionVitalsCreateArgs} args - Arguments to create a PrescriptionVitals.
     * @example
     * // Create one PrescriptionVitals
     * const PrescriptionVitals = await prisma.prescriptionVitals.create({
     *   data: {
     *     // ... data to create a PrescriptionVitals
     *   }
     * })
     * 
     */
    create<T extends PrescriptionVitalsCreateArgs>(args: SelectSubset<T, PrescriptionVitalsCreateArgs<ExtArgs>>): Prisma__PrescriptionVitalsClient<$Result.GetResult<Prisma.$PrescriptionVitalsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PrescriptionVitals.
     * @param {PrescriptionVitalsCreateManyArgs} args - Arguments to create many PrescriptionVitals.
     * @example
     * // Create many PrescriptionVitals
     * const prescriptionVitals = await prisma.prescriptionVitals.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PrescriptionVitalsCreateManyArgs>(args?: SelectSubset<T, PrescriptionVitalsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PrescriptionVitals and returns the data saved in the database.
     * @param {PrescriptionVitalsCreateManyAndReturnArgs} args - Arguments to create many PrescriptionVitals.
     * @example
     * // Create many PrescriptionVitals
     * const prescriptionVitals = await prisma.prescriptionVitals.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PrescriptionVitals and only return the `id`
     * const prescriptionVitalsWithIdOnly = await prisma.prescriptionVitals.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PrescriptionVitalsCreateManyAndReturnArgs>(args?: SelectSubset<T, PrescriptionVitalsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionVitalsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PrescriptionVitals.
     * @param {PrescriptionVitalsDeleteArgs} args - Arguments to delete one PrescriptionVitals.
     * @example
     * // Delete one PrescriptionVitals
     * const PrescriptionVitals = await prisma.prescriptionVitals.delete({
     *   where: {
     *     // ... filter to delete one PrescriptionVitals
     *   }
     * })
     * 
     */
    delete<T extends PrescriptionVitalsDeleteArgs>(args: SelectSubset<T, PrescriptionVitalsDeleteArgs<ExtArgs>>): Prisma__PrescriptionVitalsClient<$Result.GetResult<Prisma.$PrescriptionVitalsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PrescriptionVitals.
     * @param {PrescriptionVitalsUpdateArgs} args - Arguments to update one PrescriptionVitals.
     * @example
     * // Update one PrescriptionVitals
     * const prescriptionVitals = await prisma.prescriptionVitals.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PrescriptionVitalsUpdateArgs>(args: SelectSubset<T, PrescriptionVitalsUpdateArgs<ExtArgs>>): Prisma__PrescriptionVitalsClient<$Result.GetResult<Prisma.$PrescriptionVitalsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PrescriptionVitals.
     * @param {PrescriptionVitalsDeleteManyArgs} args - Arguments to filter PrescriptionVitals to delete.
     * @example
     * // Delete a few PrescriptionVitals
     * const { count } = await prisma.prescriptionVitals.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PrescriptionVitalsDeleteManyArgs>(args?: SelectSubset<T, PrescriptionVitalsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PrescriptionVitals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionVitalsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PrescriptionVitals
     * const prescriptionVitals = await prisma.prescriptionVitals.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PrescriptionVitalsUpdateManyArgs>(args: SelectSubset<T, PrescriptionVitalsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PrescriptionVitals and returns the data updated in the database.
     * @param {PrescriptionVitalsUpdateManyAndReturnArgs} args - Arguments to update many PrescriptionVitals.
     * @example
     * // Update many PrescriptionVitals
     * const prescriptionVitals = await prisma.prescriptionVitals.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PrescriptionVitals and only return the `id`
     * const prescriptionVitalsWithIdOnly = await prisma.prescriptionVitals.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PrescriptionVitalsUpdateManyAndReturnArgs>(args: SelectSubset<T, PrescriptionVitalsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionVitalsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PrescriptionVitals.
     * @param {PrescriptionVitalsUpsertArgs} args - Arguments to update or create a PrescriptionVitals.
     * @example
     * // Update or create a PrescriptionVitals
     * const prescriptionVitals = await prisma.prescriptionVitals.upsert({
     *   create: {
     *     // ... data to create a PrescriptionVitals
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PrescriptionVitals we want to update
     *   }
     * })
     */
    upsert<T extends PrescriptionVitalsUpsertArgs>(args: SelectSubset<T, PrescriptionVitalsUpsertArgs<ExtArgs>>): Prisma__PrescriptionVitalsClient<$Result.GetResult<Prisma.$PrescriptionVitalsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PrescriptionVitals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionVitalsCountArgs} args - Arguments to filter PrescriptionVitals to count.
     * @example
     * // Count the number of PrescriptionVitals
     * const count = await prisma.prescriptionVitals.count({
     *   where: {
     *     // ... the filter for the PrescriptionVitals we want to count
     *   }
     * })
    **/
    count<T extends PrescriptionVitalsCountArgs>(
      args?: Subset<T, PrescriptionVitalsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrescriptionVitalsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PrescriptionVitals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionVitalsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrescriptionVitalsAggregateArgs>(args: Subset<T, PrescriptionVitalsAggregateArgs>): Prisma.PrismaPromise<GetPrescriptionVitalsAggregateType<T>>

    /**
     * Group by PrescriptionVitals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionVitalsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrescriptionVitalsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrescriptionVitalsGroupByArgs['orderBy'] }
        : { orderBy?: PrescriptionVitalsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrescriptionVitalsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrescriptionVitalsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PrescriptionVitals model
   */
  readonly fields: PrescriptionVitalsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PrescriptionVitals.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PrescriptionVitalsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    prescription<T extends PrescriptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PrescriptionDefaultArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    vital<T extends VitalsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VitalsDefaultArgs<ExtArgs>>): Prisma__VitalsClient<$Result.GetResult<Prisma.$VitalsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PrescriptionVitals model
   */ 
  interface PrescriptionVitalsFieldRefs {
    readonly id: FieldRef<"PrescriptionVitals", 'Int'>
    readonly prescriptionId: FieldRef<"PrescriptionVitals", 'Int'>
    readonly vitalId: FieldRef<"PrescriptionVitals", 'Int'>
    readonly value: FieldRef<"PrescriptionVitals", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PrescriptionVitals findUnique
   */
  export type PrescriptionVitalsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionVitals
     */
    select?: PrescriptionVitalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionVitals
     */
    omit?: PrescriptionVitalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionVitalsInclude<ExtArgs> | null
    /**
     * Filter, which PrescriptionVitals to fetch.
     */
    where: PrescriptionVitalsWhereUniqueInput
  }

  /**
   * PrescriptionVitals findUniqueOrThrow
   */
  export type PrescriptionVitalsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionVitals
     */
    select?: PrescriptionVitalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionVitals
     */
    omit?: PrescriptionVitalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionVitalsInclude<ExtArgs> | null
    /**
     * Filter, which PrescriptionVitals to fetch.
     */
    where: PrescriptionVitalsWhereUniqueInput
  }

  /**
   * PrescriptionVitals findFirst
   */
  export type PrescriptionVitalsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionVitals
     */
    select?: PrescriptionVitalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionVitals
     */
    omit?: PrescriptionVitalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionVitalsInclude<ExtArgs> | null
    /**
     * Filter, which PrescriptionVitals to fetch.
     */
    where?: PrescriptionVitalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrescriptionVitals to fetch.
     */
    orderBy?: PrescriptionVitalsOrderByWithRelationInput | PrescriptionVitalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrescriptionVitals.
     */
    cursor?: PrescriptionVitalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrescriptionVitals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrescriptionVitals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrescriptionVitals.
     */
    distinct?: PrescriptionVitalsScalarFieldEnum | PrescriptionVitalsScalarFieldEnum[]
  }

  /**
   * PrescriptionVitals findFirstOrThrow
   */
  export type PrescriptionVitalsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionVitals
     */
    select?: PrescriptionVitalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionVitals
     */
    omit?: PrescriptionVitalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionVitalsInclude<ExtArgs> | null
    /**
     * Filter, which PrescriptionVitals to fetch.
     */
    where?: PrescriptionVitalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrescriptionVitals to fetch.
     */
    orderBy?: PrescriptionVitalsOrderByWithRelationInput | PrescriptionVitalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrescriptionVitals.
     */
    cursor?: PrescriptionVitalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrescriptionVitals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrescriptionVitals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrescriptionVitals.
     */
    distinct?: PrescriptionVitalsScalarFieldEnum | PrescriptionVitalsScalarFieldEnum[]
  }

  /**
   * PrescriptionVitals findMany
   */
  export type PrescriptionVitalsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionVitals
     */
    select?: PrescriptionVitalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionVitals
     */
    omit?: PrescriptionVitalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionVitalsInclude<ExtArgs> | null
    /**
     * Filter, which PrescriptionVitals to fetch.
     */
    where?: PrescriptionVitalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrescriptionVitals to fetch.
     */
    orderBy?: PrescriptionVitalsOrderByWithRelationInput | PrescriptionVitalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PrescriptionVitals.
     */
    cursor?: PrescriptionVitalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrescriptionVitals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrescriptionVitals.
     */
    skip?: number
    distinct?: PrescriptionVitalsScalarFieldEnum | PrescriptionVitalsScalarFieldEnum[]
  }

  /**
   * PrescriptionVitals create
   */
  export type PrescriptionVitalsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionVitals
     */
    select?: PrescriptionVitalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionVitals
     */
    omit?: PrescriptionVitalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionVitalsInclude<ExtArgs> | null
    /**
     * The data needed to create a PrescriptionVitals.
     */
    data: XOR<PrescriptionVitalsCreateInput, PrescriptionVitalsUncheckedCreateInput>
  }

  /**
   * PrescriptionVitals createMany
   */
  export type PrescriptionVitalsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PrescriptionVitals.
     */
    data: PrescriptionVitalsCreateManyInput | PrescriptionVitalsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PrescriptionVitals createManyAndReturn
   */
  export type PrescriptionVitalsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionVitals
     */
    select?: PrescriptionVitalsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionVitals
     */
    omit?: PrescriptionVitalsOmit<ExtArgs> | null
    /**
     * The data used to create many PrescriptionVitals.
     */
    data: PrescriptionVitalsCreateManyInput | PrescriptionVitalsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionVitalsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PrescriptionVitals update
   */
  export type PrescriptionVitalsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionVitals
     */
    select?: PrescriptionVitalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionVitals
     */
    omit?: PrescriptionVitalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionVitalsInclude<ExtArgs> | null
    /**
     * The data needed to update a PrescriptionVitals.
     */
    data: XOR<PrescriptionVitalsUpdateInput, PrescriptionVitalsUncheckedUpdateInput>
    /**
     * Choose, which PrescriptionVitals to update.
     */
    where: PrescriptionVitalsWhereUniqueInput
  }

  /**
   * PrescriptionVitals updateMany
   */
  export type PrescriptionVitalsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PrescriptionVitals.
     */
    data: XOR<PrescriptionVitalsUpdateManyMutationInput, PrescriptionVitalsUncheckedUpdateManyInput>
    /**
     * Filter which PrescriptionVitals to update
     */
    where?: PrescriptionVitalsWhereInput
    /**
     * Limit how many PrescriptionVitals to update.
     */
    limit?: number
  }

  /**
   * PrescriptionVitals updateManyAndReturn
   */
  export type PrescriptionVitalsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionVitals
     */
    select?: PrescriptionVitalsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionVitals
     */
    omit?: PrescriptionVitalsOmit<ExtArgs> | null
    /**
     * The data used to update PrescriptionVitals.
     */
    data: XOR<PrescriptionVitalsUpdateManyMutationInput, PrescriptionVitalsUncheckedUpdateManyInput>
    /**
     * Filter which PrescriptionVitals to update
     */
    where?: PrescriptionVitalsWhereInput
    /**
     * Limit how many PrescriptionVitals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionVitalsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PrescriptionVitals upsert
   */
  export type PrescriptionVitalsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionVitals
     */
    select?: PrescriptionVitalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionVitals
     */
    omit?: PrescriptionVitalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionVitalsInclude<ExtArgs> | null
    /**
     * The filter to search for the PrescriptionVitals to update in case it exists.
     */
    where: PrescriptionVitalsWhereUniqueInput
    /**
     * In case the PrescriptionVitals found by the `where` argument doesn't exist, create a new PrescriptionVitals with this data.
     */
    create: XOR<PrescriptionVitalsCreateInput, PrescriptionVitalsUncheckedCreateInput>
    /**
     * In case the PrescriptionVitals was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrescriptionVitalsUpdateInput, PrescriptionVitalsUncheckedUpdateInput>
  }

  /**
   * PrescriptionVitals delete
   */
  export type PrescriptionVitalsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionVitals
     */
    select?: PrescriptionVitalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionVitals
     */
    omit?: PrescriptionVitalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionVitalsInclude<ExtArgs> | null
    /**
     * Filter which PrescriptionVitals to delete.
     */
    where: PrescriptionVitalsWhereUniqueInput
  }

  /**
   * PrescriptionVitals deleteMany
   */
  export type PrescriptionVitalsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrescriptionVitals to delete
     */
    where?: PrescriptionVitalsWhereInput
    /**
     * Limit how many PrescriptionVitals to delete.
     */
    limit?: number
  }

  /**
   * PrescriptionVitals without action
   */
  export type PrescriptionVitalsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionVitals
     */
    select?: PrescriptionVitalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionVitals
     */
    omit?: PrescriptionVitalsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionVitalsInclude<ExtArgs> | null
  }


  /**
   * Model MedicalCertificate
   */

  export type AggregateMedicalCertificate = {
    _count: MedicalCertificateCountAggregateOutputType | null
    _avg: MedicalCertificateAvgAggregateOutputType | null
    _sum: MedicalCertificateSumAggregateOutputType | null
    _min: MedicalCertificateMinAggregateOutputType | null
    _max: MedicalCertificateMaxAggregateOutputType | null
  }

  export type MedicalCertificateAvgAggregateOutputType = {
    id: number | null
    patientId: number | null
    recommendedLeaveDays: number | null
    ageOfThePatient: number | null
  }

  export type MedicalCertificateSumAggregateOutputType = {
    id: number | null
    patientId: number | null
    recommendedLeaveDays: number | null
    ageOfThePatient: number | null
  }

  export type MedicalCertificateMinAggregateOutputType = {
    id: number | null
    patientId: number | null
    nameOfThePatient: string | null
    addressOfThePatient: string | null
    fitForDuty: $Enums.MedicalCertificateStatus | null
    dateOfSickness: Date | null
    recommendedLeaveDays: number | null
    natureOfTheDisease: string | null
    ageOfThePatient: number | null
    reccomendations: string | null
    time: Date | null
  }

  export type MedicalCertificateMaxAggregateOutputType = {
    id: number | null
    patientId: number | null
    nameOfThePatient: string | null
    addressOfThePatient: string | null
    fitForDuty: $Enums.MedicalCertificateStatus | null
    dateOfSickness: Date | null
    recommendedLeaveDays: number | null
    natureOfTheDisease: string | null
    ageOfThePatient: number | null
    reccomendations: string | null
    time: Date | null
  }

  export type MedicalCertificateCountAggregateOutputType = {
    id: number
    patientId: number
    nameOfThePatient: number
    addressOfThePatient: number
    fitForDuty: number
    dateOfSickness: number
    recommendedLeaveDays: number
    natureOfTheDisease: number
    ageOfThePatient: number
    reccomendations: number
    time: number
    _all: number
  }


  export type MedicalCertificateAvgAggregateInputType = {
    id?: true
    patientId?: true
    recommendedLeaveDays?: true
    ageOfThePatient?: true
  }

  export type MedicalCertificateSumAggregateInputType = {
    id?: true
    patientId?: true
    recommendedLeaveDays?: true
    ageOfThePatient?: true
  }

  export type MedicalCertificateMinAggregateInputType = {
    id?: true
    patientId?: true
    nameOfThePatient?: true
    addressOfThePatient?: true
    fitForDuty?: true
    dateOfSickness?: true
    recommendedLeaveDays?: true
    natureOfTheDisease?: true
    ageOfThePatient?: true
    reccomendations?: true
    time?: true
  }

  export type MedicalCertificateMaxAggregateInputType = {
    id?: true
    patientId?: true
    nameOfThePatient?: true
    addressOfThePatient?: true
    fitForDuty?: true
    dateOfSickness?: true
    recommendedLeaveDays?: true
    natureOfTheDisease?: true
    ageOfThePatient?: true
    reccomendations?: true
    time?: true
  }

  export type MedicalCertificateCountAggregateInputType = {
    id?: true
    patientId?: true
    nameOfThePatient?: true
    addressOfThePatient?: true
    fitForDuty?: true
    dateOfSickness?: true
    recommendedLeaveDays?: true
    natureOfTheDisease?: true
    ageOfThePatient?: true
    reccomendations?: true
    time?: true
    _all?: true
  }

  export type MedicalCertificateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicalCertificate to aggregate.
     */
    where?: MedicalCertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalCertificates to fetch.
     */
    orderBy?: MedicalCertificateOrderByWithRelationInput | MedicalCertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MedicalCertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalCertificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalCertificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MedicalCertificates
    **/
    _count?: true | MedicalCertificateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MedicalCertificateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MedicalCertificateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicalCertificateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicalCertificateMaxAggregateInputType
  }

  export type GetMedicalCertificateAggregateType<T extends MedicalCertificateAggregateArgs> = {
        [P in keyof T & keyof AggregateMedicalCertificate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedicalCertificate[P]>
      : GetScalarType<T[P], AggregateMedicalCertificate[P]>
  }




  export type MedicalCertificateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicalCertificateWhereInput
    orderBy?: MedicalCertificateOrderByWithAggregationInput | MedicalCertificateOrderByWithAggregationInput[]
    by: MedicalCertificateScalarFieldEnum[] | MedicalCertificateScalarFieldEnum
    having?: MedicalCertificateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicalCertificateCountAggregateInputType | true
    _avg?: MedicalCertificateAvgAggregateInputType
    _sum?: MedicalCertificateSumAggregateInputType
    _min?: MedicalCertificateMinAggregateInputType
    _max?: MedicalCertificateMaxAggregateInputType
  }

  export type MedicalCertificateGroupByOutputType = {
    id: number
    patientId: number
    nameOfThePatient: string
    addressOfThePatient: string
    fitForDuty: $Enums.MedicalCertificateStatus
    dateOfSickness: Date
    recommendedLeaveDays: number
    natureOfTheDisease: string
    ageOfThePatient: number
    reccomendations: string
    time: Date
    _count: MedicalCertificateCountAggregateOutputType | null
    _avg: MedicalCertificateAvgAggregateOutputType | null
    _sum: MedicalCertificateSumAggregateOutputType | null
    _min: MedicalCertificateMinAggregateOutputType | null
    _max: MedicalCertificateMaxAggregateOutputType | null
  }

  type GetMedicalCertificateGroupByPayload<T extends MedicalCertificateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicalCertificateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicalCertificateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicalCertificateGroupByOutputType[P]>
            : GetScalarType<T[P], MedicalCertificateGroupByOutputType[P]>
        }
      >
    >


  export type MedicalCertificateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    nameOfThePatient?: boolean
    addressOfThePatient?: boolean
    fitForDuty?: boolean
    dateOfSickness?: boolean
    recommendedLeaveDays?: boolean
    natureOfTheDisease?: boolean
    ageOfThePatient?: boolean
    reccomendations?: boolean
    time?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicalCertificate"]>

  export type MedicalCertificateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    nameOfThePatient?: boolean
    addressOfThePatient?: boolean
    fitForDuty?: boolean
    dateOfSickness?: boolean
    recommendedLeaveDays?: boolean
    natureOfTheDisease?: boolean
    ageOfThePatient?: boolean
    reccomendations?: boolean
    time?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicalCertificate"]>

  export type MedicalCertificateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    nameOfThePatient?: boolean
    addressOfThePatient?: boolean
    fitForDuty?: boolean
    dateOfSickness?: boolean
    recommendedLeaveDays?: boolean
    natureOfTheDisease?: boolean
    ageOfThePatient?: boolean
    reccomendations?: boolean
    time?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicalCertificate"]>

  export type MedicalCertificateSelectScalar = {
    id?: boolean
    patientId?: boolean
    nameOfThePatient?: boolean
    addressOfThePatient?: boolean
    fitForDuty?: boolean
    dateOfSickness?: boolean
    recommendedLeaveDays?: boolean
    natureOfTheDisease?: boolean
    ageOfThePatient?: boolean
    reccomendations?: boolean
    time?: boolean
  }

  export type MedicalCertificateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "nameOfThePatient" | "addressOfThePatient" | "fitForDuty" | "dateOfSickness" | "recommendedLeaveDays" | "natureOfTheDisease" | "ageOfThePatient" | "reccomendations" | "time", ExtArgs["result"]["medicalCertificate"]>
  export type MedicalCertificateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type MedicalCertificateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type MedicalCertificateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }

  export type $MedicalCertificatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MedicalCertificate"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      patientId: number
      nameOfThePatient: string
      addressOfThePatient: string
      fitForDuty: $Enums.MedicalCertificateStatus
      dateOfSickness: Date
      recommendedLeaveDays: number
      natureOfTheDisease: string
      ageOfThePatient: number
      reccomendations: string
      time: Date
    }, ExtArgs["result"]["medicalCertificate"]>
    composites: {}
  }

  type MedicalCertificateGetPayload<S extends boolean | null | undefined | MedicalCertificateDefaultArgs> = $Result.GetResult<Prisma.$MedicalCertificatePayload, S>

  type MedicalCertificateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MedicalCertificateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MedicalCertificateCountAggregateInputType | true
    }

  export interface MedicalCertificateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MedicalCertificate'], meta: { name: 'MedicalCertificate' } }
    /**
     * Find zero or one MedicalCertificate that matches the filter.
     * @param {MedicalCertificateFindUniqueArgs} args - Arguments to find a MedicalCertificate
     * @example
     * // Get one MedicalCertificate
     * const medicalCertificate = await prisma.medicalCertificate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MedicalCertificateFindUniqueArgs>(args: SelectSubset<T, MedicalCertificateFindUniqueArgs<ExtArgs>>): Prisma__MedicalCertificateClient<$Result.GetResult<Prisma.$MedicalCertificatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MedicalCertificate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MedicalCertificateFindUniqueOrThrowArgs} args - Arguments to find a MedicalCertificate
     * @example
     * // Get one MedicalCertificate
     * const medicalCertificate = await prisma.medicalCertificate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MedicalCertificateFindUniqueOrThrowArgs>(args: SelectSubset<T, MedicalCertificateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MedicalCertificateClient<$Result.GetResult<Prisma.$MedicalCertificatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicalCertificate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalCertificateFindFirstArgs} args - Arguments to find a MedicalCertificate
     * @example
     * // Get one MedicalCertificate
     * const medicalCertificate = await prisma.medicalCertificate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MedicalCertificateFindFirstArgs>(args?: SelectSubset<T, MedicalCertificateFindFirstArgs<ExtArgs>>): Prisma__MedicalCertificateClient<$Result.GetResult<Prisma.$MedicalCertificatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicalCertificate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalCertificateFindFirstOrThrowArgs} args - Arguments to find a MedicalCertificate
     * @example
     * // Get one MedicalCertificate
     * const medicalCertificate = await prisma.medicalCertificate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MedicalCertificateFindFirstOrThrowArgs>(args?: SelectSubset<T, MedicalCertificateFindFirstOrThrowArgs<ExtArgs>>): Prisma__MedicalCertificateClient<$Result.GetResult<Prisma.$MedicalCertificatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MedicalCertificates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalCertificateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MedicalCertificates
     * const medicalCertificates = await prisma.medicalCertificate.findMany()
     * 
     * // Get first 10 MedicalCertificates
     * const medicalCertificates = await prisma.medicalCertificate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicalCertificateWithIdOnly = await prisma.medicalCertificate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MedicalCertificateFindManyArgs>(args?: SelectSubset<T, MedicalCertificateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalCertificatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MedicalCertificate.
     * @param {MedicalCertificateCreateArgs} args - Arguments to create a MedicalCertificate.
     * @example
     * // Create one MedicalCertificate
     * const MedicalCertificate = await prisma.medicalCertificate.create({
     *   data: {
     *     // ... data to create a MedicalCertificate
     *   }
     * })
     * 
     */
    create<T extends MedicalCertificateCreateArgs>(args: SelectSubset<T, MedicalCertificateCreateArgs<ExtArgs>>): Prisma__MedicalCertificateClient<$Result.GetResult<Prisma.$MedicalCertificatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MedicalCertificates.
     * @param {MedicalCertificateCreateManyArgs} args - Arguments to create many MedicalCertificates.
     * @example
     * // Create many MedicalCertificates
     * const medicalCertificate = await prisma.medicalCertificate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MedicalCertificateCreateManyArgs>(args?: SelectSubset<T, MedicalCertificateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MedicalCertificates and returns the data saved in the database.
     * @param {MedicalCertificateCreateManyAndReturnArgs} args - Arguments to create many MedicalCertificates.
     * @example
     * // Create many MedicalCertificates
     * const medicalCertificate = await prisma.medicalCertificate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MedicalCertificates and only return the `id`
     * const medicalCertificateWithIdOnly = await prisma.medicalCertificate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MedicalCertificateCreateManyAndReturnArgs>(args?: SelectSubset<T, MedicalCertificateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalCertificatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MedicalCertificate.
     * @param {MedicalCertificateDeleteArgs} args - Arguments to delete one MedicalCertificate.
     * @example
     * // Delete one MedicalCertificate
     * const MedicalCertificate = await prisma.medicalCertificate.delete({
     *   where: {
     *     // ... filter to delete one MedicalCertificate
     *   }
     * })
     * 
     */
    delete<T extends MedicalCertificateDeleteArgs>(args: SelectSubset<T, MedicalCertificateDeleteArgs<ExtArgs>>): Prisma__MedicalCertificateClient<$Result.GetResult<Prisma.$MedicalCertificatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MedicalCertificate.
     * @param {MedicalCertificateUpdateArgs} args - Arguments to update one MedicalCertificate.
     * @example
     * // Update one MedicalCertificate
     * const medicalCertificate = await prisma.medicalCertificate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MedicalCertificateUpdateArgs>(args: SelectSubset<T, MedicalCertificateUpdateArgs<ExtArgs>>): Prisma__MedicalCertificateClient<$Result.GetResult<Prisma.$MedicalCertificatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MedicalCertificates.
     * @param {MedicalCertificateDeleteManyArgs} args - Arguments to filter MedicalCertificates to delete.
     * @example
     * // Delete a few MedicalCertificates
     * const { count } = await prisma.medicalCertificate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MedicalCertificateDeleteManyArgs>(args?: SelectSubset<T, MedicalCertificateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicalCertificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalCertificateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MedicalCertificates
     * const medicalCertificate = await prisma.medicalCertificate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MedicalCertificateUpdateManyArgs>(args: SelectSubset<T, MedicalCertificateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicalCertificates and returns the data updated in the database.
     * @param {MedicalCertificateUpdateManyAndReturnArgs} args - Arguments to update many MedicalCertificates.
     * @example
     * // Update many MedicalCertificates
     * const medicalCertificate = await prisma.medicalCertificate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MedicalCertificates and only return the `id`
     * const medicalCertificateWithIdOnly = await prisma.medicalCertificate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MedicalCertificateUpdateManyAndReturnArgs>(args: SelectSubset<T, MedicalCertificateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalCertificatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MedicalCertificate.
     * @param {MedicalCertificateUpsertArgs} args - Arguments to update or create a MedicalCertificate.
     * @example
     * // Update or create a MedicalCertificate
     * const medicalCertificate = await prisma.medicalCertificate.upsert({
     *   create: {
     *     // ... data to create a MedicalCertificate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MedicalCertificate we want to update
     *   }
     * })
     */
    upsert<T extends MedicalCertificateUpsertArgs>(args: SelectSubset<T, MedicalCertificateUpsertArgs<ExtArgs>>): Prisma__MedicalCertificateClient<$Result.GetResult<Prisma.$MedicalCertificatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MedicalCertificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalCertificateCountArgs} args - Arguments to filter MedicalCertificates to count.
     * @example
     * // Count the number of MedicalCertificates
     * const count = await prisma.medicalCertificate.count({
     *   where: {
     *     // ... the filter for the MedicalCertificates we want to count
     *   }
     * })
    **/
    count<T extends MedicalCertificateCountArgs>(
      args?: Subset<T, MedicalCertificateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicalCertificateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MedicalCertificate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalCertificateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicalCertificateAggregateArgs>(args: Subset<T, MedicalCertificateAggregateArgs>): Prisma.PrismaPromise<GetMedicalCertificateAggregateType<T>>

    /**
     * Group by MedicalCertificate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalCertificateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MedicalCertificateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MedicalCertificateGroupByArgs['orderBy'] }
        : { orderBy?: MedicalCertificateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MedicalCertificateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicalCertificateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MedicalCertificate model
   */
  readonly fields: MedicalCertificateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MedicalCertificate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MedicalCertificateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MedicalCertificate model
   */ 
  interface MedicalCertificateFieldRefs {
    readonly id: FieldRef<"MedicalCertificate", 'Int'>
    readonly patientId: FieldRef<"MedicalCertificate", 'Int'>
    readonly nameOfThePatient: FieldRef<"MedicalCertificate", 'String'>
    readonly addressOfThePatient: FieldRef<"MedicalCertificate", 'String'>
    readonly fitForDuty: FieldRef<"MedicalCertificate", 'MedicalCertificateStatus'>
    readonly dateOfSickness: FieldRef<"MedicalCertificate", 'DateTime'>
    readonly recommendedLeaveDays: FieldRef<"MedicalCertificate", 'Int'>
    readonly natureOfTheDisease: FieldRef<"MedicalCertificate", 'String'>
    readonly ageOfThePatient: FieldRef<"MedicalCertificate", 'Int'>
    readonly reccomendations: FieldRef<"MedicalCertificate", 'String'>
    readonly time: FieldRef<"MedicalCertificate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MedicalCertificate findUnique
   */
  export type MedicalCertificateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalCertificate
     */
    select?: MedicalCertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalCertificate
     */
    omit?: MedicalCertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalCertificateInclude<ExtArgs> | null
    /**
     * Filter, which MedicalCertificate to fetch.
     */
    where: MedicalCertificateWhereUniqueInput
  }

  /**
   * MedicalCertificate findUniqueOrThrow
   */
  export type MedicalCertificateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalCertificate
     */
    select?: MedicalCertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalCertificate
     */
    omit?: MedicalCertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalCertificateInclude<ExtArgs> | null
    /**
     * Filter, which MedicalCertificate to fetch.
     */
    where: MedicalCertificateWhereUniqueInput
  }

  /**
   * MedicalCertificate findFirst
   */
  export type MedicalCertificateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalCertificate
     */
    select?: MedicalCertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalCertificate
     */
    omit?: MedicalCertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalCertificateInclude<ExtArgs> | null
    /**
     * Filter, which MedicalCertificate to fetch.
     */
    where?: MedicalCertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalCertificates to fetch.
     */
    orderBy?: MedicalCertificateOrderByWithRelationInput | MedicalCertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicalCertificates.
     */
    cursor?: MedicalCertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalCertificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalCertificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicalCertificates.
     */
    distinct?: MedicalCertificateScalarFieldEnum | MedicalCertificateScalarFieldEnum[]
  }

  /**
   * MedicalCertificate findFirstOrThrow
   */
  export type MedicalCertificateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalCertificate
     */
    select?: MedicalCertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalCertificate
     */
    omit?: MedicalCertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalCertificateInclude<ExtArgs> | null
    /**
     * Filter, which MedicalCertificate to fetch.
     */
    where?: MedicalCertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalCertificates to fetch.
     */
    orderBy?: MedicalCertificateOrderByWithRelationInput | MedicalCertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicalCertificates.
     */
    cursor?: MedicalCertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalCertificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalCertificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicalCertificates.
     */
    distinct?: MedicalCertificateScalarFieldEnum | MedicalCertificateScalarFieldEnum[]
  }

  /**
   * MedicalCertificate findMany
   */
  export type MedicalCertificateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalCertificate
     */
    select?: MedicalCertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalCertificate
     */
    omit?: MedicalCertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalCertificateInclude<ExtArgs> | null
    /**
     * Filter, which MedicalCertificates to fetch.
     */
    where?: MedicalCertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalCertificates to fetch.
     */
    orderBy?: MedicalCertificateOrderByWithRelationInput | MedicalCertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MedicalCertificates.
     */
    cursor?: MedicalCertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalCertificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalCertificates.
     */
    skip?: number
    distinct?: MedicalCertificateScalarFieldEnum | MedicalCertificateScalarFieldEnum[]
  }

  /**
   * MedicalCertificate create
   */
  export type MedicalCertificateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalCertificate
     */
    select?: MedicalCertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalCertificate
     */
    omit?: MedicalCertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalCertificateInclude<ExtArgs> | null
    /**
     * The data needed to create a MedicalCertificate.
     */
    data: XOR<MedicalCertificateCreateInput, MedicalCertificateUncheckedCreateInput>
  }

  /**
   * MedicalCertificate createMany
   */
  export type MedicalCertificateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MedicalCertificates.
     */
    data: MedicalCertificateCreateManyInput | MedicalCertificateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MedicalCertificate createManyAndReturn
   */
  export type MedicalCertificateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalCertificate
     */
    select?: MedicalCertificateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalCertificate
     */
    omit?: MedicalCertificateOmit<ExtArgs> | null
    /**
     * The data used to create many MedicalCertificates.
     */
    data: MedicalCertificateCreateManyInput | MedicalCertificateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalCertificateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MedicalCertificate update
   */
  export type MedicalCertificateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalCertificate
     */
    select?: MedicalCertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalCertificate
     */
    omit?: MedicalCertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalCertificateInclude<ExtArgs> | null
    /**
     * The data needed to update a MedicalCertificate.
     */
    data: XOR<MedicalCertificateUpdateInput, MedicalCertificateUncheckedUpdateInput>
    /**
     * Choose, which MedicalCertificate to update.
     */
    where: MedicalCertificateWhereUniqueInput
  }

  /**
   * MedicalCertificate updateMany
   */
  export type MedicalCertificateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MedicalCertificates.
     */
    data: XOR<MedicalCertificateUpdateManyMutationInput, MedicalCertificateUncheckedUpdateManyInput>
    /**
     * Filter which MedicalCertificates to update
     */
    where?: MedicalCertificateWhereInput
    /**
     * Limit how many MedicalCertificates to update.
     */
    limit?: number
  }

  /**
   * MedicalCertificate updateManyAndReturn
   */
  export type MedicalCertificateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalCertificate
     */
    select?: MedicalCertificateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalCertificate
     */
    omit?: MedicalCertificateOmit<ExtArgs> | null
    /**
     * The data used to update MedicalCertificates.
     */
    data: XOR<MedicalCertificateUpdateManyMutationInput, MedicalCertificateUncheckedUpdateManyInput>
    /**
     * Filter which MedicalCertificates to update
     */
    where?: MedicalCertificateWhereInput
    /**
     * Limit how many MedicalCertificates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalCertificateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MedicalCertificate upsert
   */
  export type MedicalCertificateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalCertificate
     */
    select?: MedicalCertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalCertificate
     */
    omit?: MedicalCertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalCertificateInclude<ExtArgs> | null
    /**
     * The filter to search for the MedicalCertificate to update in case it exists.
     */
    where: MedicalCertificateWhereUniqueInput
    /**
     * In case the MedicalCertificate found by the `where` argument doesn't exist, create a new MedicalCertificate with this data.
     */
    create: XOR<MedicalCertificateCreateInput, MedicalCertificateUncheckedCreateInput>
    /**
     * In case the MedicalCertificate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MedicalCertificateUpdateInput, MedicalCertificateUncheckedUpdateInput>
  }

  /**
   * MedicalCertificate delete
   */
  export type MedicalCertificateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalCertificate
     */
    select?: MedicalCertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalCertificate
     */
    omit?: MedicalCertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalCertificateInclude<ExtArgs> | null
    /**
     * Filter which MedicalCertificate to delete.
     */
    where: MedicalCertificateWhereUniqueInput
  }

  /**
   * MedicalCertificate deleteMany
   */
  export type MedicalCertificateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicalCertificates to delete
     */
    where?: MedicalCertificateWhereInput
    /**
     * Limit how many MedicalCertificates to delete.
     */
    limit?: number
  }

  /**
   * MedicalCertificate without action
   */
  export type MedicalCertificateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalCertificate
     */
    select?: MedicalCertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalCertificate
     */
    omit?: MedicalCertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalCertificateInclude<ExtArgs> | null
  }


  /**
   * Model USSReferral
   */

  export type AggregateUSSReferral = {
    _count: USSReferralCountAggregateOutputType | null
    _avg: USSReferralAvgAggregateOutputType | null
    _sum: USSReferralSumAggregateOutputType | null
    _min: USSReferralMinAggregateOutputType | null
    _max: USSReferralMaxAggregateOutputType | null
  }

  export type USSReferralAvgAggregateOutputType = {
    id: number | null
    patientId: number | null
    ageOfThePatient: number | null
  }

  export type USSReferralSumAggregateOutputType = {
    id: number | null
    patientId: number | null
    ageOfThePatient: number | null
  }

  export type USSReferralMinAggregateOutputType = {
    id: number | null
    patientId: number | null
    nameOfThePatient: string | null
    presentingComplaint: string | null
    duration: string | null
    onExamination: string | null
    pshx_pmhx: string | null
    ageOfThePatient: number | null
    reportDate: Date | null
    USS_type: string | null
    radiologist: string | null
    radiologist_title: string | null
    time: Date | null
  }

  export type USSReferralMaxAggregateOutputType = {
    id: number | null
    patientId: number | null
    nameOfThePatient: string | null
    presentingComplaint: string | null
    duration: string | null
    onExamination: string | null
    pshx_pmhx: string | null
    ageOfThePatient: number | null
    reportDate: Date | null
    USS_type: string | null
    radiologist: string | null
    radiologist_title: string | null
    time: Date | null
  }

  export type USSReferralCountAggregateOutputType = {
    id: number
    patientId: number
    nameOfThePatient: number
    presentingComplaint: number
    duration: number
    onExamination: number
    pshx_pmhx: number
    ageOfThePatient: number
    reportDate: number
    USS_type: number
    radiologist: number
    radiologist_title: number
    time: number
    _all: number
  }


  export type USSReferralAvgAggregateInputType = {
    id?: true
    patientId?: true
    ageOfThePatient?: true
  }

  export type USSReferralSumAggregateInputType = {
    id?: true
    patientId?: true
    ageOfThePatient?: true
  }

  export type USSReferralMinAggregateInputType = {
    id?: true
    patientId?: true
    nameOfThePatient?: true
    presentingComplaint?: true
    duration?: true
    onExamination?: true
    pshx_pmhx?: true
    ageOfThePatient?: true
    reportDate?: true
    USS_type?: true
    radiologist?: true
    radiologist_title?: true
    time?: true
  }

  export type USSReferralMaxAggregateInputType = {
    id?: true
    patientId?: true
    nameOfThePatient?: true
    presentingComplaint?: true
    duration?: true
    onExamination?: true
    pshx_pmhx?: true
    ageOfThePatient?: true
    reportDate?: true
    USS_type?: true
    radiologist?: true
    radiologist_title?: true
    time?: true
  }

  export type USSReferralCountAggregateInputType = {
    id?: true
    patientId?: true
    nameOfThePatient?: true
    presentingComplaint?: true
    duration?: true
    onExamination?: true
    pshx_pmhx?: true
    ageOfThePatient?: true
    reportDate?: true
    USS_type?: true
    radiologist?: true
    radiologist_title?: true
    time?: true
    _all?: true
  }

  export type USSReferralAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which USSReferral to aggregate.
     */
    where?: USSReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of USSReferrals to fetch.
     */
    orderBy?: USSReferralOrderByWithRelationInput | USSReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: USSReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` USSReferrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` USSReferrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned USSReferrals
    **/
    _count?: true | USSReferralCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: USSReferralAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: USSReferralSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: USSReferralMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: USSReferralMaxAggregateInputType
  }

  export type GetUSSReferralAggregateType<T extends USSReferralAggregateArgs> = {
        [P in keyof T & keyof AggregateUSSReferral]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUSSReferral[P]>
      : GetScalarType<T[P], AggregateUSSReferral[P]>
  }




  export type USSReferralGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: USSReferralWhereInput
    orderBy?: USSReferralOrderByWithAggregationInput | USSReferralOrderByWithAggregationInput[]
    by: USSReferralScalarFieldEnum[] | USSReferralScalarFieldEnum
    having?: USSReferralScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: USSReferralCountAggregateInputType | true
    _avg?: USSReferralAvgAggregateInputType
    _sum?: USSReferralSumAggregateInputType
    _min?: USSReferralMinAggregateInputType
    _max?: USSReferralMaxAggregateInputType
  }

  export type USSReferralGroupByOutputType = {
    id: number
    patientId: number
    nameOfThePatient: string
    presentingComplaint: string
    duration: string
    onExamination: string
    pshx_pmhx: string
    ageOfThePatient: number
    reportDate: Date
    USS_type: string
    radiologist: string
    radiologist_title: string
    time: Date
    _count: USSReferralCountAggregateOutputType | null
    _avg: USSReferralAvgAggregateOutputType | null
    _sum: USSReferralSumAggregateOutputType | null
    _min: USSReferralMinAggregateOutputType | null
    _max: USSReferralMaxAggregateOutputType | null
  }

  type GetUSSReferralGroupByPayload<T extends USSReferralGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<USSReferralGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof USSReferralGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], USSReferralGroupByOutputType[P]>
            : GetScalarType<T[P], USSReferralGroupByOutputType[P]>
        }
      >
    >


  export type USSReferralSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    nameOfThePatient?: boolean
    presentingComplaint?: boolean
    duration?: boolean
    onExamination?: boolean
    pshx_pmhx?: boolean
    ageOfThePatient?: boolean
    reportDate?: boolean
    USS_type?: boolean
    radiologist?: boolean
    radiologist_title?: boolean
    time?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["uSSReferral"]>

  export type USSReferralSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    nameOfThePatient?: boolean
    presentingComplaint?: boolean
    duration?: boolean
    onExamination?: boolean
    pshx_pmhx?: boolean
    ageOfThePatient?: boolean
    reportDate?: boolean
    USS_type?: boolean
    radiologist?: boolean
    radiologist_title?: boolean
    time?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["uSSReferral"]>

  export type USSReferralSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    nameOfThePatient?: boolean
    presentingComplaint?: boolean
    duration?: boolean
    onExamination?: boolean
    pshx_pmhx?: boolean
    ageOfThePatient?: boolean
    reportDate?: boolean
    USS_type?: boolean
    radiologist?: boolean
    radiologist_title?: boolean
    time?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["uSSReferral"]>

  export type USSReferralSelectScalar = {
    id?: boolean
    patientId?: boolean
    nameOfThePatient?: boolean
    presentingComplaint?: boolean
    duration?: boolean
    onExamination?: boolean
    pshx_pmhx?: boolean
    ageOfThePatient?: boolean
    reportDate?: boolean
    USS_type?: boolean
    radiologist?: boolean
    radiologist_title?: boolean
    time?: boolean
  }

  export type USSReferralOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "nameOfThePatient" | "presentingComplaint" | "duration" | "onExamination" | "pshx_pmhx" | "ageOfThePatient" | "reportDate" | "USS_type" | "radiologist" | "radiologist_title" | "time", ExtArgs["result"]["uSSReferral"]>
  export type USSReferralInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type USSReferralIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type USSReferralIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }

  export type $USSReferralPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "USSReferral"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      patientId: number
      nameOfThePatient: string
      presentingComplaint: string
      duration: string
      onExamination: string
      pshx_pmhx: string
      ageOfThePatient: number
      reportDate: Date
      USS_type: string
      radiologist: string
      radiologist_title: string
      time: Date
    }, ExtArgs["result"]["uSSReferral"]>
    composites: {}
  }

  type USSReferralGetPayload<S extends boolean | null | undefined | USSReferralDefaultArgs> = $Result.GetResult<Prisma.$USSReferralPayload, S>

  type USSReferralCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<USSReferralFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: USSReferralCountAggregateInputType | true
    }

  export interface USSReferralDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['USSReferral'], meta: { name: 'USSReferral' } }
    /**
     * Find zero or one USSReferral that matches the filter.
     * @param {USSReferralFindUniqueArgs} args - Arguments to find a USSReferral
     * @example
     * // Get one USSReferral
     * const uSSReferral = await prisma.uSSReferral.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends USSReferralFindUniqueArgs>(args: SelectSubset<T, USSReferralFindUniqueArgs<ExtArgs>>): Prisma__USSReferralClient<$Result.GetResult<Prisma.$USSReferralPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one USSReferral that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {USSReferralFindUniqueOrThrowArgs} args - Arguments to find a USSReferral
     * @example
     * // Get one USSReferral
     * const uSSReferral = await prisma.uSSReferral.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends USSReferralFindUniqueOrThrowArgs>(args: SelectSubset<T, USSReferralFindUniqueOrThrowArgs<ExtArgs>>): Prisma__USSReferralClient<$Result.GetResult<Prisma.$USSReferralPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first USSReferral that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {USSReferralFindFirstArgs} args - Arguments to find a USSReferral
     * @example
     * // Get one USSReferral
     * const uSSReferral = await prisma.uSSReferral.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends USSReferralFindFirstArgs>(args?: SelectSubset<T, USSReferralFindFirstArgs<ExtArgs>>): Prisma__USSReferralClient<$Result.GetResult<Prisma.$USSReferralPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first USSReferral that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {USSReferralFindFirstOrThrowArgs} args - Arguments to find a USSReferral
     * @example
     * // Get one USSReferral
     * const uSSReferral = await prisma.uSSReferral.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends USSReferralFindFirstOrThrowArgs>(args?: SelectSubset<T, USSReferralFindFirstOrThrowArgs<ExtArgs>>): Prisma__USSReferralClient<$Result.GetResult<Prisma.$USSReferralPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more USSReferrals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {USSReferralFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all USSReferrals
     * const uSSReferrals = await prisma.uSSReferral.findMany()
     * 
     * // Get first 10 USSReferrals
     * const uSSReferrals = await prisma.uSSReferral.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const uSSReferralWithIdOnly = await prisma.uSSReferral.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends USSReferralFindManyArgs>(args?: SelectSubset<T, USSReferralFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$USSReferralPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a USSReferral.
     * @param {USSReferralCreateArgs} args - Arguments to create a USSReferral.
     * @example
     * // Create one USSReferral
     * const USSReferral = await prisma.uSSReferral.create({
     *   data: {
     *     // ... data to create a USSReferral
     *   }
     * })
     * 
     */
    create<T extends USSReferralCreateArgs>(args: SelectSubset<T, USSReferralCreateArgs<ExtArgs>>): Prisma__USSReferralClient<$Result.GetResult<Prisma.$USSReferralPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many USSReferrals.
     * @param {USSReferralCreateManyArgs} args - Arguments to create many USSReferrals.
     * @example
     * // Create many USSReferrals
     * const uSSReferral = await prisma.uSSReferral.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends USSReferralCreateManyArgs>(args?: SelectSubset<T, USSReferralCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many USSReferrals and returns the data saved in the database.
     * @param {USSReferralCreateManyAndReturnArgs} args - Arguments to create many USSReferrals.
     * @example
     * // Create many USSReferrals
     * const uSSReferral = await prisma.uSSReferral.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many USSReferrals and only return the `id`
     * const uSSReferralWithIdOnly = await prisma.uSSReferral.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends USSReferralCreateManyAndReturnArgs>(args?: SelectSubset<T, USSReferralCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$USSReferralPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a USSReferral.
     * @param {USSReferralDeleteArgs} args - Arguments to delete one USSReferral.
     * @example
     * // Delete one USSReferral
     * const USSReferral = await prisma.uSSReferral.delete({
     *   where: {
     *     // ... filter to delete one USSReferral
     *   }
     * })
     * 
     */
    delete<T extends USSReferralDeleteArgs>(args: SelectSubset<T, USSReferralDeleteArgs<ExtArgs>>): Prisma__USSReferralClient<$Result.GetResult<Prisma.$USSReferralPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one USSReferral.
     * @param {USSReferralUpdateArgs} args - Arguments to update one USSReferral.
     * @example
     * // Update one USSReferral
     * const uSSReferral = await prisma.uSSReferral.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends USSReferralUpdateArgs>(args: SelectSubset<T, USSReferralUpdateArgs<ExtArgs>>): Prisma__USSReferralClient<$Result.GetResult<Prisma.$USSReferralPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more USSReferrals.
     * @param {USSReferralDeleteManyArgs} args - Arguments to filter USSReferrals to delete.
     * @example
     * // Delete a few USSReferrals
     * const { count } = await prisma.uSSReferral.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends USSReferralDeleteManyArgs>(args?: SelectSubset<T, USSReferralDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more USSReferrals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {USSReferralUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many USSReferrals
     * const uSSReferral = await prisma.uSSReferral.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends USSReferralUpdateManyArgs>(args: SelectSubset<T, USSReferralUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more USSReferrals and returns the data updated in the database.
     * @param {USSReferralUpdateManyAndReturnArgs} args - Arguments to update many USSReferrals.
     * @example
     * // Update many USSReferrals
     * const uSSReferral = await prisma.uSSReferral.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more USSReferrals and only return the `id`
     * const uSSReferralWithIdOnly = await prisma.uSSReferral.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends USSReferralUpdateManyAndReturnArgs>(args: SelectSubset<T, USSReferralUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$USSReferralPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one USSReferral.
     * @param {USSReferralUpsertArgs} args - Arguments to update or create a USSReferral.
     * @example
     * // Update or create a USSReferral
     * const uSSReferral = await prisma.uSSReferral.upsert({
     *   create: {
     *     // ... data to create a USSReferral
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the USSReferral we want to update
     *   }
     * })
     */
    upsert<T extends USSReferralUpsertArgs>(args: SelectSubset<T, USSReferralUpsertArgs<ExtArgs>>): Prisma__USSReferralClient<$Result.GetResult<Prisma.$USSReferralPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of USSReferrals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {USSReferralCountArgs} args - Arguments to filter USSReferrals to count.
     * @example
     * // Count the number of USSReferrals
     * const count = await prisma.uSSReferral.count({
     *   where: {
     *     // ... the filter for the USSReferrals we want to count
     *   }
     * })
    **/
    count<T extends USSReferralCountArgs>(
      args?: Subset<T, USSReferralCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], USSReferralCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a USSReferral.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {USSReferralAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends USSReferralAggregateArgs>(args: Subset<T, USSReferralAggregateArgs>): Prisma.PrismaPromise<GetUSSReferralAggregateType<T>>

    /**
     * Group by USSReferral.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {USSReferralGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends USSReferralGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: USSReferralGroupByArgs['orderBy'] }
        : { orderBy?: USSReferralGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, USSReferralGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUSSReferralGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the USSReferral model
   */
  readonly fields: USSReferralFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for USSReferral.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__USSReferralClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the USSReferral model
   */ 
  interface USSReferralFieldRefs {
    readonly id: FieldRef<"USSReferral", 'Int'>
    readonly patientId: FieldRef<"USSReferral", 'Int'>
    readonly nameOfThePatient: FieldRef<"USSReferral", 'String'>
    readonly presentingComplaint: FieldRef<"USSReferral", 'String'>
    readonly duration: FieldRef<"USSReferral", 'String'>
    readonly onExamination: FieldRef<"USSReferral", 'String'>
    readonly pshx_pmhx: FieldRef<"USSReferral", 'String'>
    readonly ageOfThePatient: FieldRef<"USSReferral", 'Int'>
    readonly reportDate: FieldRef<"USSReferral", 'DateTime'>
    readonly USS_type: FieldRef<"USSReferral", 'String'>
    readonly radiologist: FieldRef<"USSReferral", 'String'>
    readonly radiologist_title: FieldRef<"USSReferral", 'String'>
    readonly time: FieldRef<"USSReferral", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * USSReferral findUnique
   */
  export type USSReferralFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the USSReferral
     */
    select?: USSReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the USSReferral
     */
    omit?: USSReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: USSReferralInclude<ExtArgs> | null
    /**
     * Filter, which USSReferral to fetch.
     */
    where: USSReferralWhereUniqueInput
  }

  /**
   * USSReferral findUniqueOrThrow
   */
  export type USSReferralFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the USSReferral
     */
    select?: USSReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the USSReferral
     */
    omit?: USSReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: USSReferralInclude<ExtArgs> | null
    /**
     * Filter, which USSReferral to fetch.
     */
    where: USSReferralWhereUniqueInput
  }

  /**
   * USSReferral findFirst
   */
  export type USSReferralFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the USSReferral
     */
    select?: USSReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the USSReferral
     */
    omit?: USSReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: USSReferralInclude<ExtArgs> | null
    /**
     * Filter, which USSReferral to fetch.
     */
    where?: USSReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of USSReferrals to fetch.
     */
    orderBy?: USSReferralOrderByWithRelationInput | USSReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for USSReferrals.
     */
    cursor?: USSReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` USSReferrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` USSReferrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of USSReferrals.
     */
    distinct?: USSReferralScalarFieldEnum | USSReferralScalarFieldEnum[]
  }

  /**
   * USSReferral findFirstOrThrow
   */
  export type USSReferralFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the USSReferral
     */
    select?: USSReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the USSReferral
     */
    omit?: USSReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: USSReferralInclude<ExtArgs> | null
    /**
     * Filter, which USSReferral to fetch.
     */
    where?: USSReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of USSReferrals to fetch.
     */
    orderBy?: USSReferralOrderByWithRelationInput | USSReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for USSReferrals.
     */
    cursor?: USSReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` USSReferrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` USSReferrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of USSReferrals.
     */
    distinct?: USSReferralScalarFieldEnum | USSReferralScalarFieldEnum[]
  }

  /**
   * USSReferral findMany
   */
  export type USSReferralFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the USSReferral
     */
    select?: USSReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the USSReferral
     */
    omit?: USSReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: USSReferralInclude<ExtArgs> | null
    /**
     * Filter, which USSReferrals to fetch.
     */
    where?: USSReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of USSReferrals to fetch.
     */
    orderBy?: USSReferralOrderByWithRelationInput | USSReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing USSReferrals.
     */
    cursor?: USSReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` USSReferrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` USSReferrals.
     */
    skip?: number
    distinct?: USSReferralScalarFieldEnum | USSReferralScalarFieldEnum[]
  }

  /**
   * USSReferral create
   */
  export type USSReferralCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the USSReferral
     */
    select?: USSReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the USSReferral
     */
    omit?: USSReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: USSReferralInclude<ExtArgs> | null
    /**
     * The data needed to create a USSReferral.
     */
    data: XOR<USSReferralCreateInput, USSReferralUncheckedCreateInput>
  }

  /**
   * USSReferral createMany
   */
  export type USSReferralCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many USSReferrals.
     */
    data: USSReferralCreateManyInput | USSReferralCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * USSReferral createManyAndReturn
   */
  export type USSReferralCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the USSReferral
     */
    select?: USSReferralSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the USSReferral
     */
    omit?: USSReferralOmit<ExtArgs> | null
    /**
     * The data used to create many USSReferrals.
     */
    data: USSReferralCreateManyInput | USSReferralCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: USSReferralIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * USSReferral update
   */
  export type USSReferralUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the USSReferral
     */
    select?: USSReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the USSReferral
     */
    omit?: USSReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: USSReferralInclude<ExtArgs> | null
    /**
     * The data needed to update a USSReferral.
     */
    data: XOR<USSReferralUpdateInput, USSReferralUncheckedUpdateInput>
    /**
     * Choose, which USSReferral to update.
     */
    where: USSReferralWhereUniqueInput
  }

  /**
   * USSReferral updateMany
   */
  export type USSReferralUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update USSReferrals.
     */
    data: XOR<USSReferralUpdateManyMutationInput, USSReferralUncheckedUpdateManyInput>
    /**
     * Filter which USSReferrals to update
     */
    where?: USSReferralWhereInput
    /**
     * Limit how many USSReferrals to update.
     */
    limit?: number
  }

  /**
   * USSReferral updateManyAndReturn
   */
  export type USSReferralUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the USSReferral
     */
    select?: USSReferralSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the USSReferral
     */
    omit?: USSReferralOmit<ExtArgs> | null
    /**
     * The data used to update USSReferrals.
     */
    data: XOR<USSReferralUpdateManyMutationInput, USSReferralUncheckedUpdateManyInput>
    /**
     * Filter which USSReferrals to update
     */
    where?: USSReferralWhereInput
    /**
     * Limit how many USSReferrals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: USSReferralIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * USSReferral upsert
   */
  export type USSReferralUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the USSReferral
     */
    select?: USSReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the USSReferral
     */
    omit?: USSReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: USSReferralInclude<ExtArgs> | null
    /**
     * The filter to search for the USSReferral to update in case it exists.
     */
    where: USSReferralWhereUniqueInput
    /**
     * In case the USSReferral found by the `where` argument doesn't exist, create a new USSReferral with this data.
     */
    create: XOR<USSReferralCreateInput, USSReferralUncheckedCreateInput>
    /**
     * In case the USSReferral was found with the provided `where` argument, update it with this data.
     */
    update: XOR<USSReferralUpdateInput, USSReferralUncheckedUpdateInput>
  }

  /**
   * USSReferral delete
   */
  export type USSReferralDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the USSReferral
     */
    select?: USSReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the USSReferral
     */
    omit?: USSReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: USSReferralInclude<ExtArgs> | null
    /**
     * Filter which USSReferral to delete.
     */
    where: USSReferralWhereUniqueInput
  }

  /**
   * USSReferral deleteMany
   */
  export type USSReferralDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which USSReferrals to delete
     */
    where?: USSReferralWhereInput
    /**
     * Limit how many USSReferrals to delete.
     */
    limit?: number
  }

  /**
   * USSReferral without action
   */
  export type USSReferralDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the USSReferral
     */
    select?: USSReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the USSReferral
     */
    omit?: USSReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: USSReferralInclude<ExtArgs> | null
  }


  /**
   * Model ReferralLetter
   */

  export type AggregateReferralLetter = {
    _count: ReferralLetterCountAggregateOutputType | null
    _avg: ReferralLetterAvgAggregateOutputType | null
    _sum: ReferralLetterSumAggregateOutputType | null
    _min: ReferralLetterMinAggregateOutputType | null
    _max: ReferralLetterMaxAggregateOutputType | null
  }

  export type ReferralLetterAvgAggregateOutputType = {
    id: number | null
    patientId: number | null
    ageOfThePatient: number | null
  }

  export type ReferralLetterSumAggregateOutputType = {
    id: number | null
    patientId: number | null
    ageOfThePatient: number | null
  }

  export type ReferralLetterMinAggregateOutputType = {
    id: number | null
    patientId: number | null
    nameOfThePatient: string | null
    consultant_speciality: string | null
    consultant_name: string | null
    condition1: string | null
    condition2: string | null
    condition3: string | null
    investigations: string | null
    ageOfThePatient: number | null
    reportDate: Date | null
    time: Date | null
  }

  export type ReferralLetterMaxAggregateOutputType = {
    id: number | null
    patientId: number | null
    nameOfThePatient: string | null
    consultant_speciality: string | null
    consultant_name: string | null
    condition1: string | null
    condition2: string | null
    condition3: string | null
    investigations: string | null
    ageOfThePatient: number | null
    reportDate: Date | null
    time: Date | null
  }

  export type ReferralLetterCountAggregateOutputType = {
    id: number
    patientId: number
    nameOfThePatient: number
    consultant_speciality: number
    consultant_name: number
    condition1: number
    condition2: number
    condition3: number
    investigations: number
    ageOfThePatient: number
    reportDate: number
    time: number
    _all: number
  }


  export type ReferralLetterAvgAggregateInputType = {
    id?: true
    patientId?: true
    ageOfThePatient?: true
  }

  export type ReferralLetterSumAggregateInputType = {
    id?: true
    patientId?: true
    ageOfThePatient?: true
  }

  export type ReferralLetterMinAggregateInputType = {
    id?: true
    patientId?: true
    nameOfThePatient?: true
    consultant_speciality?: true
    consultant_name?: true
    condition1?: true
    condition2?: true
    condition3?: true
    investigations?: true
    ageOfThePatient?: true
    reportDate?: true
    time?: true
  }

  export type ReferralLetterMaxAggregateInputType = {
    id?: true
    patientId?: true
    nameOfThePatient?: true
    consultant_speciality?: true
    consultant_name?: true
    condition1?: true
    condition2?: true
    condition3?: true
    investigations?: true
    ageOfThePatient?: true
    reportDate?: true
    time?: true
  }

  export type ReferralLetterCountAggregateInputType = {
    id?: true
    patientId?: true
    nameOfThePatient?: true
    consultant_speciality?: true
    consultant_name?: true
    condition1?: true
    condition2?: true
    condition3?: true
    investigations?: true
    ageOfThePatient?: true
    reportDate?: true
    time?: true
    _all?: true
  }

  export type ReferralLetterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReferralLetter to aggregate.
     */
    where?: ReferralLetterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferralLetters to fetch.
     */
    orderBy?: ReferralLetterOrderByWithRelationInput | ReferralLetterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReferralLetterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferralLetters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferralLetters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReferralLetters
    **/
    _count?: true | ReferralLetterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReferralLetterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReferralLetterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReferralLetterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReferralLetterMaxAggregateInputType
  }

  export type GetReferralLetterAggregateType<T extends ReferralLetterAggregateArgs> = {
        [P in keyof T & keyof AggregateReferralLetter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReferralLetter[P]>
      : GetScalarType<T[P], AggregateReferralLetter[P]>
  }




  export type ReferralLetterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralLetterWhereInput
    orderBy?: ReferralLetterOrderByWithAggregationInput | ReferralLetterOrderByWithAggregationInput[]
    by: ReferralLetterScalarFieldEnum[] | ReferralLetterScalarFieldEnum
    having?: ReferralLetterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReferralLetterCountAggregateInputType | true
    _avg?: ReferralLetterAvgAggregateInputType
    _sum?: ReferralLetterSumAggregateInputType
    _min?: ReferralLetterMinAggregateInputType
    _max?: ReferralLetterMaxAggregateInputType
  }

  export type ReferralLetterGroupByOutputType = {
    id: number
    patientId: number
    nameOfThePatient: string
    consultant_speciality: string
    consultant_name: string
    condition1: string
    condition2: string
    condition3: string
    investigations: string
    ageOfThePatient: number
    reportDate: Date
    time: Date
    _count: ReferralLetterCountAggregateOutputType | null
    _avg: ReferralLetterAvgAggregateOutputType | null
    _sum: ReferralLetterSumAggregateOutputType | null
    _min: ReferralLetterMinAggregateOutputType | null
    _max: ReferralLetterMaxAggregateOutputType | null
  }

  type GetReferralLetterGroupByPayload<T extends ReferralLetterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReferralLetterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReferralLetterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReferralLetterGroupByOutputType[P]>
            : GetScalarType<T[P], ReferralLetterGroupByOutputType[P]>
        }
      >
    >


  export type ReferralLetterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    nameOfThePatient?: boolean
    consultant_speciality?: boolean
    consultant_name?: boolean
    condition1?: boolean
    condition2?: boolean
    condition3?: boolean
    investigations?: boolean
    ageOfThePatient?: boolean
    reportDate?: boolean
    time?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referralLetter"]>

  export type ReferralLetterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    nameOfThePatient?: boolean
    consultant_speciality?: boolean
    consultant_name?: boolean
    condition1?: boolean
    condition2?: boolean
    condition3?: boolean
    investigations?: boolean
    ageOfThePatient?: boolean
    reportDate?: boolean
    time?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referralLetter"]>

  export type ReferralLetterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    nameOfThePatient?: boolean
    consultant_speciality?: boolean
    consultant_name?: boolean
    condition1?: boolean
    condition2?: boolean
    condition3?: boolean
    investigations?: boolean
    ageOfThePatient?: boolean
    reportDate?: boolean
    time?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referralLetter"]>

  export type ReferralLetterSelectScalar = {
    id?: boolean
    patientId?: boolean
    nameOfThePatient?: boolean
    consultant_speciality?: boolean
    consultant_name?: boolean
    condition1?: boolean
    condition2?: boolean
    condition3?: boolean
    investigations?: boolean
    ageOfThePatient?: boolean
    reportDate?: boolean
    time?: boolean
  }

  export type ReferralLetterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "nameOfThePatient" | "consultant_speciality" | "consultant_name" | "condition1" | "condition2" | "condition3" | "investigations" | "ageOfThePatient" | "reportDate" | "time", ExtArgs["result"]["referralLetter"]>
  export type ReferralLetterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type ReferralLetterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type ReferralLetterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }

  export type $ReferralLetterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReferralLetter"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      patientId: number
      nameOfThePatient: string
      consultant_speciality: string
      consultant_name: string
      condition1: string
      condition2: string
      condition3: string
      investigations: string
      ageOfThePatient: number
      reportDate: Date
      time: Date
    }, ExtArgs["result"]["referralLetter"]>
    composites: {}
  }

  type ReferralLetterGetPayload<S extends boolean | null | undefined | ReferralLetterDefaultArgs> = $Result.GetResult<Prisma.$ReferralLetterPayload, S>

  type ReferralLetterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReferralLetterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReferralLetterCountAggregateInputType | true
    }

  export interface ReferralLetterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReferralLetter'], meta: { name: 'ReferralLetter' } }
    /**
     * Find zero or one ReferralLetter that matches the filter.
     * @param {ReferralLetterFindUniqueArgs} args - Arguments to find a ReferralLetter
     * @example
     * // Get one ReferralLetter
     * const referralLetter = await prisma.referralLetter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReferralLetterFindUniqueArgs>(args: SelectSubset<T, ReferralLetterFindUniqueArgs<ExtArgs>>): Prisma__ReferralLetterClient<$Result.GetResult<Prisma.$ReferralLetterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReferralLetter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReferralLetterFindUniqueOrThrowArgs} args - Arguments to find a ReferralLetter
     * @example
     * // Get one ReferralLetter
     * const referralLetter = await prisma.referralLetter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReferralLetterFindUniqueOrThrowArgs>(args: SelectSubset<T, ReferralLetterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReferralLetterClient<$Result.GetResult<Prisma.$ReferralLetterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReferralLetter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralLetterFindFirstArgs} args - Arguments to find a ReferralLetter
     * @example
     * // Get one ReferralLetter
     * const referralLetter = await prisma.referralLetter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReferralLetterFindFirstArgs>(args?: SelectSubset<T, ReferralLetterFindFirstArgs<ExtArgs>>): Prisma__ReferralLetterClient<$Result.GetResult<Prisma.$ReferralLetterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReferralLetter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralLetterFindFirstOrThrowArgs} args - Arguments to find a ReferralLetter
     * @example
     * // Get one ReferralLetter
     * const referralLetter = await prisma.referralLetter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReferralLetterFindFirstOrThrowArgs>(args?: SelectSubset<T, ReferralLetterFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReferralLetterClient<$Result.GetResult<Prisma.$ReferralLetterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReferralLetters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralLetterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReferralLetters
     * const referralLetters = await prisma.referralLetter.findMany()
     * 
     * // Get first 10 ReferralLetters
     * const referralLetters = await prisma.referralLetter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const referralLetterWithIdOnly = await prisma.referralLetter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReferralLetterFindManyArgs>(args?: SelectSubset<T, ReferralLetterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralLetterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReferralLetter.
     * @param {ReferralLetterCreateArgs} args - Arguments to create a ReferralLetter.
     * @example
     * // Create one ReferralLetter
     * const ReferralLetter = await prisma.referralLetter.create({
     *   data: {
     *     // ... data to create a ReferralLetter
     *   }
     * })
     * 
     */
    create<T extends ReferralLetterCreateArgs>(args: SelectSubset<T, ReferralLetterCreateArgs<ExtArgs>>): Prisma__ReferralLetterClient<$Result.GetResult<Prisma.$ReferralLetterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReferralLetters.
     * @param {ReferralLetterCreateManyArgs} args - Arguments to create many ReferralLetters.
     * @example
     * // Create many ReferralLetters
     * const referralLetter = await prisma.referralLetter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReferralLetterCreateManyArgs>(args?: SelectSubset<T, ReferralLetterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReferralLetters and returns the data saved in the database.
     * @param {ReferralLetterCreateManyAndReturnArgs} args - Arguments to create many ReferralLetters.
     * @example
     * // Create many ReferralLetters
     * const referralLetter = await prisma.referralLetter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReferralLetters and only return the `id`
     * const referralLetterWithIdOnly = await prisma.referralLetter.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReferralLetterCreateManyAndReturnArgs>(args?: SelectSubset<T, ReferralLetterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralLetterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReferralLetter.
     * @param {ReferralLetterDeleteArgs} args - Arguments to delete one ReferralLetter.
     * @example
     * // Delete one ReferralLetter
     * const ReferralLetter = await prisma.referralLetter.delete({
     *   where: {
     *     // ... filter to delete one ReferralLetter
     *   }
     * })
     * 
     */
    delete<T extends ReferralLetterDeleteArgs>(args: SelectSubset<T, ReferralLetterDeleteArgs<ExtArgs>>): Prisma__ReferralLetterClient<$Result.GetResult<Prisma.$ReferralLetterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReferralLetter.
     * @param {ReferralLetterUpdateArgs} args - Arguments to update one ReferralLetter.
     * @example
     * // Update one ReferralLetter
     * const referralLetter = await prisma.referralLetter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReferralLetterUpdateArgs>(args: SelectSubset<T, ReferralLetterUpdateArgs<ExtArgs>>): Prisma__ReferralLetterClient<$Result.GetResult<Prisma.$ReferralLetterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReferralLetters.
     * @param {ReferralLetterDeleteManyArgs} args - Arguments to filter ReferralLetters to delete.
     * @example
     * // Delete a few ReferralLetters
     * const { count } = await prisma.referralLetter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReferralLetterDeleteManyArgs>(args?: SelectSubset<T, ReferralLetterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReferralLetters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralLetterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReferralLetters
     * const referralLetter = await prisma.referralLetter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReferralLetterUpdateManyArgs>(args: SelectSubset<T, ReferralLetterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReferralLetters and returns the data updated in the database.
     * @param {ReferralLetterUpdateManyAndReturnArgs} args - Arguments to update many ReferralLetters.
     * @example
     * // Update many ReferralLetters
     * const referralLetter = await prisma.referralLetter.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReferralLetters and only return the `id`
     * const referralLetterWithIdOnly = await prisma.referralLetter.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReferralLetterUpdateManyAndReturnArgs>(args: SelectSubset<T, ReferralLetterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralLetterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReferralLetter.
     * @param {ReferralLetterUpsertArgs} args - Arguments to update or create a ReferralLetter.
     * @example
     * // Update or create a ReferralLetter
     * const referralLetter = await prisma.referralLetter.upsert({
     *   create: {
     *     // ... data to create a ReferralLetter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReferralLetter we want to update
     *   }
     * })
     */
    upsert<T extends ReferralLetterUpsertArgs>(args: SelectSubset<T, ReferralLetterUpsertArgs<ExtArgs>>): Prisma__ReferralLetterClient<$Result.GetResult<Prisma.$ReferralLetterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReferralLetters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralLetterCountArgs} args - Arguments to filter ReferralLetters to count.
     * @example
     * // Count the number of ReferralLetters
     * const count = await prisma.referralLetter.count({
     *   where: {
     *     // ... the filter for the ReferralLetters we want to count
     *   }
     * })
    **/
    count<T extends ReferralLetterCountArgs>(
      args?: Subset<T, ReferralLetterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReferralLetterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReferralLetter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralLetterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReferralLetterAggregateArgs>(args: Subset<T, ReferralLetterAggregateArgs>): Prisma.PrismaPromise<GetReferralLetterAggregateType<T>>

    /**
     * Group by ReferralLetter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralLetterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReferralLetterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReferralLetterGroupByArgs['orderBy'] }
        : { orderBy?: ReferralLetterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReferralLetterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReferralLetterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReferralLetter model
   */
  readonly fields: ReferralLetterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReferralLetter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReferralLetterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReferralLetter model
   */ 
  interface ReferralLetterFieldRefs {
    readonly id: FieldRef<"ReferralLetter", 'Int'>
    readonly patientId: FieldRef<"ReferralLetter", 'Int'>
    readonly nameOfThePatient: FieldRef<"ReferralLetter", 'String'>
    readonly consultant_speciality: FieldRef<"ReferralLetter", 'String'>
    readonly consultant_name: FieldRef<"ReferralLetter", 'String'>
    readonly condition1: FieldRef<"ReferralLetter", 'String'>
    readonly condition2: FieldRef<"ReferralLetter", 'String'>
    readonly condition3: FieldRef<"ReferralLetter", 'String'>
    readonly investigations: FieldRef<"ReferralLetter", 'String'>
    readonly ageOfThePatient: FieldRef<"ReferralLetter", 'Int'>
    readonly reportDate: FieldRef<"ReferralLetter", 'DateTime'>
    readonly time: FieldRef<"ReferralLetter", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReferralLetter findUnique
   */
  export type ReferralLetterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralLetter
     */
    select?: ReferralLetterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferralLetter
     */
    omit?: ReferralLetterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralLetterInclude<ExtArgs> | null
    /**
     * Filter, which ReferralLetter to fetch.
     */
    where: ReferralLetterWhereUniqueInput
  }

  /**
   * ReferralLetter findUniqueOrThrow
   */
  export type ReferralLetterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralLetter
     */
    select?: ReferralLetterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferralLetter
     */
    omit?: ReferralLetterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralLetterInclude<ExtArgs> | null
    /**
     * Filter, which ReferralLetter to fetch.
     */
    where: ReferralLetterWhereUniqueInput
  }

  /**
   * ReferralLetter findFirst
   */
  export type ReferralLetterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralLetter
     */
    select?: ReferralLetterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferralLetter
     */
    omit?: ReferralLetterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralLetterInclude<ExtArgs> | null
    /**
     * Filter, which ReferralLetter to fetch.
     */
    where?: ReferralLetterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferralLetters to fetch.
     */
    orderBy?: ReferralLetterOrderByWithRelationInput | ReferralLetterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReferralLetters.
     */
    cursor?: ReferralLetterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferralLetters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferralLetters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReferralLetters.
     */
    distinct?: ReferralLetterScalarFieldEnum | ReferralLetterScalarFieldEnum[]
  }

  /**
   * ReferralLetter findFirstOrThrow
   */
  export type ReferralLetterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralLetter
     */
    select?: ReferralLetterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferralLetter
     */
    omit?: ReferralLetterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralLetterInclude<ExtArgs> | null
    /**
     * Filter, which ReferralLetter to fetch.
     */
    where?: ReferralLetterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferralLetters to fetch.
     */
    orderBy?: ReferralLetterOrderByWithRelationInput | ReferralLetterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReferralLetters.
     */
    cursor?: ReferralLetterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferralLetters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferralLetters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReferralLetters.
     */
    distinct?: ReferralLetterScalarFieldEnum | ReferralLetterScalarFieldEnum[]
  }

  /**
   * ReferralLetter findMany
   */
  export type ReferralLetterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralLetter
     */
    select?: ReferralLetterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferralLetter
     */
    omit?: ReferralLetterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralLetterInclude<ExtArgs> | null
    /**
     * Filter, which ReferralLetters to fetch.
     */
    where?: ReferralLetterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferralLetters to fetch.
     */
    orderBy?: ReferralLetterOrderByWithRelationInput | ReferralLetterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReferralLetters.
     */
    cursor?: ReferralLetterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferralLetters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferralLetters.
     */
    skip?: number
    distinct?: ReferralLetterScalarFieldEnum | ReferralLetterScalarFieldEnum[]
  }

  /**
   * ReferralLetter create
   */
  export type ReferralLetterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralLetter
     */
    select?: ReferralLetterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferralLetter
     */
    omit?: ReferralLetterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralLetterInclude<ExtArgs> | null
    /**
     * The data needed to create a ReferralLetter.
     */
    data: XOR<ReferralLetterCreateInput, ReferralLetterUncheckedCreateInput>
  }

  /**
   * ReferralLetter createMany
   */
  export type ReferralLetterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReferralLetters.
     */
    data: ReferralLetterCreateManyInput | ReferralLetterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReferralLetter createManyAndReturn
   */
  export type ReferralLetterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralLetter
     */
    select?: ReferralLetterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReferralLetter
     */
    omit?: ReferralLetterOmit<ExtArgs> | null
    /**
     * The data used to create many ReferralLetters.
     */
    data: ReferralLetterCreateManyInput | ReferralLetterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralLetterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReferralLetter update
   */
  export type ReferralLetterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralLetter
     */
    select?: ReferralLetterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferralLetter
     */
    omit?: ReferralLetterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralLetterInclude<ExtArgs> | null
    /**
     * The data needed to update a ReferralLetter.
     */
    data: XOR<ReferralLetterUpdateInput, ReferralLetterUncheckedUpdateInput>
    /**
     * Choose, which ReferralLetter to update.
     */
    where: ReferralLetterWhereUniqueInput
  }

  /**
   * ReferralLetter updateMany
   */
  export type ReferralLetterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReferralLetters.
     */
    data: XOR<ReferralLetterUpdateManyMutationInput, ReferralLetterUncheckedUpdateManyInput>
    /**
     * Filter which ReferralLetters to update
     */
    where?: ReferralLetterWhereInput
    /**
     * Limit how many ReferralLetters to update.
     */
    limit?: number
  }

  /**
   * ReferralLetter updateManyAndReturn
   */
  export type ReferralLetterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralLetter
     */
    select?: ReferralLetterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReferralLetter
     */
    omit?: ReferralLetterOmit<ExtArgs> | null
    /**
     * The data used to update ReferralLetters.
     */
    data: XOR<ReferralLetterUpdateManyMutationInput, ReferralLetterUncheckedUpdateManyInput>
    /**
     * Filter which ReferralLetters to update
     */
    where?: ReferralLetterWhereInput
    /**
     * Limit how many ReferralLetters to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralLetterIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReferralLetter upsert
   */
  export type ReferralLetterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralLetter
     */
    select?: ReferralLetterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferralLetter
     */
    omit?: ReferralLetterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralLetterInclude<ExtArgs> | null
    /**
     * The filter to search for the ReferralLetter to update in case it exists.
     */
    where: ReferralLetterWhereUniqueInput
    /**
     * In case the ReferralLetter found by the `where` argument doesn't exist, create a new ReferralLetter with this data.
     */
    create: XOR<ReferralLetterCreateInput, ReferralLetterUncheckedCreateInput>
    /**
     * In case the ReferralLetter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReferralLetterUpdateInput, ReferralLetterUncheckedUpdateInput>
  }

  /**
   * ReferralLetter delete
   */
  export type ReferralLetterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralLetter
     */
    select?: ReferralLetterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferralLetter
     */
    omit?: ReferralLetterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralLetterInclude<ExtArgs> | null
    /**
     * Filter which ReferralLetter to delete.
     */
    where: ReferralLetterWhereUniqueInput
  }

  /**
   * ReferralLetter deleteMany
   */
  export type ReferralLetterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReferralLetters to delete
     */
    where?: ReferralLetterWhereInput
    /**
     * Limit how many ReferralLetters to delete.
     */
    limit?: number
  }

  /**
   * ReferralLetter without action
   */
  export type ReferralLetterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralLetter
     */
    select?: ReferralLetterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReferralLetter
     */
    omit?: ReferralLetterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralLetterInclude<ExtArgs> | null
  }


  /**
   * Model OffRecordMeds
   */

  export type AggregateOffRecordMeds = {
    _count: OffRecordMedsCountAggregateOutputType | null
    _avg: OffRecordMedsAvgAggregateOutputType | null
    _sum: OffRecordMedsSumAggregateOutputType | null
    _min: OffRecordMedsMinAggregateOutputType | null
    _max: OffRecordMedsMaxAggregateOutputType | null
  }

  export type OffRecordMedsAvgAggregateOutputType = {
    id: number | null
    prescriptionId: number | null
  }

  export type OffRecordMedsSumAggregateOutputType = {
    id: number | null
    prescriptionId: number | null
  }

  export type OffRecordMedsMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    prescriptionId: number | null
  }

  export type OffRecordMedsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    prescriptionId: number | null
  }

  export type OffRecordMedsCountAggregateOutputType = {
    id: number
    name: number
    description: number
    prescriptionId: number
    _all: number
  }


  export type OffRecordMedsAvgAggregateInputType = {
    id?: true
    prescriptionId?: true
  }

  export type OffRecordMedsSumAggregateInputType = {
    id?: true
    prescriptionId?: true
  }

  export type OffRecordMedsMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    prescriptionId?: true
  }

  export type OffRecordMedsMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    prescriptionId?: true
  }

  export type OffRecordMedsCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    prescriptionId?: true
    _all?: true
  }

  export type OffRecordMedsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OffRecordMeds to aggregate.
     */
    where?: OffRecordMedsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OffRecordMeds to fetch.
     */
    orderBy?: OffRecordMedsOrderByWithRelationInput | OffRecordMedsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OffRecordMedsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OffRecordMeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OffRecordMeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OffRecordMeds
    **/
    _count?: true | OffRecordMedsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OffRecordMedsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OffRecordMedsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OffRecordMedsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OffRecordMedsMaxAggregateInputType
  }

  export type GetOffRecordMedsAggregateType<T extends OffRecordMedsAggregateArgs> = {
        [P in keyof T & keyof AggregateOffRecordMeds]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOffRecordMeds[P]>
      : GetScalarType<T[P], AggregateOffRecordMeds[P]>
  }




  export type OffRecordMedsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OffRecordMedsWhereInput
    orderBy?: OffRecordMedsOrderByWithAggregationInput | OffRecordMedsOrderByWithAggregationInput[]
    by: OffRecordMedsScalarFieldEnum[] | OffRecordMedsScalarFieldEnum
    having?: OffRecordMedsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OffRecordMedsCountAggregateInputType | true
    _avg?: OffRecordMedsAvgAggregateInputType
    _sum?: OffRecordMedsSumAggregateInputType
    _min?: OffRecordMedsMinAggregateInputType
    _max?: OffRecordMedsMaxAggregateInputType
  }

  export type OffRecordMedsGroupByOutputType = {
    id: number
    name: string
    description: string | null
    prescriptionId: number
    _count: OffRecordMedsCountAggregateOutputType | null
    _avg: OffRecordMedsAvgAggregateOutputType | null
    _sum: OffRecordMedsSumAggregateOutputType | null
    _min: OffRecordMedsMinAggregateOutputType | null
    _max: OffRecordMedsMaxAggregateOutputType | null
  }

  type GetOffRecordMedsGroupByPayload<T extends OffRecordMedsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OffRecordMedsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OffRecordMedsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OffRecordMedsGroupByOutputType[P]>
            : GetScalarType<T[P], OffRecordMedsGroupByOutputType[P]>
        }
      >
    >


  export type OffRecordMedsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    prescriptionId?: boolean
    prescription?: boolean | PrescriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["offRecordMeds"]>

  export type OffRecordMedsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    prescriptionId?: boolean
    prescription?: boolean | PrescriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["offRecordMeds"]>

  export type OffRecordMedsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    prescriptionId?: boolean
    prescription?: boolean | PrescriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["offRecordMeds"]>

  export type OffRecordMedsSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    prescriptionId?: boolean
  }

  export type OffRecordMedsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "prescriptionId", ExtArgs["result"]["offRecordMeds"]>
  export type OffRecordMedsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prescription?: boolean | PrescriptionDefaultArgs<ExtArgs>
  }
  export type OffRecordMedsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prescription?: boolean | PrescriptionDefaultArgs<ExtArgs>
  }
  export type OffRecordMedsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prescription?: boolean | PrescriptionDefaultArgs<ExtArgs>
  }

  export type $OffRecordMedsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OffRecordMeds"
    objects: {
      prescription: Prisma.$PrescriptionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      prescriptionId: number
    }, ExtArgs["result"]["offRecordMeds"]>
    composites: {}
  }

  type OffRecordMedsGetPayload<S extends boolean | null | undefined | OffRecordMedsDefaultArgs> = $Result.GetResult<Prisma.$OffRecordMedsPayload, S>

  type OffRecordMedsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OffRecordMedsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OffRecordMedsCountAggregateInputType | true
    }

  export interface OffRecordMedsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OffRecordMeds'], meta: { name: 'OffRecordMeds' } }
    /**
     * Find zero or one OffRecordMeds that matches the filter.
     * @param {OffRecordMedsFindUniqueArgs} args - Arguments to find a OffRecordMeds
     * @example
     * // Get one OffRecordMeds
     * const offRecordMeds = await prisma.offRecordMeds.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OffRecordMedsFindUniqueArgs>(args: SelectSubset<T, OffRecordMedsFindUniqueArgs<ExtArgs>>): Prisma__OffRecordMedsClient<$Result.GetResult<Prisma.$OffRecordMedsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OffRecordMeds that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OffRecordMedsFindUniqueOrThrowArgs} args - Arguments to find a OffRecordMeds
     * @example
     * // Get one OffRecordMeds
     * const offRecordMeds = await prisma.offRecordMeds.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OffRecordMedsFindUniqueOrThrowArgs>(args: SelectSubset<T, OffRecordMedsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OffRecordMedsClient<$Result.GetResult<Prisma.$OffRecordMedsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OffRecordMeds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffRecordMedsFindFirstArgs} args - Arguments to find a OffRecordMeds
     * @example
     * // Get one OffRecordMeds
     * const offRecordMeds = await prisma.offRecordMeds.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OffRecordMedsFindFirstArgs>(args?: SelectSubset<T, OffRecordMedsFindFirstArgs<ExtArgs>>): Prisma__OffRecordMedsClient<$Result.GetResult<Prisma.$OffRecordMedsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OffRecordMeds that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffRecordMedsFindFirstOrThrowArgs} args - Arguments to find a OffRecordMeds
     * @example
     * // Get one OffRecordMeds
     * const offRecordMeds = await prisma.offRecordMeds.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OffRecordMedsFindFirstOrThrowArgs>(args?: SelectSubset<T, OffRecordMedsFindFirstOrThrowArgs<ExtArgs>>): Prisma__OffRecordMedsClient<$Result.GetResult<Prisma.$OffRecordMedsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OffRecordMeds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffRecordMedsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OffRecordMeds
     * const offRecordMeds = await prisma.offRecordMeds.findMany()
     * 
     * // Get first 10 OffRecordMeds
     * const offRecordMeds = await prisma.offRecordMeds.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const offRecordMedsWithIdOnly = await prisma.offRecordMeds.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OffRecordMedsFindManyArgs>(args?: SelectSubset<T, OffRecordMedsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OffRecordMedsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OffRecordMeds.
     * @param {OffRecordMedsCreateArgs} args - Arguments to create a OffRecordMeds.
     * @example
     * // Create one OffRecordMeds
     * const OffRecordMeds = await prisma.offRecordMeds.create({
     *   data: {
     *     // ... data to create a OffRecordMeds
     *   }
     * })
     * 
     */
    create<T extends OffRecordMedsCreateArgs>(args: SelectSubset<T, OffRecordMedsCreateArgs<ExtArgs>>): Prisma__OffRecordMedsClient<$Result.GetResult<Prisma.$OffRecordMedsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OffRecordMeds.
     * @param {OffRecordMedsCreateManyArgs} args - Arguments to create many OffRecordMeds.
     * @example
     * // Create many OffRecordMeds
     * const offRecordMeds = await prisma.offRecordMeds.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OffRecordMedsCreateManyArgs>(args?: SelectSubset<T, OffRecordMedsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OffRecordMeds and returns the data saved in the database.
     * @param {OffRecordMedsCreateManyAndReturnArgs} args - Arguments to create many OffRecordMeds.
     * @example
     * // Create many OffRecordMeds
     * const offRecordMeds = await prisma.offRecordMeds.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OffRecordMeds and only return the `id`
     * const offRecordMedsWithIdOnly = await prisma.offRecordMeds.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OffRecordMedsCreateManyAndReturnArgs>(args?: SelectSubset<T, OffRecordMedsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OffRecordMedsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OffRecordMeds.
     * @param {OffRecordMedsDeleteArgs} args - Arguments to delete one OffRecordMeds.
     * @example
     * // Delete one OffRecordMeds
     * const OffRecordMeds = await prisma.offRecordMeds.delete({
     *   where: {
     *     // ... filter to delete one OffRecordMeds
     *   }
     * })
     * 
     */
    delete<T extends OffRecordMedsDeleteArgs>(args: SelectSubset<T, OffRecordMedsDeleteArgs<ExtArgs>>): Prisma__OffRecordMedsClient<$Result.GetResult<Prisma.$OffRecordMedsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OffRecordMeds.
     * @param {OffRecordMedsUpdateArgs} args - Arguments to update one OffRecordMeds.
     * @example
     * // Update one OffRecordMeds
     * const offRecordMeds = await prisma.offRecordMeds.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OffRecordMedsUpdateArgs>(args: SelectSubset<T, OffRecordMedsUpdateArgs<ExtArgs>>): Prisma__OffRecordMedsClient<$Result.GetResult<Prisma.$OffRecordMedsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OffRecordMeds.
     * @param {OffRecordMedsDeleteManyArgs} args - Arguments to filter OffRecordMeds to delete.
     * @example
     * // Delete a few OffRecordMeds
     * const { count } = await prisma.offRecordMeds.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OffRecordMedsDeleteManyArgs>(args?: SelectSubset<T, OffRecordMedsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OffRecordMeds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffRecordMedsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OffRecordMeds
     * const offRecordMeds = await prisma.offRecordMeds.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OffRecordMedsUpdateManyArgs>(args: SelectSubset<T, OffRecordMedsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OffRecordMeds and returns the data updated in the database.
     * @param {OffRecordMedsUpdateManyAndReturnArgs} args - Arguments to update many OffRecordMeds.
     * @example
     * // Update many OffRecordMeds
     * const offRecordMeds = await prisma.offRecordMeds.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OffRecordMeds and only return the `id`
     * const offRecordMedsWithIdOnly = await prisma.offRecordMeds.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OffRecordMedsUpdateManyAndReturnArgs>(args: SelectSubset<T, OffRecordMedsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OffRecordMedsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OffRecordMeds.
     * @param {OffRecordMedsUpsertArgs} args - Arguments to update or create a OffRecordMeds.
     * @example
     * // Update or create a OffRecordMeds
     * const offRecordMeds = await prisma.offRecordMeds.upsert({
     *   create: {
     *     // ... data to create a OffRecordMeds
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OffRecordMeds we want to update
     *   }
     * })
     */
    upsert<T extends OffRecordMedsUpsertArgs>(args: SelectSubset<T, OffRecordMedsUpsertArgs<ExtArgs>>): Prisma__OffRecordMedsClient<$Result.GetResult<Prisma.$OffRecordMedsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OffRecordMeds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffRecordMedsCountArgs} args - Arguments to filter OffRecordMeds to count.
     * @example
     * // Count the number of OffRecordMeds
     * const count = await prisma.offRecordMeds.count({
     *   where: {
     *     // ... the filter for the OffRecordMeds we want to count
     *   }
     * })
    **/
    count<T extends OffRecordMedsCountArgs>(
      args?: Subset<T, OffRecordMedsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OffRecordMedsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OffRecordMeds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffRecordMedsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OffRecordMedsAggregateArgs>(args: Subset<T, OffRecordMedsAggregateArgs>): Prisma.PrismaPromise<GetOffRecordMedsAggregateType<T>>

    /**
     * Group by OffRecordMeds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffRecordMedsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OffRecordMedsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OffRecordMedsGroupByArgs['orderBy'] }
        : { orderBy?: OffRecordMedsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OffRecordMedsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOffRecordMedsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OffRecordMeds model
   */
  readonly fields: OffRecordMedsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OffRecordMeds.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OffRecordMedsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    prescription<T extends PrescriptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PrescriptionDefaultArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OffRecordMeds model
   */ 
  interface OffRecordMedsFieldRefs {
    readonly id: FieldRef<"OffRecordMeds", 'Int'>
    readonly name: FieldRef<"OffRecordMeds", 'String'>
    readonly description: FieldRef<"OffRecordMeds", 'String'>
    readonly prescriptionId: FieldRef<"OffRecordMeds", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * OffRecordMeds findUnique
   */
  export type OffRecordMedsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OffRecordMeds
     */
    select?: OffRecordMedsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OffRecordMeds
     */
    omit?: OffRecordMedsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OffRecordMedsInclude<ExtArgs> | null
    /**
     * Filter, which OffRecordMeds to fetch.
     */
    where: OffRecordMedsWhereUniqueInput
  }

  /**
   * OffRecordMeds findUniqueOrThrow
   */
  export type OffRecordMedsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OffRecordMeds
     */
    select?: OffRecordMedsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OffRecordMeds
     */
    omit?: OffRecordMedsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OffRecordMedsInclude<ExtArgs> | null
    /**
     * Filter, which OffRecordMeds to fetch.
     */
    where: OffRecordMedsWhereUniqueInput
  }

  /**
   * OffRecordMeds findFirst
   */
  export type OffRecordMedsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OffRecordMeds
     */
    select?: OffRecordMedsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OffRecordMeds
     */
    omit?: OffRecordMedsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OffRecordMedsInclude<ExtArgs> | null
    /**
     * Filter, which OffRecordMeds to fetch.
     */
    where?: OffRecordMedsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OffRecordMeds to fetch.
     */
    orderBy?: OffRecordMedsOrderByWithRelationInput | OffRecordMedsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OffRecordMeds.
     */
    cursor?: OffRecordMedsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OffRecordMeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OffRecordMeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OffRecordMeds.
     */
    distinct?: OffRecordMedsScalarFieldEnum | OffRecordMedsScalarFieldEnum[]
  }

  /**
   * OffRecordMeds findFirstOrThrow
   */
  export type OffRecordMedsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OffRecordMeds
     */
    select?: OffRecordMedsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OffRecordMeds
     */
    omit?: OffRecordMedsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OffRecordMedsInclude<ExtArgs> | null
    /**
     * Filter, which OffRecordMeds to fetch.
     */
    where?: OffRecordMedsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OffRecordMeds to fetch.
     */
    orderBy?: OffRecordMedsOrderByWithRelationInput | OffRecordMedsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OffRecordMeds.
     */
    cursor?: OffRecordMedsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OffRecordMeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OffRecordMeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OffRecordMeds.
     */
    distinct?: OffRecordMedsScalarFieldEnum | OffRecordMedsScalarFieldEnum[]
  }

  /**
   * OffRecordMeds findMany
   */
  export type OffRecordMedsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OffRecordMeds
     */
    select?: OffRecordMedsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OffRecordMeds
     */
    omit?: OffRecordMedsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OffRecordMedsInclude<ExtArgs> | null
    /**
     * Filter, which OffRecordMeds to fetch.
     */
    where?: OffRecordMedsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OffRecordMeds to fetch.
     */
    orderBy?: OffRecordMedsOrderByWithRelationInput | OffRecordMedsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OffRecordMeds.
     */
    cursor?: OffRecordMedsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OffRecordMeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OffRecordMeds.
     */
    skip?: number
    distinct?: OffRecordMedsScalarFieldEnum | OffRecordMedsScalarFieldEnum[]
  }

  /**
   * OffRecordMeds create
   */
  export type OffRecordMedsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OffRecordMeds
     */
    select?: OffRecordMedsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OffRecordMeds
     */
    omit?: OffRecordMedsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OffRecordMedsInclude<ExtArgs> | null
    /**
     * The data needed to create a OffRecordMeds.
     */
    data: XOR<OffRecordMedsCreateInput, OffRecordMedsUncheckedCreateInput>
  }

  /**
   * OffRecordMeds createMany
   */
  export type OffRecordMedsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OffRecordMeds.
     */
    data: OffRecordMedsCreateManyInput | OffRecordMedsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OffRecordMeds createManyAndReturn
   */
  export type OffRecordMedsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OffRecordMeds
     */
    select?: OffRecordMedsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OffRecordMeds
     */
    omit?: OffRecordMedsOmit<ExtArgs> | null
    /**
     * The data used to create many OffRecordMeds.
     */
    data: OffRecordMedsCreateManyInput | OffRecordMedsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OffRecordMedsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OffRecordMeds update
   */
  export type OffRecordMedsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OffRecordMeds
     */
    select?: OffRecordMedsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OffRecordMeds
     */
    omit?: OffRecordMedsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OffRecordMedsInclude<ExtArgs> | null
    /**
     * The data needed to update a OffRecordMeds.
     */
    data: XOR<OffRecordMedsUpdateInput, OffRecordMedsUncheckedUpdateInput>
    /**
     * Choose, which OffRecordMeds to update.
     */
    where: OffRecordMedsWhereUniqueInput
  }

  /**
   * OffRecordMeds updateMany
   */
  export type OffRecordMedsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OffRecordMeds.
     */
    data: XOR<OffRecordMedsUpdateManyMutationInput, OffRecordMedsUncheckedUpdateManyInput>
    /**
     * Filter which OffRecordMeds to update
     */
    where?: OffRecordMedsWhereInput
    /**
     * Limit how many OffRecordMeds to update.
     */
    limit?: number
  }

  /**
   * OffRecordMeds updateManyAndReturn
   */
  export type OffRecordMedsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OffRecordMeds
     */
    select?: OffRecordMedsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OffRecordMeds
     */
    omit?: OffRecordMedsOmit<ExtArgs> | null
    /**
     * The data used to update OffRecordMeds.
     */
    data: XOR<OffRecordMedsUpdateManyMutationInput, OffRecordMedsUncheckedUpdateManyInput>
    /**
     * Filter which OffRecordMeds to update
     */
    where?: OffRecordMedsWhereInput
    /**
     * Limit how many OffRecordMeds to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OffRecordMedsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OffRecordMeds upsert
   */
  export type OffRecordMedsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OffRecordMeds
     */
    select?: OffRecordMedsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OffRecordMeds
     */
    omit?: OffRecordMedsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OffRecordMedsInclude<ExtArgs> | null
    /**
     * The filter to search for the OffRecordMeds to update in case it exists.
     */
    where: OffRecordMedsWhereUniqueInput
    /**
     * In case the OffRecordMeds found by the `where` argument doesn't exist, create a new OffRecordMeds with this data.
     */
    create: XOR<OffRecordMedsCreateInput, OffRecordMedsUncheckedCreateInput>
    /**
     * In case the OffRecordMeds was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OffRecordMedsUpdateInput, OffRecordMedsUncheckedUpdateInput>
  }

  /**
   * OffRecordMeds delete
   */
  export type OffRecordMedsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OffRecordMeds
     */
    select?: OffRecordMedsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OffRecordMeds
     */
    omit?: OffRecordMedsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OffRecordMedsInclude<ExtArgs> | null
    /**
     * Filter which OffRecordMeds to delete.
     */
    where: OffRecordMedsWhereUniqueInput
  }

  /**
   * OffRecordMeds deleteMany
   */
  export type OffRecordMedsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OffRecordMeds to delete
     */
    where?: OffRecordMedsWhereInput
    /**
     * Limit how many OffRecordMeds to delete.
     */
    limit?: number
  }

  /**
   * OffRecordMeds without action
   */
  export type OffRecordMedsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OffRecordMeds
     */
    select?: OffRecordMedsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OffRecordMeds
     */
    omit?: OffRecordMedsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OffRecordMedsInclude<ExtArgs> | null
  }


  /**
   * Model Issue
   */

  export type AggregateIssue = {
    _count: IssueCountAggregateOutputType | null
    _avg: IssueAvgAggregateOutputType | null
    _sum: IssueSumAggregateOutputType | null
    _min: IssueMinAggregateOutputType | null
    _max: IssueMaxAggregateOutputType | null
  }

  export type IssueAvgAggregateOutputType = {
    id: number | null
    prescriptionId: number | null
    batchId: number | null
    drugId: number | null
    brandId: number | null
    quantity: number | null
    dose: number | null
    unitConcentrationId: number | null
  }

  export type IssueSumAggregateOutputType = {
    id: number | null
    prescriptionId: number | null
    batchId: number | null
    drugId: number | null
    brandId: number | null
    quantity: number | null
    dose: number | null
    unitConcentrationId: number | null
  }

  export type IssueMinAggregateOutputType = {
    id: number | null
    prescriptionId: number | null
    batchId: number | null
    drugId: number | null
    brandId: number | null
    strategy: $Enums.IssuingStrategy | null
    quantity: number | null
    dose: number | null
    details: string | null
    meal: $Enums.MEAL | null
    type: $Enums.DrugType | null
    unitConcentrationId: number | null
  }

  export type IssueMaxAggregateOutputType = {
    id: number | null
    prescriptionId: number | null
    batchId: number | null
    drugId: number | null
    brandId: number | null
    strategy: $Enums.IssuingStrategy | null
    quantity: number | null
    dose: number | null
    details: string | null
    meal: $Enums.MEAL | null
    type: $Enums.DrugType | null
    unitConcentrationId: number | null
  }

  export type IssueCountAggregateOutputType = {
    id: number
    prescriptionId: number
    batchId: number
    drugId: number
    brandId: number
    strategy: number
    quantity: number
    dose: number
    details: number
    meal: number
    type: number
    unitConcentrationId: number
    _all: number
  }


  export type IssueAvgAggregateInputType = {
    id?: true
    prescriptionId?: true
    batchId?: true
    drugId?: true
    brandId?: true
    quantity?: true
    dose?: true
    unitConcentrationId?: true
  }

  export type IssueSumAggregateInputType = {
    id?: true
    prescriptionId?: true
    batchId?: true
    drugId?: true
    brandId?: true
    quantity?: true
    dose?: true
    unitConcentrationId?: true
  }

  export type IssueMinAggregateInputType = {
    id?: true
    prescriptionId?: true
    batchId?: true
    drugId?: true
    brandId?: true
    strategy?: true
    quantity?: true
    dose?: true
    details?: true
    meal?: true
    type?: true
    unitConcentrationId?: true
  }

  export type IssueMaxAggregateInputType = {
    id?: true
    prescriptionId?: true
    batchId?: true
    drugId?: true
    brandId?: true
    strategy?: true
    quantity?: true
    dose?: true
    details?: true
    meal?: true
    type?: true
    unitConcentrationId?: true
  }

  export type IssueCountAggregateInputType = {
    id?: true
    prescriptionId?: true
    batchId?: true
    drugId?: true
    brandId?: true
    strategy?: true
    quantity?: true
    dose?: true
    details?: true
    meal?: true
    type?: true
    unitConcentrationId?: true
    _all?: true
  }

  export type IssueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Issue to aggregate.
     */
    where?: IssueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Issues to fetch.
     */
    orderBy?: IssueOrderByWithRelationInput | IssueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IssueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Issues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Issues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Issues
    **/
    _count?: true | IssueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IssueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IssueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IssueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IssueMaxAggregateInputType
  }

  export type GetIssueAggregateType<T extends IssueAggregateArgs> = {
        [P in keyof T & keyof AggregateIssue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIssue[P]>
      : GetScalarType<T[P], AggregateIssue[P]>
  }




  export type IssueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IssueWhereInput
    orderBy?: IssueOrderByWithAggregationInput | IssueOrderByWithAggregationInput[]
    by: IssueScalarFieldEnum[] | IssueScalarFieldEnum
    having?: IssueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IssueCountAggregateInputType | true
    _avg?: IssueAvgAggregateInputType
    _sum?: IssueSumAggregateInputType
    _min?: IssueMinAggregateInputType
    _max?: IssueMaxAggregateInputType
  }

  export type IssueGroupByOutputType = {
    id: number
    prescriptionId: number
    batchId: number | null
    drugId: number
    brandId: number
    strategy: $Enums.IssuingStrategy
    quantity: number
    dose: number
    details: string | null
    meal: $Enums.MEAL | null
    type: $Enums.DrugType
    unitConcentrationId: number
    _count: IssueCountAggregateOutputType | null
    _avg: IssueAvgAggregateOutputType | null
    _sum: IssueSumAggregateOutputType | null
    _min: IssueMinAggregateOutputType | null
    _max: IssueMaxAggregateOutputType | null
  }

  type GetIssueGroupByPayload<T extends IssueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IssueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IssueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IssueGroupByOutputType[P]>
            : GetScalarType<T[P], IssueGroupByOutputType[P]>
        }
      >
    >


  export type IssueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prescriptionId?: boolean
    batchId?: boolean
    drugId?: boolean
    brandId?: boolean
    strategy?: boolean
    quantity?: boolean
    dose?: boolean
    details?: boolean
    meal?: boolean
    type?: boolean
    unitConcentrationId?: boolean
    batch?: boolean | Issue$batchArgs<ExtArgs>
    brand?: boolean | DrugBrandDefaultArgs<ExtArgs>
    drug?: boolean | DrugDefaultArgs<ExtArgs>
    prescription?: boolean | PrescriptionDefaultArgs<ExtArgs>
    unitConcentration?: boolean | UnitConcentrationDefaultArgs<ExtArgs>
    stratergyHistory?: boolean | Issue$stratergyHistoryArgs<ExtArgs>
    _count?: boolean | IssueCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["issue"]>

  export type IssueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prescriptionId?: boolean
    batchId?: boolean
    drugId?: boolean
    brandId?: boolean
    strategy?: boolean
    quantity?: boolean
    dose?: boolean
    details?: boolean
    meal?: boolean
    type?: boolean
    unitConcentrationId?: boolean
    batch?: boolean | Issue$batchArgs<ExtArgs>
    brand?: boolean | DrugBrandDefaultArgs<ExtArgs>
    drug?: boolean | DrugDefaultArgs<ExtArgs>
    prescription?: boolean | PrescriptionDefaultArgs<ExtArgs>
    unitConcentration?: boolean | UnitConcentrationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["issue"]>

  export type IssueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prescriptionId?: boolean
    batchId?: boolean
    drugId?: boolean
    brandId?: boolean
    strategy?: boolean
    quantity?: boolean
    dose?: boolean
    details?: boolean
    meal?: boolean
    type?: boolean
    unitConcentrationId?: boolean
    batch?: boolean | Issue$batchArgs<ExtArgs>
    brand?: boolean | DrugBrandDefaultArgs<ExtArgs>
    drug?: boolean | DrugDefaultArgs<ExtArgs>
    prescription?: boolean | PrescriptionDefaultArgs<ExtArgs>
    unitConcentration?: boolean | UnitConcentrationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["issue"]>

  export type IssueSelectScalar = {
    id?: boolean
    prescriptionId?: boolean
    batchId?: boolean
    drugId?: boolean
    brandId?: boolean
    strategy?: boolean
    quantity?: boolean
    dose?: boolean
    details?: boolean
    meal?: boolean
    type?: boolean
    unitConcentrationId?: boolean
  }

  export type IssueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "prescriptionId" | "batchId" | "drugId" | "brandId" | "strategy" | "quantity" | "dose" | "details" | "meal" | "type" | "unitConcentrationId", ExtArgs["result"]["issue"]>
  export type IssueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batch?: boolean | Issue$batchArgs<ExtArgs>
    brand?: boolean | DrugBrandDefaultArgs<ExtArgs>
    drug?: boolean | DrugDefaultArgs<ExtArgs>
    prescription?: boolean | PrescriptionDefaultArgs<ExtArgs>
    unitConcentration?: boolean | UnitConcentrationDefaultArgs<ExtArgs>
    stratergyHistory?: boolean | Issue$stratergyHistoryArgs<ExtArgs>
    _count?: boolean | IssueCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type IssueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batch?: boolean | Issue$batchArgs<ExtArgs>
    brand?: boolean | DrugBrandDefaultArgs<ExtArgs>
    drug?: boolean | DrugDefaultArgs<ExtArgs>
    prescription?: boolean | PrescriptionDefaultArgs<ExtArgs>
    unitConcentration?: boolean | UnitConcentrationDefaultArgs<ExtArgs>
  }
  export type IssueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batch?: boolean | Issue$batchArgs<ExtArgs>
    brand?: boolean | DrugBrandDefaultArgs<ExtArgs>
    drug?: boolean | DrugDefaultArgs<ExtArgs>
    prescription?: boolean | PrescriptionDefaultArgs<ExtArgs>
    unitConcentration?: boolean | UnitConcentrationDefaultArgs<ExtArgs>
  }

  export type $IssuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Issue"
    objects: {
      batch: Prisma.$BatchPayload<ExtArgs> | null
      brand: Prisma.$DrugBrandPayload<ExtArgs>
      drug: Prisma.$DrugPayload<ExtArgs>
      prescription: Prisma.$PrescriptionPayload<ExtArgs>
      unitConcentration: Prisma.$UnitConcentrationPayload<ExtArgs>
      stratergyHistory: Prisma.$StratergyHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      prescriptionId: number
      batchId: number | null
      drugId: number
      brandId: number
      strategy: $Enums.IssuingStrategy
      quantity: number
      dose: number
      details: string | null
      meal: $Enums.MEAL | null
      type: $Enums.DrugType
      unitConcentrationId: number
    }, ExtArgs["result"]["issue"]>
    composites: {}
  }

  type IssueGetPayload<S extends boolean | null | undefined | IssueDefaultArgs> = $Result.GetResult<Prisma.$IssuePayload, S>

  type IssueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IssueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IssueCountAggregateInputType | true
    }

  export interface IssueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Issue'], meta: { name: 'Issue' } }
    /**
     * Find zero or one Issue that matches the filter.
     * @param {IssueFindUniqueArgs} args - Arguments to find a Issue
     * @example
     * // Get one Issue
     * const issue = await prisma.issue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IssueFindUniqueArgs>(args: SelectSubset<T, IssueFindUniqueArgs<ExtArgs>>): Prisma__IssueClient<$Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Issue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IssueFindUniqueOrThrowArgs} args - Arguments to find a Issue
     * @example
     * // Get one Issue
     * const issue = await prisma.issue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IssueFindUniqueOrThrowArgs>(args: SelectSubset<T, IssueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IssueClient<$Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Issue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IssueFindFirstArgs} args - Arguments to find a Issue
     * @example
     * // Get one Issue
     * const issue = await prisma.issue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IssueFindFirstArgs>(args?: SelectSubset<T, IssueFindFirstArgs<ExtArgs>>): Prisma__IssueClient<$Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Issue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IssueFindFirstOrThrowArgs} args - Arguments to find a Issue
     * @example
     * // Get one Issue
     * const issue = await prisma.issue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IssueFindFirstOrThrowArgs>(args?: SelectSubset<T, IssueFindFirstOrThrowArgs<ExtArgs>>): Prisma__IssueClient<$Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Issues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IssueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Issues
     * const issues = await prisma.issue.findMany()
     * 
     * // Get first 10 Issues
     * const issues = await prisma.issue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const issueWithIdOnly = await prisma.issue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IssueFindManyArgs>(args?: SelectSubset<T, IssueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Issue.
     * @param {IssueCreateArgs} args - Arguments to create a Issue.
     * @example
     * // Create one Issue
     * const Issue = await prisma.issue.create({
     *   data: {
     *     // ... data to create a Issue
     *   }
     * })
     * 
     */
    create<T extends IssueCreateArgs>(args: SelectSubset<T, IssueCreateArgs<ExtArgs>>): Prisma__IssueClient<$Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Issues.
     * @param {IssueCreateManyArgs} args - Arguments to create many Issues.
     * @example
     * // Create many Issues
     * const issue = await prisma.issue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IssueCreateManyArgs>(args?: SelectSubset<T, IssueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Issues and returns the data saved in the database.
     * @param {IssueCreateManyAndReturnArgs} args - Arguments to create many Issues.
     * @example
     * // Create many Issues
     * const issue = await prisma.issue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Issues and only return the `id`
     * const issueWithIdOnly = await prisma.issue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IssueCreateManyAndReturnArgs>(args?: SelectSubset<T, IssueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Issue.
     * @param {IssueDeleteArgs} args - Arguments to delete one Issue.
     * @example
     * // Delete one Issue
     * const Issue = await prisma.issue.delete({
     *   where: {
     *     // ... filter to delete one Issue
     *   }
     * })
     * 
     */
    delete<T extends IssueDeleteArgs>(args: SelectSubset<T, IssueDeleteArgs<ExtArgs>>): Prisma__IssueClient<$Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Issue.
     * @param {IssueUpdateArgs} args - Arguments to update one Issue.
     * @example
     * // Update one Issue
     * const issue = await prisma.issue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IssueUpdateArgs>(args: SelectSubset<T, IssueUpdateArgs<ExtArgs>>): Prisma__IssueClient<$Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Issues.
     * @param {IssueDeleteManyArgs} args - Arguments to filter Issues to delete.
     * @example
     * // Delete a few Issues
     * const { count } = await prisma.issue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IssueDeleteManyArgs>(args?: SelectSubset<T, IssueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Issues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IssueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Issues
     * const issue = await prisma.issue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IssueUpdateManyArgs>(args: SelectSubset<T, IssueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Issues and returns the data updated in the database.
     * @param {IssueUpdateManyAndReturnArgs} args - Arguments to update many Issues.
     * @example
     * // Update many Issues
     * const issue = await prisma.issue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Issues and only return the `id`
     * const issueWithIdOnly = await prisma.issue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IssueUpdateManyAndReturnArgs>(args: SelectSubset<T, IssueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Issue.
     * @param {IssueUpsertArgs} args - Arguments to update or create a Issue.
     * @example
     * // Update or create a Issue
     * const issue = await prisma.issue.upsert({
     *   create: {
     *     // ... data to create a Issue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Issue we want to update
     *   }
     * })
     */
    upsert<T extends IssueUpsertArgs>(args: SelectSubset<T, IssueUpsertArgs<ExtArgs>>): Prisma__IssueClient<$Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Issues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IssueCountArgs} args - Arguments to filter Issues to count.
     * @example
     * // Count the number of Issues
     * const count = await prisma.issue.count({
     *   where: {
     *     // ... the filter for the Issues we want to count
     *   }
     * })
    **/
    count<T extends IssueCountArgs>(
      args?: Subset<T, IssueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IssueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Issue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IssueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IssueAggregateArgs>(args: Subset<T, IssueAggregateArgs>): Prisma.PrismaPromise<GetIssueAggregateType<T>>

    /**
     * Group by Issue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IssueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IssueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IssueGroupByArgs['orderBy'] }
        : { orderBy?: IssueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IssueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIssueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Issue model
   */
  readonly fields: IssueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Issue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IssueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    batch<T extends Issue$batchArgs<ExtArgs> = {}>(args?: Subset<T, Issue$batchArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    brand<T extends DrugBrandDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DrugBrandDefaultArgs<ExtArgs>>): Prisma__DrugBrandClient<$Result.GetResult<Prisma.$DrugBrandPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    drug<T extends DrugDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DrugDefaultArgs<ExtArgs>>): Prisma__DrugClient<$Result.GetResult<Prisma.$DrugPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    prescription<T extends PrescriptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PrescriptionDefaultArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    unitConcentration<T extends UnitConcentrationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitConcentrationDefaultArgs<ExtArgs>>): Prisma__UnitConcentrationClient<$Result.GetResult<Prisma.$UnitConcentrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    stratergyHistory<T extends Issue$stratergyHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Issue$stratergyHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StratergyHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Issue model
   */ 
  interface IssueFieldRefs {
    readonly id: FieldRef<"Issue", 'Int'>
    readonly prescriptionId: FieldRef<"Issue", 'Int'>
    readonly batchId: FieldRef<"Issue", 'Int'>
    readonly drugId: FieldRef<"Issue", 'Int'>
    readonly brandId: FieldRef<"Issue", 'Int'>
    readonly strategy: FieldRef<"Issue", 'IssuingStrategy'>
    readonly quantity: FieldRef<"Issue", 'Float'>
    readonly dose: FieldRef<"Issue", 'Float'>
    readonly details: FieldRef<"Issue", 'String'>
    readonly meal: FieldRef<"Issue", 'MEAL'>
    readonly type: FieldRef<"Issue", 'DrugType'>
    readonly unitConcentrationId: FieldRef<"Issue", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Issue findUnique
   */
  export type IssueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issue
     */
    select?: IssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Issue
     */
    omit?: IssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueInclude<ExtArgs> | null
    /**
     * Filter, which Issue to fetch.
     */
    where: IssueWhereUniqueInput
  }

  /**
   * Issue findUniqueOrThrow
   */
  export type IssueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issue
     */
    select?: IssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Issue
     */
    omit?: IssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueInclude<ExtArgs> | null
    /**
     * Filter, which Issue to fetch.
     */
    where: IssueWhereUniqueInput
  }

  /**
   * Issue findFirst
   */
  export type IssueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issue
     */
    select?: IssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Issue
     */
    omit?: IssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueInclude<ExtArgs> | null
    /**
     * Filter, which Issue to fetch.
     */
    where?: IssueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Issues to fetch.
     */
    orderBy?: IssueOrderByWithRelationInput | IssueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Issues.
     */
    cursor?: IssueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Issues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Issues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Issues.
     */
    distinct?: IssueScalarFieldEnum | IssueScalarFieldEnum[]
  }

  /**
   * Issue findFirstOrThrow
   */
  export type IssueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issue
     */
    select?: IssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Issue
     */
    omit?: IssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueInclude<ExtArgs> | null
    /**
     * Filter, which Issue to fetch.
     */
    where?: IssueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Issues to fetch.
     */
    orderBy?: IssueOrderByWithRelationInput | IssueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Issues.
     */
    cursor?: IssueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Issues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Issues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Issues.
     */
    distinct?: IssueScalarFieldEnum | IssueScalarFieldEnum[]
  }

  /**
   * Issue findMany
   */
  export type IssueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issue
     */
    select?: IssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Issue
     */
    omit?: IssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueInclude<ExtArgs> | null
    /**
     * Filter, which Issues to fetch.
     */
    where?: IssueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Issues to fetch.
     */
    orderBy?: IssueOrderByWithRelationInput | IssueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Issues.
     */
    cursor?: IssueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Issues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Issues.
     */
    skip?: number
    distinct?: IssueScalarFieldEnum | IssueScalarFieldEnum[]
  }

  /**
   * Issue create
   */
  export type IssueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issue
     */
    select?: IssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Issue
     */
    omit?: IssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueInclude<ExtArgs> | null
    /**
     * The data needed to create a Issue.
     */
    data: XOR<IssueCreateInput, IssueUncheckedCreateInput>
  }

  /**
   * Issue createMany
   */
  export type IssueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Issues.
     */
    data: IssueCreateManyInput | IssueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Issue createManyAndReturn
   */
  export type IssueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issue
     */
    select?: IssueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Issue
     */
    omit?: IssueOmit<ExtArgs> | null
    /**
     * The data used to create many Issues.
     */
    data: IssueCreateManyInput | IssueCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Issue update
   */
  export type IssueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issue
     */
    select?: IssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Issue
     */
    omit?: IssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueInclude<ExtArgs> | null
    /**
     * The data needed to update a Issue.
     */
    data: XOR<IssueUpdateInput, IssueUncheckedUpdateInput>
    /**
     * Choose, which Issue to update.
     */
    where: IssueWhereUniqueInput
  }

  /**
   * Issue updateMany
   */
  export type IssueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Issues.
     */
    data: XOR<IssueUpdateManyMutationInput, IssueUncheckedUpdateManyInput>
    /**
     * Filter which Issues to update
     */
    where?: IssueWhereInput
    /**
     * Limit how many Issues to update.
     */
    limit?: number
  }

  /**
   * Issue updateManyAndReturn
   */
  export type IssueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issue
     */
    select?: IssueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Issue
     */
    omit?: IssueOmit<ExtArgs> | null
    /**
     * The data used to update Issues.
     */
    data: XOR<IssueUpdateManyMutationInput, IssueUncheckedUpdateManyInput>
    /**
     * Filter which Issues to update
     */
    where?: IssueWhereInput
    /**
     * Limit how many Issues to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Issue upsert
   */
  export type IssueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issue
     */
    select?: IssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Issue
     */
    omit?: IssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueInclude<ExtArgs> | null
    /**
     * The filter to search for the Issue to update in case it exists.
     */
    where: IssueWhereUniqueInput
    /**
     * In case the Issue found by the `where` argument doesn't exist, create a new Issue with this data.
     */
    create: XOR<IssueCreateInput, IssueUncheckedCreateInput>
    /**
     * In case the Issue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IssueUpdateInput, IssueUncheckedUpdateInput>
  }

  /**
   * Issue delete
   */
  export type IssueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issue
     */
    select?: IssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Issue
     */
    omit?: IssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueInclude<ExtArgs> | null
    /**
     * Filter which Issue to delete.
     */
    where: IssueWhereUniqueInput
  }

  /**
   * Issue deleteMany
   */
  export type IssueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Issues to delete
     */
    where?: IssueWhereInput
    /**
     * Limit how many Issues to delete.
     */
    limit?: number
  }

  /**
   * Issue.batch
   */
  export type Issue$batchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    where?: BatchWhereInput
  }

  /**
   * Issue.stratergyHistory
   */
  export type Issue$stratergyHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StratergyHistory
     */
    select?: StratergyHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StratergyHistory
     */
    omit?: StratergyHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StratergyHistoryInclude<ExtArgs> | null
    where?: StratergyHistoryWhereInput
    orderBy?: StratergyHistoryOrderByWithRelationInput | StratergyHistoryOrderByWithRelationInput[]
    cursor?: StratergyHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StratergyHistoryScalarFieldEnum | StratergyHistoryScalarFieldEnum[]
  }

  /**
   * Issue without action
   */
  export type IssueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issue
     */
    select?: IssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Issue
     */
    omit?: IssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueInclude<ExtArgs> | null
  }


  /**
   * Model ReportParameter
   */

  export type AggregateReportParameter = {
    _count: ReportParameterCountAggregateOutputType | null
    _avg: ReportParameterAvgAggregateOutputType | null
    _sum: ReportParameterSumAggregateOutputType | null
    _min: ReportParameterMinAggregateOutputType | null
    _max: ReportParameterMaxAggregateOutputType | null
  }

  export type ReportParameterAvgAggregateOutputType = {
    id: number | null
    reportTypeId: number | null
  }

  export type ReportParameterSumAggregateOutputType = {
    id: number | null
    reportTypeId: number | null
  }

  export type ReportParameterMinAggregateOutputType = {
    id: number | null
    name: string | null
    units: string | null
    reportTypeId: number | null
  }

  export type ReportParameterMaxAggregateOutputType = {
    id: number | null
    name: string | null
    units: string | null
    reportTypeId: number | null
  }

  export type ReportParameterCountAggregateOutputType = {
    id: number
    name: number
    units: number
    reportTypeId: number
    _all: number
  }


  export type ReportParameterAvgAggregateInputType = {
    id?: true
    reportTypeId?: true
  }

  export type ReportParameterSumAggregateInputType = {
    id?: true
    reportTypeId?: true
  }

  export type ReportParameterMinAggregateInputType = {
    id?: true
    name?: true
    units?: true
    reportTypeId?: true
  }

  export type ReportParameterMaxAggregateInputType = {
    id?: true
    name?: true
    units?: true
    reportTypeId?: true
  }

  export type ReportParameterCountAggregateInputType = {
    id?: true
    name?: true
    units?: true
    reportTypeId?: true
    _all?: true
  }

  export type ReportParameterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportParameter to aggregate.
     */
    where?: ReportParameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportParameters to fetch.
     */
    orderBy?: ReportParameterOrderByWithRelationInput | ReportParameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportParameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportParameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportParameters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReportParameters
    **/
    _count?: true | ReportParameterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReportParameterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReportParameterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportParameterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportParameterMaxAggregateInputType
  }

  export type GetReportParameterAggregateType<T extends ReportParameterAggregateArgs> = {
        [P in keyof T & keyof AggregateReportParameter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReportParameter[P]>
      : GetScalarType<T[P], AggregateReportParameter[P]>
  }




  export type ReportParameterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportParameterWhereInput
    orderBy?: ReportParameterOrderByWithAggregationInput | ReportParameterOrderByWithAggregationInput[]
    by: ReportParameterScalarFieldEnum[] | ReportParameterScalarFieldEnum
    having?: ReportParameterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportParameterCountAggregateInputType | true
    _avg?: ReportParameterAvgAggregateInputType
    _sum?: ReportParameterSumAggregateInputType
    _min?: ReportParameterMinAggregateInputType
    _max?: ReportParameterMaxAggregateInputType
  }

  export type ReportParameterGroupByOutputType = {
    id: number
    name: string
    units: string | null
    reportTypeId: number | null
    _count: ReportParameterCountAggregateOutputType | null
    _avg: ReportParameterAvgAggregateOutputType | null
    _sum: ReportParameterSumAggregateOutputType | null
    _min: ReportParameterMinAggregateOutputType | null
    _max: ReportParameterMaxAggregateOutputType | null
  }

  type GetReportParameterGroupByPayload<T extends ReportParameterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportParameterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportParameterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportParameterGroupByOutputType[P]>
            : GetScalarType<T[P], ReportParameterGroupByOutputType[P]>
        }
      >
    >


  export type ReportParameterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    units?: boolean
    reportTypeId?: boolean
    ReportType?: boolean | ReportParameter$ReportTypeArgs<ExtArgs>
    ReportValue?: boolean | ReportParameter$ReportValueArgs<ExtArgs>
    _count?: boolean | ReportParameterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportParameter"]>

  export type ReportParameterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    units?: boolean
    reportTypeId?: boolean
    ReportType?: boolean | ReportParameter$ReportTypeArgs<ExtArgs>
  }, ExtArgs["result"]["reportParameter"]>

  export type ReportParameterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    units?: boolean
    reportTypeId?: boolean
    ReportType?: boolean | ReportParameter$ReportTypeArgs<ExtArgs>
  }, ExtArgs["result"]["reportParameter"]>

  export type ReportParameterSelectScalar = {
    id?: boolean
    name?: boolean
    units?: boolean
    reportTypeId?: boolean
  }

  export type ReportParameterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "units" | "reportTypeId", ExtArgs["result"]["reportParameter"]>
  export type ReportParameterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ReportType?: boolean | ReportParameter$ReportTypeArgs<ExtArgs>
    ReportValue?: boolean | ReportParameter$ReportValueArgs<ExtArgs>
    _count?: boolean | ReportParameterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ReportParameterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ReportType?: boolean | ReportParameter$ReportTypeArgs<ExtArgs>
  }
  export type ReportParameterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ReportType?: boolean | ReportParameter$ReportTypeArgs<ExtArgs>
  }

  export type $ReportParameterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReportParameter"
    objects: {
      ReportType: Prisma.$ReportTypePayload<ExtArgs> | null
      ReportValue: Prisma.$ReportValuePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      units: string | null
      reportTypeId: number | null
    }, ExtArgs["result"]["reportParameter"]>
    composites: {}
  }

  type ReportParameterGetPayload<S extends boolean | null | undefined | ReportParameterDefaultArgs> = $Result.GetResult<Prisma.$ReportParameterPayload, S>

  type ReportParameterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReportParameterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReportParameterCountAggregateInputType | true
    }

  export interface ReportParameterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReportParameter'], meta: { name: 'ReportParameter' } }
    /**
     * Find zero or one ReportParameter that matches the filter.
     * @param {ReportParameterFindUniqueArgs} args - Arguments to find a ReportParameter
     * @example
     * // Get one ReportParameter
     * const reportParameter = await prisma.reportParameter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportParameterFindUniqueArgs>(args: SelectSubset<T, ReportParameterFindUniqueArgs<ExtArgs>>): Prisma__ReportParameterClient<$Result.GetResult<Prisma.$ReportParameterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReportParameter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReportParameterFindUniqueOrThrowArgs} args - Arguments to find a ReportParameter
     * @example
     * // Get one ReportParameter
     * const reportParameter = await prisma.reportParameter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportParameterFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportParameterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportParameterClient<$Result.GetResult<Prisma.$ReportParameterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReportParameter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportParameterFindFirstArgs} args - Arguments to find a ReportParameter
     * @example
     * // Get one ReportParameter
     * const reportParameter = await prisma.reportParameter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportParameterFindFirstArgs>(args?: SelectSubset<T, ReportParameterFindFirstArgs<ExtArgs>>): Prisma__ReportParameterClient<$Result.GetResult<Prisma.$ReportParameterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReportParameter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportParameterFindFirstOrThrowArgs} args - Arguments to find a ReportParameter
     * @example
     * // Get one ReportParameter
     * const reportParameter = await prisma.reportParameter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportParameterFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportParameterFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportParameterClient<$Result.GetResult<Prisma.$ReportParameterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReportParameters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportParameterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReportParameters
     * const reportParameters = await prisma.reportParameter.findMany()
     * 
     * // Get first 10 ReportParameters
     * const reportParameters = await prisma.reportParameter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportParameterWithIdOnly = await prisma.reportParameter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportParameterFindManyArgs>(args?: SelectSubset<T, ReportParameterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportParameterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReportParameter.
     * @param {ReportParameterCreateArgs} args - Arguments to create a ReportParameter.
     * @example
     * // Create one ReportParameter
     * const ReportParameter = await prisma.reportParameter.create({
     *   data: {
     *     // ... data to create a ReportParameter
     *   }
     * })
     * 
     */
    create<T extends ReportParameterCreateArgs>(args: SelectSubset<T, ReportParameterCreateArgs<ExtArgs>>): Prisma__ReportParameterClient<$Result.GetResult<Prisma.$ReportParameterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReportParameters.
     * @param {ReportParameterCreateManyArgs} args - Arguments to create many ReportParameters.
     * @example
     * // Create many ReportParameters
     * const reportParameter = await prisma.reportParameter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportParameterCreateManyArgs>(args?: SelectSubset<T, ReportParameterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReportParameters and returns the data saved in the database.
     * @param {ReportParameterCreateManyAndReturnArgs} args - Arguments to create many ReportParameters.
     * @example
     * // Create many ReportParameters
     * const reportParameter = await prisma.reportParameter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReportParameters and only return the `id`
     * const reportParameterWithIdOnly = await prisma.reportParameter.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReportParameterCreateManyAndReturnArgs>(args?: SelectSubset<T, ReportParameterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportParameterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReportParameter.
     * @param {ReportParameterDeleteArgs} args - Arguments to delete one ReportParameter.
     * @example
     * // Delete one ReportParameter
     * const ReportParameter = await prisma.reportParameter.delete({
     *   where: {
     *     // ... filter to delete one ReportParameter
     *   }
     * })
     * 
     */
    delete<T extends ReportParameterDeleteArgs>(args: SelectSubset<T, ReportParameterDeleteArgs<ExtArgs>>): Prisma__ReportParameterClient<$Result.GetResult<Prisma.$ReportParameterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReportParameter.
     * @param {ReportParameterUpdateArgs} args - Arguments to update one ReportParameter.
     * @example
     * // Update one ReportParameter
     * const reportParameter = await prisma.reportParameter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportParameterUpdateArgs>(args: SelectSubset<T, ReportParameterUpdateArgs<ExtArgs>>): Prisma__ReportParameterClient<$Result.GetResult<Prisma.$ReportParameterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReportParameters.
     * @param {ReportParameterDeleteManyArgs} args - Arguments to filter ReportParameters to delete.
     * @example
     * // Delete a few ReportParameters
     * const { count } = await prisma.reportParameter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportParameterDeleteManyArgs>(args?: SelectSubset<T, ReportParameterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportParameters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportParameterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReportParameters
     * const reportParameter = await prisma.reportParameter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportParameterUpdateManyArgs>(args: SelectSubset<T, ReportParameterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportParameters and returns the data updated in the database.
     * @param {ReportParameterUpdateManyAndReturnArgs} args - Arguments to update many ReportParameters.
     * @example
     * // Update many ReportParameters
     * const reportParameter = await prisma.reportParameter.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReportParameters and only return the `id`
     * const reportParameterWithIdOnly = await prisma.reportParameter.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReportParameterUpdateManyAndReturnArgs>(args: SelectSubset<T, ReportParameterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportParameterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReportParameter.
     * @param {ReportParameterUpsertArgs} args - Arguments to update or create a ReportParameter.
     * @example
     * // Update or create a ReportParameter
     * const reportParameter = await prisma.reportParameter.upsert({
     *   create: {
     *     // ... data to create a ReportParameter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReportParameter we want to update
     *   }
     * })
     */
    upsert<T extends ReportParameterUpsertArgs>(args: SelectSubset<T, ReportParameterUpsertArgs<ExtArgs>>): Prisma__ReportParameterClient<$Result.GetResult<Prisma.$ReportParameterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReportParameters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportParameterCountArgs} args - Arguments to filter ReportParameters to count.
     * @example
     * // Count the number of ReportParameters
     * const count = await prisma.reportParameter.count({
     *   where: {
     *     // ... the filter for the ReportParameters we want to count
     *   }
     * })
    **/
    count<T extends ReportParameterCountArgs>(
      args?: Subset<T, ReportParameterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportParameterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReportParameter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportParameterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportParameterAggregateArgs>(args: Subset<T, ReportParameterAggregateArgs>): Prisma.PrismaPromise<GetReportParameterAggregateType<T>>

    /**
     * Group by ReportParameter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportParameterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportParameterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportParameterGroupByArgs['orderBy'] }
        : { orderBy?: ReportParameterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportParameterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportParameterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReportParameter model
   */
  readonly fields: ReportParameterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReportParameter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportParameterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ReportType<T extends ReportParameter$ReportTypeArgs<ExtArgs> = {}>(args?: Subset<T, ReportParameter$ReportTypeArgs<ExtArgs>>): Prisma__ReportTypeClient<$Result.GetResult<Prisma.$ReportTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    ReportValue<T extends ReportParameter$ReportValueArgs<ExtArgs> = {}>(args?: Subset<T, ReportParameter$ReportValueArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReportParameter model
   */ 
  interface ReportParameterFieldRefs {
    readonly id: FieldRef<"ReportParameter", 'Int'>
    readonly name: FieldRef<"ReportParameter", 'String'>
    readonly units: FieldRef<"ReportParameter", 'String'>
    readonly reportTypeId: FieldRef<"ReportParameter", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ReportParameter findUnique
   */
  export type ReportParameterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportParameter
     */
    select?: ReportParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportParameter
     */
    omit?: ReportParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportParameterInclude<ExtArgs> | null
    /**
     * Filter, which ReportParameter to fetch.
     */
    where: ReportParameterWhereUniqueInput
  }

  /**
   * ReportParameter findUniqueOrThrow
   */
  export type ReportParameterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportParameter
     */
    select?: ReportParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportParameter
     */
    omit?: ReportParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportParameterInclude<ExtArgs> | null
    /**
     * Filter, which ReportParameter to fetch.
     */
    where: ReportParameterWhereUniqueInput
  }

  /**
   * ReportParameter findFirst
   */
  export type ReportParameterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportParameter
     */
    select?: ReportParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportParameter
     */
    omit?: ReportParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportParameterInclude<ExtArgs> | null
    /**
     * Filter, which ReportParameter to fetch.
     */
    where?: ReportParameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportParameters to fetch.
     */
    orderBy?: ReportParameterOrderByWithRelationInput | ReportParameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportParameters.
     */
    cursor?: ReportParameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportParameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportParameters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportParameters.
     */
    distinct?: ReportParameterScalarFieldEnum | ReportParameterScalarFieldEnum[]
  }

  /**
   * ReportParameter findFirstOrThrow
   */
  export type ReportParameterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportParameter
     */
    select?: ReportParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportParameter
     */
    omit?: ReportParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportParameterInclude<ExtArgs> | null
    /**
     * Filter, which ReportParameter to fetch.
     */
    where?: ReportParameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportParameters to fetch.
     */
    orderBy?: ReportParameterOrderByWithRelationInput | ReportParameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportParameters.
     */
    cursor?: ReportParameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportParameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportParameters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportParameters.
     */
    distinct?: ReportParameterScalarFieldEnum | ReportParameterScalarFieldEnum[]
  }

  /**
   * ReportParameter findMany
   */
  export type ReportParameterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportParameter
     */
    select?: ReportParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportParameter
     */
    omit?: ReportParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportParameterInclude<ExtArgs> | null
    /**
     * Filter, which ReportParameters to fetch.
     */
    where?: ReportParameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportParameters to fetch.
     */
    orderBy?: ReportParameterOrderByWithRelationInput | ReportParameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReportParameters.
     */
    cursor?: ReportParameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportParameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportParameters.
     */
    skip?: number
    distinct?: ReportParameterScalarFieldEnum | ReportParameterScalarFieldEnum[]
  }

  /**
   * ReportParameter create
   */
  export type ReportParameterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportParameter
     */
    select?: ReportParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportParameter
     */
    omit?: ReportParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportParameterInclude<ExtArgs> | null
    /**
     * The data needed to create a ReportParameter.
     */
    data: XOR<ReportParameterCreateInput, ReportParameterUncheckedCreateInput>
  }

  /**
   * ReportParameter createMany
   */
  export type ReportParameterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReportParameters.
     */
    data: ReportParameterCreateManyInput | ReportParameterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReportParameter createManyAndReturn
   */
  export type ReportParameterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportParameter
     */
    select?: ReportParameterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReportParameter
     */
    omit?: ReportParameterOmit<ExtArgs> | null
    /**
     * The data used to create many ReportParameters.
     */
    data: ReportParameterCreateManyInput | ReportParameterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportParameterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReportParameter update
   */
  export type ReportParameterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportParameter
     */
    select?: ReportParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportParameter
     */
    omit?: ReportParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportParameterInclude<ExtArgs> | null
    /**
     * The data needed to update a ReportParameter.
     */
    data: XOR<ReportParameterUpdateInput, ReportParameterUncheckedUpdateInput>
    /**
     * Choose, which ReportParameter to update.
     */
    where: ReportParameterWhereUniqueInput
  }

  /**
   * ReportParameter updateMany
   */
  export type ReportParameterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReportParameters.
     */
    data: XOR<ReportParameterUpdateManyMutationInput, ReportParameterUncheckedUpdateManyInput>
    /**
     * Filter which ReportParameters to update
     */
    where?: ReportParameterWhereInput
    /**
     * Limit how many ReportParameters to update.
     */
    limit?: number
  }

  /**
   * ReportParameter updateManyAndReturn
   */
  export type ReportParameterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportParameter
     */
    select?: ReportParameterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReportParameter
     */
    omit?: ReportParameterOmit<ExtArgs> | null
    /**
     * The data used to update ReportParameters.
     */
    data: XOR<ReportParameterUpdateManyMutationInput, ReportParameterUncheckedUpdateManyInput>
    /**
     * Filter which ReportParameters to update
     */
    where?: ReportParameterWhereInput
    /**
     * Limit how many ReportParameters to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportParameterIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReportParameter upsert
   */
  export type ReportParameterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportParameter
     */
    select?: ReportParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportParameter
     */
    omit?: ReportParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportParameterInclude<ExtArgs> | null
    /**
     * The filter to search for the ReportParameter to update in case it exists.
     */
    where: ReportParameterWhereUniqueInput
    /**
     * In case the ReportParameter found by the `where` argument doesn't exist, create a new ReportParameter with this data.
     */
    create: XOR<ReportParameterCreateInput, ReportParameterUncheckedCreateInput>
    /**
     * In case the ReportParameter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportParameterUpdateInput, ReportParameterUncheckedUpdateInput>
  }

  /**
   * ReportParameter delete
   */
  export type ReportParameterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportParameter
     */
    select?: ReportParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportParameter
     */
    omit?: ReportParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportParameterInclude<ExtArgs> | null
    /**
     * Filter which ReportParameter to delete.
     */
    where: ReportParameterWhereUniqueInput
  }

  /**
   * ReportParameter deleteMany
   */
  export type ReportParameterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportParameters to delete
     */
    where?: ReportParameterWhereInput
    /**
     * Limit how many ReportParameters to delete.
     */
    limit?: number
  }

  /**
   * ReportParameter.ReportType
   */
  export type ReportParameter$ReportTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportType
     */
    select?: ReportTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportType
     */
    omit?: ReportTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTypeInclude<ExtArgs> | null
    where?: ReportTypeWhereInput
  }

  /**
   * ReportParameter.ReportValue
   */
  export type ReportParameter$ReportValueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportValue
     */
    select?: ReportValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportValue
     */
    omit?: ReportValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportValueInclude<ExtArgs> | null
    where?: ReportValueWhereInput
    orderBy?: ReportValueOrderByWithRelationInput | ReportValueOrderByWithRelationInput[]
    cursor?: ReportValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportValueScalarFieldEnum | ReportValueScalarFieldEnum[]
  }

  /**
   * ReportParameter without action
   */
  export type ReportParameterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportParameter
     */
    select?: ReportParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportParameter
     */
    omit?: ReportParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportParameterInclude<ExtArgs> | null
  }


  /**
   * Model ReportType
   */

  export type AggregateReportType = {
    _count: ReportTypeCountAggregateOutputType | null
    _avg: ReportTypeAvgAggregateOutputType | null
    _sum: ReportTypeSumAggregateOutputType | null
    _min: ReportTypeMinAggregateOutputType | null
    _max: ReportTypeMaxAggregateOutputType | null
  }

  export type ReportTypeAvgAggregateOutputType = {
    id: number | null
  }

  export type ReportTypeSumAggregateOutputType = {
    id: number | null
  }

  export type ReportTypeMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
  }

  export type ReportTypeMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
  }

  export type ReportTypeCountAggregateOutputType = {
    id: number
    name: number
    description: number
    _all: number
  }


  export type ReportTypeAvgAggregateInputType = {
    id?: true
  }

  export type ReportTypeSumAggregateInputType = {
    id?: true
  }

  export type ReportTypeMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type ReportTypeMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type ReportTypeCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    _all?: true
  }

  export type ReportTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportType to aggregate.
     */
    where?: ReportTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportTypes to fetch.
     */
    orderBy?: ReportTypeOrderByWithRelationInput | ReportTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReportTypes
    **/
    _count?: true | ReportTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReportTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReportTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportTypeMaxAggregateInputType
  }

  export type GetReportTypeAggregateType<T extends ReportTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateReportType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReportType[P]>
      : GetScalarType<T[P], AggregateReportType[P]>
  }




  export type ReportTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportTypeWhereInput
    orderBy?: ReportTypeOrderByWithAggregationInput | ReportTypeOrderByWithAggregationInput[]
    by: ReportTypeScalarFieldEnum[] | ReportTypeScalarFieldEnum
    having?: ReportTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportTypeCountAggregateInputType | true
    _avg?: ReportTypeAvgAggregateInputType
    _sum?: ReportTypeSumAggregateInputType
    _min?: ReportTypeMinAggregateInputType
    _max?: ReportTypeMaxAggregateInputType
  }

  export type ReportTypeGroupByOutputType = {
    id: number
    name: string
    description: string | null
    _count: ReportTypeCountAggregateOutputType | null
    _avg: ReportTypeAvgAggregateOutputType | null
    _sum: ReportTypeSumAggregateOutputType | null
    _min: ReportTypeMinAggregateOutputType | null
    _max: ReportTypeMaxAggregateOutputType | null
  }

  type GetReportTypeGroupByPayload<T extends ReportTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportTypeGroupByOutputType[P]>
            : GetScalarType<T[P], ReportTypeGroupByOutputType[P]>
        }
      >
    >


  export type ReportTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    PatientReport?: boolean | ReportType$PatientReportArgs<ExtArgs>
    parameters?: boolean | ReportType$parametersArgs<ExtArgs>
    _count?: boolean | ReportTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportType"]>

  export type ReportTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["reportType"]>

  export type ReportTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["reportType"]>

  export type ReportTypeSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
  }

  export type ReportTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description", ExtArgs["result"]["reportType"]>
  export type ReportTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PatientReport?: boolean | ReportType$PatientReportArgs<ExtArgs>
    parameters?: boolean | ReportType$parametersArgs<ExtArgs>
    _count?: boolean | ReportTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ReportTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ReportTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ReportTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReportType"
    objects: {
      PatientReport: Prisma.$PatientReportPayload<ExtArgs>[]
      parameters: Prisma.$ReportParameterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
    }, ExtArgs["result"]["reportType"]>
    composites: {}
  }

  type ReportTypeGetPayload<S extends boolean | null | undefined | ReportTypeDefaultArgs> = $Result.GetResult<Prisma.$ReportTypePayload, S>

  type ReportTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReportTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReportTypeCountAggregateInputType | true
    }

  export interface ReportTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReportType'], meta: { name: 'ReportType' } }
    /**
     * Find zero or one ReportType that matches the filter.
     * @param {ReportTypeFindUniqueArgs} args - Arguments to find a ReportType
     * @example
     * // Get one ReportType
     * const reportType = await prisma.reportType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportTypeFindUniqueArgs>(args: SelectSubset<T, ReportTypeFindUniqueArgs<ExtArgs>>): Prisma__ReportTypeClient<$Result.GetResult<Prisma.$ReportTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReportType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReportTypeFindUniqueOrThrowArgs} args - Arguments to find a ReportType
     * @example
     * // Get one ReportType
     * const reportType = await prisma.reportType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportTypeClient<$Result.GetResult<Prisma.$ReportTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReportType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportTypeFindFirstArgs} args - Arguments to find a ReportType
     * @example
     * // Get one ReportType
     * const reportType = await prisma.reportType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportTypeFindFirstArgs>(args?: SelectSubset<T, ReportTypeFindFirstArgs<ExtArgs>>): Prisma__ReportTypeClient<$Result.GetResult<Prisma.$ReportTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReportType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportTypeFindFirstOrThrowArgs} args - Arguments to find a ReportType
     * @example
     * // Get one ReportType
     * const reportType = await prisma.reportType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportTypeClient<$Result.GetResult<Prisma.$ReportTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReportTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReportTypes
     * const reportTypes = await prisma.reportType.findMany()
     * 
     * // Get first 10 ReportTypes
     * const reportTypes = await prisma.reportType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportTypeWithIdOnly = await prisma.reportType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportTypeFindManyArgs>(args?: SelectSubset<T, ReportTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReportType.
     * @param {ReportTypeCreateArgs} args - Arguments to create a ReportType.
     * @example
     * // Create one ReportType
     * const ReportType = await prisma.reportType.create({
     *   data: {
     *     // ... data to create a ReportType
     *   }
     * })
     * 
     */
    create<T extends ReportTypeCreateArgs>(args: SelectSubset<T, ReportTypeCreateArgs<ExtArgs>>): Prisma__ReportTypeClient<$Result.GetResult<Prisma.$ReportTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReportTypes.
     * @param {ReportTypeCreateManyArgs} args - Arguments to create many ReportTypes.
     * @example
     * // Create many ReportTypes
     * const reportType = await prisma.reportType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportTypeCreateManyArgs>(args?: SelectSubset<T, ReportTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReportTypes and returns the data saved in the database.
     * @param {ReportTypeCreateManyAndReturnArgs} args - Arguments to create many ReportTypes.
     * @example
     * // Create many ReportTypes
     * const reportType = await prisma.reportType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReportTypes and only return the `id`
     * const reportTypeWithIdOnly = await prisma.reportType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReportTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, ReportTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReportType.
     * @param {ReportTypeDeleteArgs} args - Arguments to delete one ReportType.
     * @example
     * // Delete one ReportType
     * const ReportType = await prisma.reportType.delete({
     *   where: {
     *     // ... filter to delete one ReportType
     *   }
     * })
     * 
     */
    delete<T extends ReportTypeDeleteArgs>(args: SelectSubset<T, ReportTypeDeleteArgs<ExtArgs>>): Prisma__ReportTypeClient<$Result.GetResult<Prisma.$ReportTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReportType.
     * @param {ReportTypeUpdateArgs} args - Arguments to update one ReportType.
     * @example
     * // Update one ReportType
     * const reportType = await prisma.reportType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportTypeUpdateArgs>(args: SelectSubset<T, ReportTypeUpdateArgs<ExtArgs>>): Prisma__ReportTypeClient<$Result.GetResult<Prisma.$ReportTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReportTypes.
     * @param {ReportTypeDeleteManyArgs} args - Arguments to filter ReportTypes to delete.
     * @example
     * // Delete a few ReportTypes
     * const { count } = await prisma.reportType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportTypeDeleteManyArgs>(args?: SelectSubset<T, ReportTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReportTypes
     * const reportType = await prisma.reportType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportTypeUpdateManyArgs>(args: SelectSubset<T, ReportTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportTypes and returns the data updated in the database.
     * @param {ReportTypeUpdateManyAndReturnArgs} args - Arguments to update many ReportTypes.
     * @example
     * // Update many ReportTypes
     * const reportType = await prisma.reportType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReportTypes and only return the `id`
     * const reportTypeWithIdOnly = await prisma.reportType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReportTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, ReportTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReportType.
     * @param {ReportTypeUpsertArgs} args - Arguments to update or create a ReportType.
     * @example
     * // Update or create a ReportType
     * const reportType = await prisma.reportType.upsert({
     *   create: {
     *     // ... data to create a ReportType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReportType we want to update
     *   }
     * })
     */
    upsert<T extends ReportTypeUpsertArgs>(args: SelectSubset<T, ReportTypeUpsertArgs<ExtArgs>>): Prisma__ReportTypeClient<$Result.GetResult<Prisma.$ReportTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReportTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportTypeCountArgs} args - Arguments to filter ReportTypes to count.
     * @example
     * // Count the number of ReportTypes
     * const count = await prisma.reportType.count({
     *   where: {
     *     // ... the filter for the ReportTypes we want to count
     *   }
     * })
    **/
    count<T extends ReportTypeCountArgs>(
      args?: Subset<T, ReportTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReportType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportTypeAggregateArgs>(args: Subset<T, ReportTypeAggregateArgs>): Prisma.PrismaPromise<GetReportTypeAggregateType<T>>

    /**
     * Group by ReportType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportTypeGroupByArgs['orderBy'] }
        : { orderBy?: ReportTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReportType model
   */
  readonly fields: ReportTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReportType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    PatientReport<T extends ReportType$PatientReportArgs<ExtArgs> = {}>(args?: Subset<T, ReportType$PatientReportArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    parameters<T extends ReportType$parametersArgs<ExtArgs> = {}>(args?: Subset<T, ReportType$parametersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportParameterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReportType model
   */ 
  interface ReportTypeFieldRefs {
    readonly id: FieldRef<"ReportType", 'Int'>
    readonly name: FieldRef<"ReportType", 'String'>
    readonly description: FieldRef<"ReportType", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ReportType findUnique
   */
  export type ReportTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportType
     */
    select?: ReportTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportType
     */
    omit?: ReportTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTypeInclude<ExtArgs> | null
    /**
     * Filter, which ReportType to fetch.
     */
    where: ReportTypeWhereUniqueInput
  }

  /**
   * ReportType findUniqueOrThrow
   */
  export type ReportTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportType
     */
    select?: ReportTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportType
     */
    omit?: ReportTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTypeInclude<ExtArgs> | null
    /**
     * Filter, which ReportType to fetch.
     */
    where: ReportTypeWhereUniqueInput
  }

  /**
   * ReportType findFirst
   */
  export type ReportTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportType
     */
    select?: ReportTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportType
     */
    omit?: ReportTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTypeInclude<ExtArgs> | null
    /**
     * Filter, which ReportType to fetch.
     */
    where?: ReportTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportTypes to fetch.
     */
    orderBy?: ReportTypeOrderByWithRelationInput | ReportTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportTypes.
     */
    cursor?: ReportTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportTypes.
     */
    distinct?: ReportTypeScalarFieldEnum | ReportTypeScalarFieldEnum[]
  }

  /**
   * ReportType findFirstOrThrow
   */
  export type ReportTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportType
     */
    select?: ReportTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportType
     */
    omit?: ReportTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTypeInclude<ExtArgs> | null
    /**
     * Filter, which ReportType to fetch.
     */
    where?: ReportTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportTypes to fetch.
     */
    orderBy?: ReportTypeOrderByWithRelationInput | ReportTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportTypes.
     */
    cursor?: ReportTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportTypes.
     */
    distinct?: ReportTypeScalarFieldEnum | ReportTypeScalarFieldEnum[]
  }

  /**
   * ReportType findMany
   */
  export type ReportTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportType
     */
    select?: ReportTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportType
     */
    omit?: ReportTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTypeInclude<ExtArgs> | null
    /**
     * Filter, which ReportTypes to fetch.
     */
    where?: ReportTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportTypes to fetch.
     */
    orderBy?: ReportTypeOrderByWithRelationInput | ReportTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReportTypes.
     */
    cursor?: ReportTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportTypes.
     */
    skip?: number
    distinct?: ReportTypeScalarFieldEnum | ReportTypeScalarFieldEnum[]
  }

  /**
   * ReportType create
   */
  export type ReportTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportType
     */
    select?: ReportTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportType
     */
    omit?: ReportTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a ReportType.
     */
    data: XOR<ReportTypeCreateInput, ReportTypeUncheckedCreateInput>
  }

  /**
   * ReportType createMany
   */
  export type ReportTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReportTypes.
     */
    data: ReportTypeCreateManyInput | ReportTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReportType createManyAndReturn
   */
  export type ReportTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportType
     */
    select?: ReportTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReportType
     */
    omit?: ReportTypeOmit<ExtArgs> | null
    /**
     * The data used to create many ReportTypes.
     */
    data: ReportTypeCreateManyInput | ReportTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReportType update
   */
  export type ReportTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportType
     */
    select?: ReportTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportType
     */
    omit?: ReportTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a ReportType.
     */
    data: XOR<ReportTypeUpdateInput, ReportTypeUncheckedUpdateInput>
    /**
     * Choose, which ReportType to update.
     */
    where: ReportTypeWhereUniqueInput
  }

  /**
   * ReportType updateMany
   */
  export type ReportTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReportTypes.
     */
    data: XOR<ReportTypeUpdateManyMutationInput, ReportTypeUncheckedUpdateManyInput>
    /**
     * Filter which ReportTypes to update
     */
    where?: ReportTypeWhereInput
    /**
     * Limit how many ReportTypes to update.
     */
    limit?: number
  }

  /**
   * ReportType updateManyAndReturn
   */
  export type ReportTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportType
     */
    select?: ReportTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReportType
     */
    omit?: ReportTypeOmit<ExtArgs> | null
    /**
     * The data used to update ReportTypes.
     */
    data: XOR<ReportTypeUpdateManyMutationInput, ReportTypeUncheckedUpdateManyInput>
    /**
     * Filter which ReportTypes to update
     */
    where?: ReportTypeWhereInput
    /**
     * Limit how many ReportTypes to update.
     */
    limit?: number
  }

  /**
   * ReportType upsert
   */
  export type ReportTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportType
     */
    select?: ReportTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportType
     */
    omit?: ReportTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the ReportType to update in case it exists.
     */
    where: ReportTypeWhereUniqueInput
    /**
     * In case the ReportType found by the `where` argument doesn't exist, create a new ReportType with this data.
     */
    create: XOR<ReportTypeCreateInput, ReportTypeUncheckedCreateInput>
    /**
     * In case the ReportType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportTypeUpdateInput, ReportTypeUncheckedUpdateInput>
  }

  /**
   * ReportType delete
   */
  export type ReportTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportType
     */
    select?: ReportTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportType
     */
    omit?: ReportTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTypeInclude<ExtArgs> | null
    /**
     * Filter which ReportType to delete.
     */
    where: ReportTypeWhereUniqueInput
  }

  /**
   * ReportType deleteMany
   */
  export type ReportTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportTypes to delete
     */
    where?: ReportTypeWhereInput
    /**
     * Limit how many ReportTypes to delete.
     */
    limit?: number
  }

  /**
   * ReportType.PatientReport
   */
  export type ReportType$PatientReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientReport
     */
    select?: PatientReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientReport
     */
    omit?: PatientReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientReportInclude<ExtArgs> | null
    where?: PatientReportWhereInput
    orderBy?: PatientReportOrderByWithRelationInput | PatientReportOrderByWithRelationInput[]
    cursor?: PatientReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatientReportScalarFieldEnum | PatientReportScalarFieldEnum[]
  }

  /**
   * ReportType.parameters
   */
  export type ReportType$parametersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportParameter
     */
    select?: ReportParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportParameter
     */
    omit?: ReportParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportParameterInclude<ExtArgs> | null
    where?: ReportParameterWhereInput
    orderBy?: ReportParameterOrderByWithRelationInput | ReportParameterOrderByWithRelationInput[]
    cursor?: ReportParameterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportParameterScalarFieldEnum | ReportParameterScalarFieldEnum[]
  }

  /**
   * ReportType without action
   */
  export type ReportTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportType
     */
    select?: ReportTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportType
     */
    omit?: ReportTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTypeInclude<ExtArgs> | null
  }


  /**
   * Model PatientReport
   */

  export type AggregatePatientReport = {
    _count: PatientReportCountAggregateOutputType | null
    _avg: PatientReportAvgAggregateOutputType | null
    _sum: PatientReportSumAggregateOutputType | null
    _min: PatientReportMinAggregateOutputType | null
    _max: PatientReportMaxAggregateOutputType | null
  }

  export type PatientReportAvgAggregateOutputType = {
    id: number | null
    patientId: number | null
    reportTypeId: number | null
  }

  export type PatientReportSumAggregateOutputType = {
    id: number | null
    patientId: number | null
    reportTypeId: number | null
  }

  export type PatientReportMinAggregateOutputType = {
    id: number | null
    patientId: number | null
    reportTypeId: number | null
    time: Date | null
  }

  export type PatientReportMaxAggregateOutputType = {
    id: number | null
    patientId: number | null
    reportTypeId: number | null
    time: Date | null
  }

  export type PatientReportCountAggregateOutputType = {
    id: number
    patientId: number
    reportTypeId: number
    time: number
    _all: number
  }


  export type PatientReportAvgAggregateInputType = {
    id?: true
    patientId?: true
    reportTypeId?: true
  }

  export type PatientReportSumAggregateInputType = {
    id?: true
    patientId?: true
    reportTypeId?: true
  }

  export type PatientReportMinAggregateInputType = {
    id?: true
    patientId?: true
    reportTypeId?: true
    time?: true
  }

  export type PatientReportMaxAggregateInputType = {
    id?: true
    patientId?: true
    reportTypeId?: true
    time?: true
  }

  export type PatientReportCountAggregateInputType = {
    id?: true
    patientId?: true
    reportTypeId?: true
    time?: true
    _all?: true
  }

  export type PatientReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PatientReport to aggregate.
     */
    where?: PatientReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientReports to fetch.
     */
    orderBy?: PatientReportOrderByWithRelationInput | PatientReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatientReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PatientReports
    **/
    _count?: true | PatientReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PatientReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PatientReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatientReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatientReportMaxAggregateInputType
  }

  export type GetPatientReportAggregateType<T extends PatientReportAggregateArgs> = {
        [P in keyof T & keyof AggregatePatientReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatientReport[P]>
      : GetScalarType<T[P], AggregatePatientReport[P]>
  }




  export type PatientReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientReportWhereInput
    orderBy?: PatientReportOrderByWithAggregationInput | PatientReportOrderByWithAggregationInput[]
    by: PatientReportScalarFieldEnum[] | PatientReportScalarFieldEnum
    having?: PatientReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatientReportCountAggregateInputType | true
    _avg?: PatientReportAvgAggregateInputType
    _sum?: PatientReportSumAggregateInputType
    _min?: PatientReportMinAggregateInputType
    _max?: PatientReportMaxAggregateInputType
  }

  export type PatientReportGroupByOutputType = {
    id: number
    patientId: number
    reportTypeId: number
    time: Date
    _count: PatientReportCountAggregateOutputType | null
    _avg: PatientReportAvgAggregateOutputType | null
    _sum: PatientReportSumAggregateOutputType | null
    _min: PatientReportMinAggregateOutputType | null
    _max: PatientReportMaxAggregateOutputType | null
  }

  type GetPatientReportGroupByPayload<T extends PatientReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatientReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatientReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatientReportGroupByOutputType[P]>
            : GetScalarType<T[P], PatientReportGroupByOutputType[P]>
        }
      >
    >


  export type PatientReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    reportTypeId?: boolean
    time?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    reportType?: boolean | ReportTypeDefaultArgs<ExtArgs>
    parameters?: boolean | PatientReport$parametersArgs<ExtArgs>
    _count?: boolean | PatientReportCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patientReport"]>

  export type PatientReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    reportTypeId?: boolean
    time?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    reportType?: boolean | ReportTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patientReport"]>

  export type PatientReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    reportTypeId?: boolean
    time?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    reportType?: boolean | ReportTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patientReport"]>

  export type PatientReportSelectScalar = {
    id?: boolean
    patientId?: boolean
    reportTypeId?: boolean
    time?: boolean
  }

  export type PatientReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "reportTypeId" | "time", ExtArgs["result"]["patientReport"]>
  export type PatientReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    reportType?: boolean | ReportTypeDefaultArgs<ExtArgs>
    parameters?: boolean | PatientReport$parametersArgs<ExtArgs>
    _count?: boolean | PatientReportCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PatientReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    reportType?: boolean | ReportTypeDefaultArgs<ExtArgs>
  }
  export type PatientReportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    reportType?: boolean | ReportTypeDefaultArgs<ExtArgs>
  }

  export type $PatientReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PatientReport"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      reportType: Prisma.$ReportTypePayload<ExtArgs>
      parameters: Prisma.$ReportValuePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      patientId: number
      reportTypeId: number
      time: Date
    }, ExtArgs["result"]["patientReport"]>
    composites: {}
  }

  type PatientReportGetPayload<S extends boolean | null | undefined | PatientReportDefaultArgs> = $Result.GetResult<Prisma.$PatientReportPayload, S>

  type PatientReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PatientReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PatientReportCountAggregateInputType | true
    }

  export interface PatientReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PatientReport'], meta: { name: 'PatientReport' } }
    /**
     * Find zero or one PatientReport that matches the filter.
     * @param {PatientReportFindUniqueArgs} args - Arguments to find a PatientReport
     * @example
     * // Get one PatientReport
     * const patientReport = await prisma.patientReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PatientReportFindUniqueArgs>(args: SelectSubset<T, PatientReportFindUniqueArgs<ExtArgs>>): Prisma__PatientReportClient<$Result.GetResult<Prisma.$PatientReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PatientReport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PatientReportFindUniqueOrThrowArgs} args - Arguments to find a PatientReport
     * @example
     * // Get one PatientReport
     * const patientReport = await prisma.patientReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PatientReportFindUniqueOrThrowArgs>(args: SelectSubset<T, PatientReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PatientReportClient<$Result.GetResult<Prisma.$PatientReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PatientReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientReportFindFirstArgs} args - Arguments to find a PatientReport
     * @example
     * // Get one PatientReport
     * const patientReport = await prisma.patientReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PatientReportFindFirstArgs>(args?: SelectSubset<T, PatientReportFindFirstArgs<ExtArgs>>): Prisma__PatientReportClient<$Result.GetResult<Prisma.$PatientReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PatientReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientReportFindFirstOrThrowArgs} args - Arguments to find a PatientReport
     * @example
     * // Get one PatientReport
     * const patientReport = await prisma.patientReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PatientReportFindFirstOrThrowArgs>(args?: SelectSubset<T, PatientReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__PatientReportClient<$Result.GetResult<Prisma.$PatientReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PatientReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PatientReports
     * const patientReports = await prisma.patientReport.findMany()
     * 
     * // Get first 10 PatientReports
     * const patientReports = await prisma.patientReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patientReportWithIdOnly = await prisma.patientReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PatientReportFindManyArgs>(args?: SelectSubset<T, PatientReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PatientReport.
     * @param {PatientReportCreateArgs} args - Arguments to create a PatientReport.
     * @example
     * // Create one PatientReport
     * const PatientReport = await prisma.patientReport.create({
     *   data: {
     *     // ... data to create a PatientReport
     *   }
     * })
     * 
     */
    create<T extends PatientReportCreateArgs>(args: SelectSubset<T, PatientReportCreateArgs<ExtArgs>>): Prisma__PatientReportClient<$Result.GetResult<Prisma.$PatientReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PatientReports.
     * @param {PatientReportCreateManyArgs} args - Arguments to create many PatientReports.
     * @example
     * // Create many PatientReports
     * const patientReport = await prisma.patientReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PatientReportCreateManyArgs>(args?: SelectSubset<T, PatientReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PatientReports and returns the data saved in the database.
     * @param {PatientReportCreateManyAndReturnArgs} args - Arguments to create many PatientReports.
     * @example
     * // Create many PatientReports
     * const patientReport = await prisma.patientReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PatientReports and only return the `id`
     * const patientReportWithIdOnly = await prisma.patientReport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PatientReportCreateManyAndReturnArgs>(args?: SelectSubset<T, PatientReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PatientReport.
     * @param {PatientReportDeleteArgs} args - Arguments to delete one PatientReport.
     * @example
     * // Delete one PatientReport
     * const PatientReport = await prisma.patientReport.delete({
     *   where: {
     *     // ... filter to delete one PatientReport
     *   }
     * })
     * 
     */
    delete<T extends PatientReportDeleteArgs>(args: SelectSubset<T, PatientReportDeleteArgs<ExtArgs>>): Prisma__PatientReportClient<$Result.GetResult<Prisma.$PatientReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PatientReport.
     * @param {PatientReportUpdateArgs} args - Arguments to update one PatientReport.
     * @example
     * // Update one PatientReport
     * const patientReport = await prisma.patientReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PatientReportUpdateArgs>(args: SelectSubset<T, PatientReportUpdateArgs<ExtArgs>>): Prisma__PatientReportClient<$Result.GetResult<Prisma.$PatientReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PatientReports.
     * @param {PatientReportDeleteManyArgs} args - Arguments to filter PatientReports to delete.
     * @example
     * // Delete a few PatientReports
     * const { count } = await prisma.patientReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PatientReportDeleteManyArgs>(args?: SelectSubset<T, PatientReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PatientReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PatientReports
     * const patientReport = await prisma.patientReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PatientReportUpdateManyArgs>(args: SelectSubset<T, PatientReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PatientReports and returns the data updated in the database.
     * @param {PatientReportUpdateManyAndReturnArgs} args - Arguments to update many PatientReports.
     * @example
     * // Update many PatientReports
     * const patientReport = await prisma.patientReport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PatientReports and only return the `id`
     * const patientReportWithIdOnly = await prisma.patientReport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PatientReportUpdateManyAndReturnArgs>(args: SelectSubset<T, PatientReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PatientReport.
     * @param {PatientReportUpsertArgs} args - Arguments to update or create a PatientReport.
     * @example
     * // Update or create a PatientReport
     * const patientReport = await prisma.patientReport.upsert({
     *   create: {
     *     // ... data to create a PatientReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PatientReport we want to update
     *   }
     * })
     */
    upsert<T extends PatientReportUpsertArgs>(args: SelectSubset<T, PatientReportUpsertArgs<ExtArgs>>): Prisma__PatientReportClient<$Result.GetResult<Prisma.$PatientReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PatientReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientReportCountArgs} args - Arguments to filter PatientReports to count.
     * @example
     * // Count the number of PatientReports
     * const count = await prisma.patientReport.count({
     *   where: {
     *     // ... the filter for the PatientReports we want to count
     *   }
     * })
    **/
    count<T extends PatientReportCountArgs>(
      args?: Subset<T, PatientReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatientReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PatientReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatientReportAggregateArgs>(args: Subset<T, PatientReportAggregateArgs>): Prisma.PrismaPromise<GetPatientReportAggregateType<T>>

    /**
     * Group by PatientReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatientReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatientReportGroupByArgs['orderBy'] }
        : { orderBy?: PatientReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatientReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatientReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PatientReport model
   */
  readonly fields: PatientReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PatientReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatientReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reportType<T extends ReportTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReportTypeDefaultArgs<ExtArgs>>): Prisma__ReportTypeClient<$Result.GetResult<Prisma.$ReportTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parameters<T extends PatientReport$parametersArgs<ExtArgs> = {}>(args?: Subset<T, PatientReport$parametersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PatientReport model
   */ 
  interface PatientReportFieldRefs {
    readonly id: FieldRef<"PatientReport", 'Int'>
    readonly patientId: FieldRef<"PatientReport", 'Int'>
    readonly reportTypeId: FieldRef<"PatientReport", 'Int'>
    readonly time: FieldRef<"PatientReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PatientReport findUnique
   */
  export type PatientReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientReport
     */
    select?: PatientReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientReport
     */
    omit?: PatientReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientReportInclude<ExtArgs> | null
    /**
     * Filter, which PatientReport to fetch.
     */
    where: PatientReportWhereUniqueInput
  }

  /**
   * PatientReport findUniqueOrThrow
   */
  export type PatientReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientReport
     */
    select?: PatientReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientReport
     */
    omit?: PatientReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientReportInclude<ExtArgs> | null
    /**
     * Filter, which PatientReport to fetch.
     */
    where: PatientReportWhereUniqueInput
  }

  /**
   * PatientReport findFirst
   */
  export type PatientReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientReport
     */
    select?: PatientReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientReport
     */
    omit?: PatientReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientReportInclude<ExtArgs> | null
    /**
     * Filter, which PatientReport to fetch.
     */
    where?: PatientReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientReports to fetch.
     */
    orderBy?: PatientReportOrderByWithRelationInput | PatientReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PatientReports.
     */
    cursor?: PatientReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PatientReports.
     */
    distinct?: PatientReportScalarFieldEnum | PatientReportScalarFieldEnum[]
  }

  /**
   * PatientReport findFirstOrThrow
   */
  export type PatientReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientReport
     */
    select?: PatientReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientReport
     */
    omit?: PatientReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientReportInclude<ExtArgs> | null
    /**
     * Filter, which PatientReport to fetch.
     */
    where?: PatientReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientReports to fetch.
     */
    orderBy?: PatientReportOrderByWithRelationInput | PatientReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PatientReports.
     */
    cursor?: PatientReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PatientReports.
     */
    distinct?: PatientReportScalarFieldEnum | PatientReportScalarFieldEnum[]
  }

  /**
   * PatientReport findMany
   */
  export type PatientReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientReport
     */
    select?: PatientReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientReport
     */
    omit?: PatientReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientReportInclude<ExtArgs> | null
    /**
     * Filter, which PatientReports to fetch.
     */
    where?: PatientReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientReports to fetch.
     */
    orderBy?: PatientReportOrderByWithRelationInput | PatientReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PatientReports.
     */
    cursor?: PatientReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientReports.
     */
    skip?: number
    distinct?: PatientReportScalarFieldEnum | PatientReportScalarFieldEnum[]
  }

  /**
   * PatientReport create
   */
  export type PatientReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientReport
     */
    select?: PatientReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientReport
     */
    omit?: PatientReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientReportInclude<ExtArgs> | null
    /**
     * The data needed to create a PatientReport.
     */
    data: XOR<PatientReportCreateInput, PatientReportUncheckedCreateInput>
  }

  /**
   * PatientReport createMany
   */
  export type PatientReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PatientReports.
     */
    data: PatientReportCreateManyInput | PatientReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PatientReport createManyAndReturn
   */
  export type PatientReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientReport
     */
    select?: PatientReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PatientReport
     */
    omit?: PatientReportOmit<ExtArgs> | null
    /**
     * The data used to create many PatientReports.
     */
    data: PatientReportCreateManyInput | PatientReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PatientReport update
   */
  export type PatientReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientReport
     */
    select?: PatientReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientReport
     */
    omit?: PatientReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientReportInclude<ExtArgs> | null
    /**
     * The data needed to update a PatientReport.
     */
    data: XOR<PatientReportUpdateInput, PatientReportUncheckedUpdateInput>
    /**
     * Choose, which PatientReport to update.
     */
    where: PatientReportWhereUniqueInput
  }

  /**
   * PatientReport updateMany
   */
  export type PatientReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PatientReports.
     */
    data: XOR<PatientReportUpdateManyMutationInput, PatientReportUncheckedUpdateManyInput>
    /**
     * Filter which PatientReports to update
     */
    where?: PatientReportWhereInput
    /**
     * Limit how many PatientReports to update.
     */
    limit?: number
  }

  /**
   * PatientReport updateManyAndReturn
   */
  export type PatientReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientReport
     */
    select?: PatientReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PatientReport
     */
    omit?: PatientReportOmit<ExtArgs> | null
    /**
     * The data used to update PatientReports.
     */
    data: XOR<PatientReportUpdateManyMutationInput, PatientReportUncheckedUpdateManyInput>
    /**
     * Filter which PatientReports to update
     */
    where?: PatientReportWhereInput
    /**
     * Limit how many PatientReports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientReportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PatientReport upsert
   */
  export type PatientReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientReport
     */
    select?: PatientReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientReport
     */
    omit?: PatientReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientReportInclude<ExtArgs> | null
    /**
     * The filter to search for the PatientReport to update in case it exists.
     */
    where: PatientReportWhereUniqueInput
    /**
     * In case the PatientReport found by the `where` argument doesn't exist, create a new PatientReport with this data.
     */
    create: XOR<PatientReportCreateInput, PatientReportUncheckedCreateInput>
    /**
     * In case the PatientReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatientReportUpdateInput, PatientReportUncheckedUpdateInput>
  }

  /**
   * PatientReport delete
   */
  export type PatientReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientReport
     */
    select?: PatientReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientReport
     */
    omit?: PatientReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientReportInclude<ExtArgs> | null
    /**
     * Filter which PatientReport to delete.
     */
    where: PatientReportWhereUniqueInput
  }

  /**
   * PatientReport deleteMany
   */
  export type PatientReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PatientReports to delete
     */
    where?: PatientReportWhereInput
    /**
     * Limit how many PatientReports to delete.
     */
    limit?: number
  }

  /**
   * PatientReport.parameters
   */
  export type PatientReport$parametersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportValue
     */
    select?: ReportValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportValue
     */
    omit?: ReportValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportValueInclude<ExtArgs> | null
    where?: ReportValueWhereInput
    orderBy?: ReportValueOrderByWithRelationInput | ReportValueOrderByWithRelationInput[]
    cursor?: ReportValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportValueScalarFieldEnum | ReportValueScalarFieldEnum[]
  }

  /**
   * PatientReport without action
   */
  export type PatientReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientReport
     */
    select?: PatientReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientReport
     */
    omit?: PatientReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientReportInclude<ExtArgs> | null
  }


  /**
   * Model ReportValue
   */

  export type AggregateReportValue = {
    _count: ReportValueCountAggregateOutputType | null
    _avg: ReportValueAvgAggregateOutputType | null
    _sum: ReportValueSumAggregateOutputType | null
    _min: ReportValueMinAggregateOutputType | null
    _max: ReportValueMaxAggregateOutputType | null
  }

  export type ReportValueAvgAggregateOutputType = {
    id: number | null
    reportParameterId: number | null
    patientReportId: number | null
  }

  export type ReportValueSumAggregateOutputType = {
    id: number | null
    reportParameterId: number | null
    patientReportId: number | null
  }

  export type ReportValueMinAggregateOutputType = {
    id: number | null
    reportParameterId: number | null
    attention: boolean | null
    value: string | null
    patientReportId: number | null
  }

  export type ReportValueMaxAggregateOutputType = {
    id: number | null
    reportParameterId: number | null
    attention: boolean | null
    value: string | null
    patientReportId: number | null
  }

  export type ReportValueCountAggregateOutputType = {
    id: number
    reportParameterId: number
    attention: number
    value: number
    patientReportId: number
    _all: number
  }


  export type ReportValueAvgAggregateInputType = {
    id?: true
    reportParameterId?: true
    patientReportId?: true
  }

  export type ReportValueSumAggregateInputType = {
    id?: true
    reportParameterId?: true
    patientReportId?: true
  }

  export type ReportValueMinAggregateInputType = {
    id?: true
    reportParameterId?: true
    attention?: true
    value?: true
    patientReportId?: true
  }

  export type ReportValueMaxAggregateInputType = {
    id?: true
    reportParameterId?: true
    attention?: true
    value?: true
    patientReportId?: true
  }

  export type ReportValueCountAggregateInputType = {
    id?: true
    reportParameterId?: true
    attention?: true
    value?: true
    patientReportId?: true
    _all?: true
  }

  export type ReportValueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportValue to aggregate.
     */
    where?: ReportValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportValues to fetch.
     */
    orderBy?: ReportValueOrderByWithRelationInput | ReportValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReportValues
    **/
    _count?: true | ReportValueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReportValueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReportValueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportValueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportValueMaxAggregateInputType
  }

  export type GetReportValueAggregateType<T extends ReportValueAggregateArgs> = {
        [P in keyof T & keyof AggregateReportValue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReportValue[P]>
      : GetScalarType<T[P], AggregateReportValue[P]>
  }




  export type ReportValueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportValueWhereInput
    orderBy?: ReportValueOrderByWithAggregationInput | ReportValueOrderByWithAggregationInput[]
    by: ReportValueScalarFieldEnum[] | ReportValueScalarFieldEnum
    having?: ReportValueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportValueCountAggregateInputType | true
    _avg?: ReportValueAvgAggregateInputType
    _sum?: ReportValueSumAggregateInputType
    _min?: ReportValueMinAggregateInputType
    _max?: ReportValueMaxAggregateInputType
  }

  export type ReportValueGroupByOutputType = {
    id: number
    reportParameterId: number
    attention: boolean
    value: string
    patientReportId: number | null
    _count: ReportValueCountAggregateOutputType | null
    _avg: ReportValueAvgAggregateOutputType | null
    _sum: ReportValueSumAggregateOutputType | null
    _min: ReportValueMinAggregateOutputType | null
    _max: ReportValueMaxAggregateOutputType | null
  }

  type GetReportValueGroupByPayload<T extends ReportValueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportValueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportValueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportValueGroupByOutputType[P]>
            : GetScalarType<T[P], ReportValueGroupByOutputType[P]>
        }
      >
    >


  export type ReportValueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reportParameterId?: boolean
    attention?: boolean
    value?: boolean
    patientReportId?: boolean
    PatientReport?: boolean | ReportValue$PatientReportArgs<ExtArgs>
    reportParameter?: boolean | ReportParameterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportValue"]>

  export type ReportValueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reportParameterId?: boolean
    attention?: boolean
    value?: boolean
    patientReportId?: boolean
    PatientReport?: boolean | ReportValue$PatientReportArgs<ExtArgs>
    reportParameter?: boolean | ReportParameterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportValue"]>

  export type ReportValueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reportParameterId?: boolean
    attention?: boolean
    value?: boolean
    patientReportId?: boolean
    PatientReport?: boolean | ReportValue$PatientReportArgs<ExtArgs>
    reportParameter?: boolean | ReportParameterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportValue"]>

  export type ReportValueSelectScalar = {
    id?: boolean
    reportParameterId?: boolean
    attention?: boolean
    value?: boolean
    patientReportId?: boolean
  }

  export type ReportValueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "reportParameterId" | "attention" | "value" | "patientReportId", ExtArgs["result"]["reportValue"]>
  export type ReportValueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PatientReport?: boolean | ReportValue$PatientReportArgs<ExtArgs>
    reportParameter?: boolean | ReportParameterDefaultArgs<ExtArgs>
  }
  export type ReportValueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PatientReport?: boolean | ReportValue$PatientReportArgs<ExtArgs>
    reportParameter?: boolean | ReportParameterDefaultArgs<ExtArgs>
  }
  export type ReportValueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PatientReport?: boolean | ReportValue$PatientReportArgs<ExtArgs>
    reportParameter?: boolean | ReportParameterDefaultArgs<ExtArgs>
  }

  export type $ReportValuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReportValue"
    objects: {
      PatientReport: Prisma.$PatientReportPayload<ExtArgs> | null
      reportParameter: Prisma.$ReportParameterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      reportParameterId: number
      attention: boolean
      value: string
      patientReportId: number | null
    }, ExtArgs["result"]["reportValue"]>
    composites: {}
  }

  type ReportValueGetPayload<S extends boolean | null | undefined | ReportValueDefaultArgs> = $Result.GetResult<Prisma.$ReportValuePayload, S>

  type ReportValueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReportValueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReportValueCountAggregateInputType | true
    }

  export interface ReportValueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReportValue'], meta: { name: 'ReportValue' } }
    /**
     * Find zero or one ReportValue that matches the filter.
     * @param {ReportValueFindUniqueArgs} args - Arguments to find a ReportValue
     * @example
     * // Get one ReportValue
     * const reportValue = await prisma.reportValue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportValueFindUniqueArgs>(args: SelectSubset<T, ReportValueFindUniqueArgs<ExtArgs>>): Prisma__ReportValueClient<$Result.GetResult<Prisma.$ReportValuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReportValue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReportValueFindUniqueOrThrowArgs} args - Arguments to find a ReportValue
     * @example
     * // Get one ReportValue
     * const reportValue = await prisma.reportValue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportValueFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportValueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportValueClient<$Result.GetResult<Prisma.$ReportValuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReportValue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportValueFindFirstArgs} args - Arguments to find a ReportValue
     * @example
     * // Get one ReportValue
     * const reportValue = await prisma.reportValue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportValueFindFirstArgs>(args?: SelectSubset<T, ReportValueFindFirstArgs<ExtArgs>>): Prisma__ReportValueClient<$Result.GetResult<Prisma.$ReportValuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReportValue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportValueFindFirstOrThrowArgs} args - Arguments to find a ReportValue
     * @example
     * // Get one ReportValue
     * const reportValue = await prisma.reportValue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportValueFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportValueFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportValueClient<$Result.GetResult<Prisma.$ReportValuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReportValues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportValueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReportValues
     * const reportValues = await prisma.reportValue.findMany()
     * 
     * // Get first 10 ReportValues
     * const reportValues = await prisma.reportValue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportValueWithIdOnly = await prisma.reportValue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportValueFindManyArgs>(args?: SelectSubset<T, ReportValueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReportValue.
     * @param {ReportValueCreateArgs} args - Arguments to create a ReportValue.
     * @example
     * // Create one ReportValue
     * const ReportValue = await prisma.reportValue.create({
     *   data: {
     *     // ... data to create a ReportValue
     *   }
     * })
     * 
     */
    create<T extends ReportValueCreateArgs>(args: SelectSubset<T, ReportValueCreateArgs<ExtArgs>>): Prisma__ReportValueClient<$Result.GetResult<Prisma.$ReportValuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReportValues.
     * @param {ReportValueCreateManyArgs} args - Arguments to create many ReportValues.
     * @example
     * // Create many ReportValues
     * const reportValue = await prisma.reportValue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportValueCreateManyArgs>(args?: SelectSubset<T, ReportValueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReportValues and returns the data saved in the database.
     * @param {ReportValueCreateManyAndReturnArgs} args - Arguments to create many ReportValues.
     * @example
     * // Create many ReportValues
     * const reportValue = await prisma.reportValue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReportValues and only return the `id`
     * const reportValueWithIdOnly = await prisma.reportValue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReportValueCreateManyAndReturnArgs>(args?: SelectSubset<T, ReportValueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportValuePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReportValue.
     * @param {ReportValueDeleteArgs} args - Arguments to delete one ReportValue.
     * @example
     * // Delete one ReportValue
     * const ReportValue = await prisma.reportValue.delete({
     *   where: {
     *     // ... filter to delete one ReportValue
     *   }
     * })
     * 
     */
    delete<T extends ReportValueDeleteArgs>(args: SelectSubset<T, ReportValueDeleteArgs<ExtArgs>>): Prisma__ReportValueClient<$Result.GetResult<Prisma.$ReportValuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReportValue.
     * @param {ReportValueUpdateArgs} args - Arguments to update one ReportValue.
     * @example
     * // Update one ReportValue
     * const reportValue = await prisma.reportValue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportValueUpdateArgs>(args: SelectSubset<T, ReportValueUpdateArgs<ExtArgs>>): Prisma__ReportValueClient<$Result.GetResult<Prisma.$ReportValuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReportValues.
     * @param {ReportValueDeleteManyArgs} args - Arguments to filter ReportValues to delete.
     * @example
     * // Delete a few ReportValues
     * const { count } = await prisma.reportValue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportValueDeleteManyArgs>(args?: SelectSubset<T, ReportValueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportValueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReportValues
     * const reportValue = await prisma.reportValue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportValueUpdateManyArgs>(args: SelectSubset<T, ReportValueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportValues and returns the data updated in the database.
     * @param {ReportValueUpdateManyAndReturnArgs} args - Arguments to update many ReportValues.
     * @example
     * // Update many ReportValues
     * const reportValue = await prisma.reportValue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReportValues and only return the `id`
     * const reportValueWithIdOnly = await prisma.reportValue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReportValueUpdateManyAndReturnArgs>(args: SelectSubset<T, ReportValueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportValuePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReportValue.
     * @param {ReportValueUpsertArgs} args - Arguments to update or create a ReportValue.
     * @example
     * // Update or create a ReportValue
     * const reportValue = await prisma.reportValue.upsert({
     *   create: {
     *     // ... data to create a ReportValue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReportValue we want to update
     *   }
     * })
     */
    upsert<T extends ReportValueUpsertArgs>(args: SelectSubset<T, ReportValueUpsertArgs<ExtArgs>>): Prisma__ReportValueClient<$Result.GetResult<Prisma.$ReportValuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReportValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportValueCountArgs} args - Arguments to filter ReportValues to count.
     * @example
     * // Count the number of ReportValues
     * const count = await prisma.reportValue.count({
     *   where: {
     *     // ... the filter for the ReportValues we want to count
     *   }
     * })
    **/
    count<T extends ReportValueCountArgs>(
      args?: Subset<T, ReportValueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportValueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReportValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportValueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportValueAggregateArgs>(args: Subset<T, ReportValueAggregateArgs>): Prisma.PrismaPromise<GetReportValueAggregateType<T>>

    /**
     * Group by ReportValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportValueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportValueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportValueGroupByArgs['orderBy'] }
        : { orderBy?: ReportValueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportValueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportValueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReportValue model
   */
  readonly fields: ReportValueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReportValue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportValueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    PatientReport<T extends ReportValue$PatientReportArgs<ExtArgs> = {}>(args?: Subset<T, ReportValue$PatientReportArgs<ExtArgs>>): Prisma__PatientReportClient<$Result.GetResult<Prisma.$PatientReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    reportParameter<T extends ReportParameterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReportParameterDefaultArgs<ExtArgs>>): Prisma__ReportParameterClient<$Result.GetResult<Prisma.$ReportParameterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReportValue model
   */ 
  interface ReportValueFieldRefs {
    readonly id: FieldRef<"ReportValue", 'Int'>
    readonly reportParameterId: FieldRef<"ReportValue", 'Int'>
    readonly attention: FieldRef<"ReportValue", 'Boolean'>
    readonly value: FieldRef<"ReportValue", 'String'>
    readonly patientReportId: FieldRef<"ReportValue", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ReportValue findUnique
   */
  export type ReportValueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportValue
     */
    select?: ReportValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportValue
     */
    omit?: ReportValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportValueInclude<ExtArgs> | null
    /**
     * Filter, which ReportValue to fetch.
     */
    where: ReportValueWhereUniqueInput
  }

  /**
   * ReportValue findUniqueOrThrow
   */
  export type ReportValueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportValue
     */
    select?: ReportValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportValue
     */
    omit?: ReportValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportValueInclude<ExtArgs> | null
    /**
     * Filter, which ReportValue to fetch.
     */
    where: ReportValueWhereUniqueInput
  }

  /**
   * ReportValue findFirst
   */
  export type ReportValueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportValue
     */
    select?: ReportValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportValue
     */
    omit?: ReportValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportValueInclude<ExtArgs> | null
    /**
     * Filter, which ReportValue to fetch.
     */
    where?: ReportValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportValues to fetch.
     */
    orderBy?: ReportValueOrderByWithRelationInput | ReportValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportValues.
     */
    cursor?: ReportValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportValues.
     */
    distinct?: ReportValueScalarFieldEnum | ReportValueScalarFieldEnum[]
  }

  /**
   * ReportValue findFirstOrThrow
   */
  export type ReportValueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportValue
     */
    select?: ReportValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportValue
     */
    omit?: ReportValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportValueInclude<ExtArgs> | null
    /**
     * Filter, which ReportValue to fetch.
     */
    where?: ReportValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportValues to fetch.
     */
    orderBy?: ReportValueOrderByWithRelationInput | ReportValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportValues.
     */
    cursor?: ReportValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportValues.
     */
    distinct?: ReportValueScalarFieldEnum | ReportValueScalarFieldEnum[]
  }

  /**
   * ReportValue findMany
   */
  export type ReportValueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportValue
     */
    select?: ReportValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportValue
     */
    omit?: ReportValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportValueInclude<ExtArgs> | null
    /**
     * Filter, which ReportValues to fetch.
     */
    where?: ReportValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportValues to fetch.
     */
    orderBy?: ReportValueOrderByWithRelationInput | ReportValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReportValues.
     */
    cursor?: ReportValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportValues.
     */
    skip?: number
    distinct?: ReportValueScalarFieldEnum | ReportValueScalarFieldEnum[]
  }

  /**
   * ReportValue create
   */
  export type ReportValueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportValue
     */
    select?: ReportValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportValue
     */
    omit?: ReportValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportValueInclude<ExtArgs> | null
    /**
     * The data needed to create a ReportValue.
     */
    data: XOR<ReportValueCreateInput, ReportValueUncheckedCreateInput>
  }

  /**
   * ReportValue createMany
   */
  export type ReportValueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReportValues.
     */
    data: ReportValueCreateManyInput | ReportValueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReportValue createManyAndReturn
   */
  export type ReportValueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportValue
     */
    select?: ReportValueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReportValue
     */
    omit?: ReportValueOmit<ExtArgs> | null
    /**
     * The data used to create many ReportValues.
     */
    data: ReportValueCreateManyInput | ReportValueCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportValueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReportValue update
   */
  export type ReportValueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportValue
     */
    select?: ReportValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportValue
     */
    omit?: ReportValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportValueInclude<ExtArgs> | null
    /**
     * The data needed to update a ReportValue.
     */
    data: XOR<ReportValueUpdateInput, ReportValueUncheckedUpdateInput>
    /**
     * Choose, which ReportValue to update.
     */
    where: ReportValueWhereUniqueInput
  }

  /**
   * ReportValue updateMany
   */
  export type ReportValueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReportValues.
     */
    data: XOR<ReportValueUpdateManyMutationInput, ReportValueUncheckedUpdateManyInput>
    /**
     * Filter which ReportValues to update
     */
    where?: ReportValueWhereInput
    /**
     * Limit how many ReportValues to update.
     */
    limit?: number
  }

  /**
   * ReportValue updateManyAndReturn
   */
  export type ReportValueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportValue
     */
    select?: ReportValueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReportValue
     */
    omit?: ReportValueOmit<ExtArgs> | null
    /**
     * The data used to update ReportValues.
     */
    data: XOR<ReportValueUpdateManyMutationInput, ReportValueUncheckedUpdateManyInput>
    /**
     * Filter which ReportValues to update
     */
    where?: ReportValueWhereInput
    /**
     * Limit how many ReportValues to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportValueIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReportValue upsert
   */
  export type ReportValueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportValue
     */
    select?: ReportValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportValue
     */
    omit?: ReportValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportValueInclude<ExtArgs> | null
    /**
     * The filter to search for the ReportValue to update in case it exists.
     */
    where: ReportValueWhereUniqueInput
    /**
     * In case the ReportValue found by the `where` argument doesn't exist, create a new ReportValue with this data.
     */
    create: XOR<ReportValueCreateInput, ReportValueUncheckedCreateInput>
    /**
     * In case the ReportValue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportValueUpdateInput, ReportValueUncheckedUpdateInput>
  }

  /**
   * ReportValue delete
   */
  export type ReportValueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportValue
     */
    select?: ReportValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportValue
     */
    omit?: ReportValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportValueInclude<ExtArgs> | null
    /**
     * Filter which ReportValue to delete.
     */
    where: ReportValueWhereUniqueInput
  }

  /**
   * ReportValue deleteMany
   */
  export type ReportValueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportValues to delete
     */
    where?: ReportValueWhereInput
    /**
     * Limit how many ReportValues to delete.
     */
    limit?: number
  }

  /**
   * ReportValue.PatientReport
   */
  export type ReportValue$PatientReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientReport
     */
    select?: PatientReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientReport
     */
    omit?: PatientReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientReportInclude<ExtArgs> | null
    where?: PatientReportWhereInput
  }

  /**
   * ReportValue without action
   */
  export type ReportValueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportValue
     */
    select?: ReportValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportValue
     */
    omit?: ReportValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportValueInclude<ExtArgs> | null
  }


  /**
   * Model StratergyHistory
   */

  export type AggregateStratergyHistory = {
    _count: StratergyHistoryCountAggregateOutputType | null
    _avg: StratergyHistoryAvgAggregateOutputType | null
    _sum: StratergyHistorySumAggregateOutputType | null
    _min: StratergyHistoryMinAggregateOutputType | null
    _max: StratergyHistoryMaxAggregateOutputType | null
  }

  export type StratergyHistoryAvgAggregateOutputType = {
    id: number | null
    drugId: number | null
    issueId: number | null
  }

  export type StratergyHistorySumAggregateOutputType = {
    id: number | null
    drugId: number | null
    issueId: number | null
  }

  export type StratergyHistoryMinAggregateOutputType = {
    id: number | null
    drugId: number | null
    issueId: number | null
  }

  export type StratergyHistoryMaxAggregateOutputType = {
    id: number | null
    drugId: number | null
    issueId: number | null
  }

  export type StratergyHistoryCountAggregateOutputType = {
    id: number
    drugId: number
    issueId: number
    _all: number
  }


  export type StratergyHistoryAvgAggregateInputType = {
    id?: true
    drugId?: true
    issueId?: true
  }

  export type StratergyHistorySumAggregateInputType = {
    id?: true
    drugId?: true
    issueId?: true
  }

  export type StratergyHistoryMinAggregateInputType = {
    id?: true
    drugId?: true
    issueId?: true
  }

  export type StratergyHistoryMaxAggregateInputType = {
    id?: true
    drugId?: true
    issueId?: true
  }

  export type StratergyHistoryCountAggregateInputType = {
    id?: true
    drugId?: true
    issueId?: true
    _all?: true
  }

  export type StratergyHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StratergyHistory to aggregate.
     */
    where?: StratergyHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StratergyHistories to fetch.
     */
    orderBy?: StratergyHistoryOrderByWithRelationInput | StratergyHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StratergyHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StratergyHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StratergyHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StratergyHistories
    **/
    _count?: true | StratergyHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StratergyHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StratergyHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StratergyHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StratergyHistoryMaxAggregateInputType
  }

  export type GetStratergyHistoryAggregateType<T extends StratergyHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateStratergyHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStratergyHistory[P]>
      : GetScalarType<T[P], AggregateStratergyHistory[P]>
  }




  export type StratergyHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StratergyHistoryWhereInput
    orderBy?: StratergyHistoryOrderByWithAggregationInput | StratergyHistoryOrderByWithAggregationInput[]
    by: StratergyHistoryScalarFieldEnum[] | StratergyHistoryScalarFieldEnum
    having?: StratergyHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StratergyHistoryCountAggregateInputType | true
    _avg?: StratergyHistoryAvgAggregateInputType
    _sum?: StratergyHistorySumAggregateInputType
    _min?: StratergyHistoryMinAggregateInputType
    _max?: StratergyHistoryMaxAggregateInputType
  }

  export type StratergyHistoryGroupByOutputType = {
    id: number
    drugId: number
    issueId: number
    _count: StratergyHistoryCountAggregateOutputType | null
    _avg: StratergyHistoryAvgAggregateOutputType | null
    _sum: StratergyHistorySumAggregateOutputType | null
    _min: StratergyHistoryMinAggregateOutputType | null
    _max: StratergyHistoryMaxAggregateOutputType | null
  }

  type GetStratergyHistoryGroupByPayload<T extends StratergyHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StratergyHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StratergyHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StratergyHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], StratergyHistoryGroupByOutputType[P]>
        }
      >
    >


  export type StratergyHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    drugId?: boolean
    issueId?: boolean
    drug?: boolean | DrugDefaultArgs<ExtArgs>
    issue?: boolean | IssueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stratergyHistory"]>

  export type StratergyHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    drugId?: boolean
    issueId?: boolean
    drug?: boolean | DrugDefaultArgs<ExtArgs>
    issue?: boolean | IssueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stratergyHistory"]>

  export type StratergyHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    drugId?: boolean
    issueId?: boolean
    drug?: boolean | DrugDefaultArgs<ExtArgs>
    issue?: boolean | IssueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stratergyHistory"]>

  export type StratergyHistorySelectScalar = {
    id?: boolean
    drugId?: boolean
    issueId?: boolean
  }

  export type StratergyHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "drugId" | "issueId", ExtArgs["result"]["stratergyHistory"]>
  export type StratergyHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    drug?: boolean | DrugDefaultArgs<ExtArgs>
    issue?: boolean | IssueDefaultArgs<ExtArgs>
  }
  export type StratergyHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    drug?: boolean | DrugDefaultArgs<ExtArgs>
    issue?: boolean | IssueDefaultArgs<ExtArgs>
  }
  export type StratergyHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    drug?: boolean | DrugDefaultArgs<ExtArgs>
    issue?: boolean | IssueDefaultArgs<ExtArgs>
  }

  export type $StratergyHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StratergyHistory"
    objects: {
      drug: Prisma.$DrugPayload<ExtArgs>
      issue: Prisma.$IssuePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      drugId: number
      issueId: number
    }, ExtArgs["result"]["stratergyHistory"]>
    composites: {}
  }

  type StratergyHistoryGetPayload<S extends boolean | null | undefined | StratergyHistoryDefaultArgs> = $Result.GetResult<Prisma.$StratergyHistoryPayload, S>

  type StratergyHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StratergyHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StratergyHistoryCountAggregateInputType | true
    }

  export interface StratergyHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StratergyHistory'], meta: { name: 'StratergyHistory' } }
    /**
     * Find zero or one StratergyHistory that matches the filter.
     * @param {StratergyHistoryFindUniqueArgs} args - Arguments to find a StratergyHistory
     * @example
     * // Get one StratergyHistory
     * const stratergyHistory = await prisma.stratergyHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StratergyHistoryFindUniqueArgs>(args: SelectSubset<T, StratergyHistoryFindUniqueArgs<ExtArgs>>): Prisma__StratergyHistoryClient<$Result.GetResult<Prisma.$StratergyHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StratergyHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StratergyHistoryFindUniqueOrThrowArgs} args - Arguments to find a StratergyHistory
     * @example
     * // Get one StratergyHistory
     * const stratergyHistory = await prisma.stratergyHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StratergyHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, StratergyHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StratergyHistoryClient<$Result.GetResult<Prisma.$StratergyHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StratergyHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StratergyHistoryFindFirstArgs} args - Arguments to find a StratergyHistory
     * @example
     * // Get one StratergyHistory
     * const stratergyHistory = await prisma.stratergyHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StratergyHistoryFindFirstArgs>(args?: SelectSubset<T, StratergyHistoryFindFirstArgs<ExtArgs>>): Prisma__StratergyHistoryClient<$Result.GetResult<Prisma.$StratergyHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StratergyHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StratergyHistoryFindFirstOrThrowArgs} args - Arguments to find a StratergyHistory
     * @example
     * // Get one StratergyHistory
     * const stratergyHistory = await prisma.stratergyHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StratergyHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, StratergyHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__StratergyHistoryClient<$Result.GetResult<Prisma.$StratergyHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StratergyHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StratergyHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StratergyHistories
     * const stratergyHistories = await prisma.stratergyHistory.findMany()
     * 
     * // Get first 10 StratergyHistories
     * const stratergyHistories = await prisma.stratergyHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stratergyHistoryWithIdOnly = await prisma.stratergyHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StratergyHistoryFindManyArgs>(args?: SelectSubset<T, StratergyHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StratergyHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StratergyHistory.
     * @param {StratergyHistoryCreateArgs} args - Arguments to create a StratergyHistory.
     * @example
     * // Create one StratergyHistory
     * const StratergyHistory = await prisma.stratergyHistory.create({
     *   data: {
     *     // ... data to create a StratergyHistory
     *   }
     * })
     * 
     */
    create<T extends StratergyHistoryCreateArgs>(args: SelectSubset<T, StratergyHistoryCreateArgs<ExtArgs>>): Prisma__StratergyHistoryClient<$Result.GetResult<Prisma.$StratergyHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StratergyHistories.
     * @param {StratergyHistoryCreateManyArgs} args - Arguments to create many StratergyHistories.
     * @example
     * // Create many StratergyHistories
     * const stratergyHistory = await prisma.stratergyHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StratergyHistoryCreateManyArgs>(args?: SelectSubset<T, StratergyHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StratergyHistories and returns the data saved in the database.
     * @param {StratergyHistoryCreateManyAndReturnArgs} args - Arguments to create many StratergyHistories.
     * @example
     * // Create many StratergyHistories
     * const stratergyHistory = await prisma.stratergyHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StratergyHistories and only return the `id`
     * const stratergyHistoryWithIdOnly = await prisma.stratergyHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StratergyHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, StratergyHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StratergyHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StratergyHistory.
     * @param {StratergyHistoryDeleteArgs} args - Arguments to delete one StratergyHistory.
     * @example
     * // Delete one StratergyHistory
     * const StratergyHistory = await prisma.stratergyHistory.delete({
     *   where: {
     *     // ... filter to delete one StratergyHistory
     *   }
     * })
     * 
     */
    delete<T extends StratergyHistoryDeleteArgs>(args: SelectSubset<T, StratergyHistoryDeleteArgs<ExtArgs>>): Prisma__StratergyHistoryClient<$Result.GetResult<Prisma.$StratergyHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StratergyHistory.
     * @param {StratergyHistoryUpdateArgs} args - Arguments to update one StratergyHistory.
     * @example
     * // Update one StratergyHistory
     * const stratergyHistory = await prisma.stratergyHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StratergyHistoryUpdateArgs>(args: SelectSubset<T, StratergyHistoryUpdateArgs<ExtArgs>>): Prisma__StratergyHistoryClient<$Result.GetResult<Prisma.$StratergyHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StratergyHistories.
     * @param {StratergyHistoryDeleteManyArgs} args - Arguments to filter StratergyHistories to delete.
     * @example
     * // Delete a few StratergyHistories
     * const { count } = await prisma.stratergyHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StratergyHistoryDeleteManyArgs>(args?: SelectSubset<T, StratergyHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StratergyHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StratergyHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StratergyHistories
     * const stratergyHistory = await prisma.stratergyHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StratergyHistoryUpdateManyArgs>(args: SelectSubset<T, StratergyHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StratergyHistories and returns the data updated in the database.
     * @param {StratergyHistoryUpdateManyAndReturnArgs} args - Arguments to update many StratergyHistories.
     * @example
     * // Update many StratergyHistories
     * const stratergyHistory = await prisma.stratergyHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StratergyHistories and only return the `id`
     * const stratergyHistoryWithIdOnly = await prisma.stratergyHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StratergyHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, StratergyHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StratergyHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StratergyHistory.
     * @param {StratergyHistoryUpsertArgs} args - Arguments to update or create a StratergyHistory.
     * @example
     * // Update or create a StratergyHistory
     * const stratergyHistory = await prisma.stratergyHistory.upsert({
     *   create: {
     *     // ... data to create a StratergyHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StratergyHistory we want to update
     *   }
     * })
     */
    upsert<T extends StratergyHistoryUpsertArgs>(args: SelectSubset<T, StratergyHistoryUpsertArgs<ExtArgs>>): Prisma__StratergyHistoryClient<$Result.GetResult<Prisma.$StratergyHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StratergyHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StratergyHistoryCountArgs} args - Arguments to filter StratergyHistories to count.
     * @example
     * // Count the number of StratergyHistories
     * const count = await prisma.stratergyHistory.count({
     *   where: {
     *     // ... the filter for the StratergyHistories we want to count
     *   }
     * })
    **/
    count<T extends StratergyHistoryCountArgs>(
      args?: Subset<T, StratergyHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StratergyHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StratergyHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StratergyHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StratergyHistoryAggregateArgs>(args: Subset<T, StratergyHistoryAggregateArgs>): Prisma.PrismaPromise<GetStratergyHistoryAggregateType<T>>

    /**
     * Group by StratergyHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StratergyHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StratergyHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StratergyHistoryGroupByArgs['orderBy'] }
        : { orderBy?: StratergyHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StratergyHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStratergyHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StratergyHistory model
   */
  readonly fields: StratergyHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StratergyHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StratergyHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    drug<T extends DrugDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DrugDefaultArgs<ExtArgs>>): Prisma__DrugClient<$Result.GetResult<Prisma.$DrugPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    issue<T extends IssueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IssueDefaultArgs<ExtArgs>>): Prisma__IssueClient<$Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StratergyHistory model
   */ 
  interface StratergyHistoryFieldRefs {
    readonly id: FieldRef<"StratergyHistory", 'Int'>
    readonly drugId: FieldRef<"StratergyHistory", 'Int'>
    readonly issueId: FieldRef<"StratergyHistory", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * StratergyHistory findUnique
   */
  export type StratergyHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StratergyHistory
     */
    select?: StratergyHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StratergyHistory
     */
    omit?: StratergyHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StratergyHistoryInclude<ExtArgs> | null
    /**
     * Filter, which StratergyHistory to fetch.
     */
    where: StratergyHistoryWhereUniqueInput
  }

  /**
   * StratergyHistory findUniqueOrThrow
   */
  export type StratergyHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StratergyHistory
     */
    select?: StratergyHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StratergyHistory
     */
    omit?: StratergyHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StratergyHistoryInclude<ExtArgs> | null
    /**
     * Filter, which StratergyHistory to fetch.
     */
    where: StratergyHistoryWhereUniqueInput
  }

  /**
   * StratergyHistory findFirst
   */
  export type StratergyHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StratergyHistory
     */
    select?: StratergyHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StratergyHistory
     */
    omit?: StratergyHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StratergyHistoryInclude<ExtArgs> | null
    /**
     * Filter, which StratergyHistory to fetch.
     */
    where?: StratergyHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StratergyHistories to fetch.
     */
    orderBy?: StratergyHistoryOrderByWithRelationInput | StratergyHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StratergyHistories.
     */
    cursor?: StratergyHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StratergyHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StratergyHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StratergyHistories.
     */
    distinct?: StratergyHistoryScalarFieldEnum | StratergyHistoryScalarFieldEnum[]
  }

  /**
   * StratergyHistory findFirstOrThrow
   */
  export type StratergyHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StratergyHistory
     */
    select?: StratergyHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StratergyHistory
     */
    omit?: StratergyHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StratergyHistoryInclude<ExtArgs> | null
    /**
     * Filter, which StratergyHistory to fetch.
     */
    where?: StratergyHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StratergyHistories to fetch.
     */
    orderBy?: StratergyHistoryOrderByWithRelationInput | StratergyHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StratergyHistories.
     */
    cursor?: StratergyHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StratergyHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StratergyHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StratergyHistories.
     */
    distinct?: StratergyHistoryScalarFieldEnum | StratergyHistoryScalarFieldEnum[]
  }

  /**
   * StratergyHistory findMany
   */
  export type StratergyHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StratergyHistory
     */
    select?: StratergyHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StratergyHistory
     */
    omit?: StratergyHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StratergyHistoryInclude<ExtArgs> | null
    /**
     * Filter, which StratergyHistories to fetch.
     */
    where?: StratergyHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StratergyHistories to fetch.
     */
    orderBy?: StratergyHistoryOrderByWithRelationInput | StratergyHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StratergyHistories.
     */
    cursor?: StratergyHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StratergyHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StratergyHistories.
     */
    skip?: number
    distinct?: StratergyHistoryScalarFieldEnum | StratergyHistoryScalarFieldEnum[]
  }

  /**
   * StratergyHistory create
   */
  export type StratergyHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StratergyHistory
     */
    select?: StratergyHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StratergyHistory
     */
    omit?: StratergyHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StratergyHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a StratergyHistory.
     */
    data: XOR<StratergyHistoryCreateInput, StratergyHistoryUncheckedCreateInput>
  }

  /**
   * StratergyHistory createMany
   */
  export type StratergyHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StratergyHistories.
     */
    data: StratergyHistoryCreateManyInput | StratergyHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StratergyHistory createManyAndReturn
   */
  export type StratergyHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StratergyHistory
     */
    select?: StratergyHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StratergyHistory
     */
    omit?: StratergyHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many StratergyHistories.
     */
    data: StratergyHistoryCreateManyInput | StratergyHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StratergyHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StratergyHistory update
   */
  export type StratergyHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StratergyHistory
     */
    select?: StratergyHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StratergyHistory
     */
    omit?: StratergyHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StratergyHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a StratergyHistory.
     */
    data: XOR<StratergyHistoryUpdateInput, StratergyHistoryUncheckedUpdateInput>
    /**
     * Choose, which StratergyHistory to update.
     */
    where: StratergyHistoryWhereUniqueInput
  }

  /**
   * StratergyHistory updateMany
   */
  export type StratergyHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StratergyHistories.
     */
    data: XOR<StratergyHistoryUpdateManyMutationInput, StratergyHistoryUncheckedUpdateManyInput>
    /**
     * Filter which StratergyHistories to update
     */
    where?: StratergyHistoryWhereInput
    /**
     * Limit how many StratergyHistories to update.
     */
    limit?: number
  }

  /**
   * StratergyHistory updateManyAndReturn
   */
  export type StratergyHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StratergyHistory
     */
    select?: StratergyHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StratergyHistory
     */
    omit?: StratergyHistoryOmit<ExtArgs> | null
    /**
     * The data used to update StratergyHistories.
     */
    data: XOR<StratergyHistoryUpdateManyMutationInput, StratergyHistoryUncheckedUpdateManyInput>
    /**
     * Filter which StratergyHistories to update
     */
    where?: StratergyHistoryWhereInput
    /**
     * Limit how many StratergyHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StratergyHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StratergyHistory upsert
   */
  export type StratergyHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StratergyHistory
     */
    select?: StratergyHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StratergyHistory
     */
    omit?: StratergyHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StratergyHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the StratergyHistory to update in case it exists.
     */
    where: StratergyHistoryWhereUniqueInput
    /**
     * In case the StratergyHistory found by the `where` argument doesn't exist, create a new StratergyHistory with this data.
     */
    create: XOR<StratergyHistoryCreateInput, StratergyHistoryUncheckedCreateInput>
    /**
     * In case the StratergyHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StratergyHistoryUpdateInput, StratergyHistoryUncheckedUpdateInput>
  }

  /**
   * StratergyHistory delete
   */
  export type StratergyHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StratergyHistory
     */
    select?: StratergyHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StratergyHistory
     */
    omit?: StratergyHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StratergyHistoryInclude<ExtArgs> | null
    /**
     * Filter which StratergyHistory to delete.
     */
    where: StratergyHistoryWhereUniqueInput
  }

  /**
   * StratergyHistory deleteMany
   */
  export type StratergyHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StratergyHistories to delete
     */
    where?: StratergyHistoryWhereInput
    /**
     * Limit how many StratergyHistories to delete.
     */
    limit?: number
  }

  /**
   * StratergyHistory without action
   */
  export type StratergyHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StratergyHistory
     */
    select?: StratergyHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StratergyHistory
     */
    omit?: StratergyHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StratergyHistoryInclude<ExtArgs> | null
  }


  /**
   * Model BatchHistory
   */

  export type AggregateBatchHistory = {
    _count: BatchHistoryCountAggregateOutputType | null
    _avg: BatchHistoryAvgAggregateOutputType | null
    _sum: BatchHistorySumAggregateOutputType | null
    _min: BatchHistoryMinAggregateOutputType | null
    _max: BatchHistoryMaxAggregateOutputType | null
  }

  export type BatchHistoryAvgAggregateOutputType = {
    id: number | null
    drugId: number | null
    unitConcentrationId: number | null
    drugBrandId: number | null
    batchId: number | null
  }

  export type BatchHistorySumAggregateOutputType = {
    id: number | null
    drugId: number | null
    unitConcentrationId: number | null
    drugBrandId: number | null
    batchId: number | null
  }

  export type BatchHistoryMinAggregateOutputType = {
    id: number | null
    drugId: number | null
    type: $Enums.DrugType | null
    unitConcentrationId: number | null
    drugBrandId: number | null
    batchId: number | null
  }

  export type BatchHistoryMaxAggregateOutputType = {
    id: number | null
    drugId: number | null
    type: $Enums.DrugType | null
    unitConcentrationId: number | null
    drugBrandId: number | null
    batchId: number | null
  }

  export type BatchHistoryCountAggregateOutputType = {
    id: number
    drugId: number
    type: number
    unitConcentrationId: number
    drugBrandId: number
    batchId: number
    _all: number
  }


  export type BatchHistoryAvgAggregateInputType = {
    id?: true
    drugId?: true
    unitConcentrationId?: true
    drugBrandId?: true
    batchId?: true
  }

  export type BatchHistorySumAggregateInputType = {
    id?: true
    drugId?: true
    unitConcentrationId?: true
    drugBrandId?: true
    batchId?: true
  }

  export type BatchHistoryMinAggregateInputType = {
    id?: true
    drugId?: true
    type?: true
    unitConcentrationId?: true
    drugBrandId?: true
    batchId?: true
  }

  export type BatchHistoryMaxAggregateInputType = {
    id?: true
    drugId?: true
    type?: true
    unitConcentrationId?: true
    drugBrandId?: true
    batchId?: true
  }

  export type BatchHistoryCountAggregateInputType = {
    id?: true
    drugId?: true
    type?: true
    unitConcentrationId?: true
    drugBrandId?: true
    batchId?: true
    _all?: true
  }

  export type BatchHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BatchHistory to aggregate.
     */
    where?: BatchHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BatchHistories to fetch.
     */
    orderBy?: BatchHistoryOrderByWithRelationInput | BatchHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BatchHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BatchHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BatchHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BatchHistories
    **/
    _count?: true | BatchHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BatchHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BatchHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BatchHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BatchHistoryMaxAggregateInputType
  }

  export type GetBatchHistoryAggregateType<T extends BatchHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateBatchHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBatchHistory[P]>
      : GetScalarType<T[P], AggregateBatchHistory[P]>
  }




  export type BatchHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchHistoryWhereInput
    orderBy?: BatchHistoryOrderByWithAggregationInput | BatchHistoryOrderByWithAggregationInput[]
    by: BatchHistoryScalarFieldEnum[] | BatchHistoryScalarFieldEnum
    having?: BatchHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BatchHistoryCountAggregateInputType | true
    _avg?: BatchHistoryAvgAggregateInputType
    _sum?: BatchHistorySumAggregateInputType
    _min?: BatchHistoryMinAggregateInputType
    _max?: BatchHistoryMaxAggregateInputType
  }

  export type BatchHistoryGroupByOutputType = {
    id: number
    drugId: number
    type: $Enums.DrugType
    unitConcentrationId: number
    drugBrandId: number
    batchId: number
    _count: BatchHistoryCountAggregateOutputType | null
    _avg: BatchHistoryAvgAggregateOutputType | null
    _sum: BatchHistorySumAggregateOutputType | null
    _min: BatchHistoryMinAggregateOutputType | null
    _max: BatchHistoryMaxAggregateOutputType | null
  }

  type GetBatchHistoryGroupByPayload<T extends BatchHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BatchHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BatchHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BatchHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], BatchHistoryGroupByOutputType[P]>
        }
      >
    >


  export type BatchHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    drugId?: boolean
    type?: boolean
    unitConcentrationId?: boolean
    drugBrandId?: boolean
    batchId?: boolean
    batch?: boolean | BatchDefaultArgs<ExtArgs>
    brand?: boolean | DrugBrandDefaultArgs<ExtArgs>
    drug?: boolean | DrugDefaultArgs<ExtArgs>
    unitConcentration?: boolean | UnitConcentrationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["batchHistory"]>

  export type BatchHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    drugId?: boolean
    type?: boolean
    unitConcentrationId?: boolean
    drugBrandId?: boolean
    batchId?: boolean
    batch?: boolean | BatchDefaultArgs<ExtArgs>
    brand?: boolean | DrugBrandDefaultArgs<ExtArgs>
    drug?: boolean | DrugDefaultArgs<ExtArgs>
    unitConcentration?: boolean | UnitConcentrationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["batchHistory"]>

  export type BatchHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    drugId?: boolean
    type?: boolean
    unitConcentrationId?: boolean
    drugBrandId?: boolean
    batchId?: boolean
    batch?: boolean | BatchDefaultArgs<ExtArgs>
    brand?: boolean | DrugBrandDefaultArgs<ExtArgs>
    drug?: boolean | DrugDefaultArgs<ExtArgs>
    unitConcentration?: boolean | UnitConcentrationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["batchHistory"]>

  export type BatchHistorySelectScalar = {
    id?: boolean
    drugId?: boolean
    type?: boolean
    unitConcentrationId?: boolean
    drugBrandId?: boolean
    batchId?: boolean
  }

  export type BatchHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "drugId" | "type" | "unitConcentrationId" | "drugBrandId" | "batchId", ExtArgs["result"]["batchHistory"]>
  export type BatchHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batch?: boolean | BatchDefaultArgs<ExtArgs>
    brand?: boolean | DrugBrandDefaultArgs<ExtArgs>
    drug?: boolean | DrugDefaultArgs<ExtArgs>
    unitConcentration?: boolean | UnitConcentrationDefaultArgs<ExtArgs>
  }
  export type BatchHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batch?: boolean | BatchDefaultArgs<ExtArgs>
    brand?: boolean | DrugBrandDefaultArgs<ExtArgs>
    drug?: boolean | DrugDefaultArgs<ExtArgs>
    unitConcentration?: boolean | UnitConcentrationDefaultArgs<ExtArgs>
  }
  export type BatchHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batch?: boolean | BatchDefaultArgs<ExtArgs>
    brand?: boolean | DrugBrandDefaultArgs<ExtArgs>
    drug?: boolean | DrugDefaultArgs<ExtArgs>
    unitConcentration?: boolean | UnitConcentrationDefaultArgs<ExtArgs>
  }

  export type $BatchHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BatchHistory"
    objects: {
      batch: Prisma.$BatchPayload<ExtArgs>
      brand: Prisma.$DrugBrandPayload<ExtArgs>
      drug: Prisma.$DrugPayload<ExtArgs>
      unitConcentration: Prisma.$UnitConcentrationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      drugId: number
      type: $Enums.DrugType
      unitConcentrationId: number
      drugBrandId: number
      batchId: number
    }, ExtArgs["result"]["batchHistory"]>
    composites: {}
  }

  type BatchHistoryGetPayload<S extends boolean | null | undefined | BatchHistoryDefaultArgs> = $Result.GetResult<Prisma.$BatchHistoryPayload, S>

  type BatchHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BatchHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BatchHistoryCountAggregateInputType | true
    }

  export interface BatchHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BatchHistory'], meta: { name: 'BatchHistory' } }
    /**
     * Find zero or one BatchHistory that matches the filter.
     * @param {BatchHistoryFindUniqueArgs} args - Arguments to find a BatchHistory
     * @example
     * // Get one BatchHistory
     * const batchHistory = await prisma.batchHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BatchHistoryFindUniqueArgs>(args: SelectSubset<T, BatchHistoryFindUniqueArgs<ExtArgs>>): Prisma__BatchHistoryClient<$Result.GetResult<Prisma.$BatchHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BatchHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BatchHistoryFindUniqueOrThrowArgs} args - Arguments to find a BatchHistory
     * @example
     * // Get one BatchHistory
     * const batchHistory = await prisma.batchHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BatchHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, BatchHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BatchHistoryClient<$Result.GetResult<Prisma.$BatchHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BatchHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchHistoryFindFirstArgs} args - Arguments to find a BatchHistory
     * @example
     * // Get one BatchHistory
     * const batchHistory = await prisma.batchHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BatchHistoryFindFirstArgs>(args?: SelectSubset<T, BatchHistoryFindFirstArgs<ExtArgs>>): Prisma__BatchHistoryClient<$Result.GetResult<Prisma.$BatchHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BatchHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchHistoryFindFirstOrThrowArgs} args - Arguments to find a BatchHistory
     * @example
     * // Get one BatchHistory
     * const batchHistory = await prisma.batchHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BatchHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, BatchHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__BatchHistoryClient<$Result.GetResult<Prisma.$BatchHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BatchHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BatchHistories
     * const batchHistories = await prisma.batchHistory.findMany()
     * 
     * // Get first 10 BatchHistories
     * const batchHistories = await prisma.batchHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const batchHistoryWithIdOnly = await prisma.batchHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BatchHistoryFindManyArgs>(args?: SelectSubset<T, BatchHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BatchHistory.
     * @param {BatchHistoryCreateArgs} args - Arguments to create a BatchHistory.
     * @example
     * // Create one BatchHistory
     * const BatchHistory = await prisma.batchHistory.create({
     *   data: {
     *     // ... data to create a BatchHistory
     *   }
     * })
     * 
     */
    create<T extends BatchHistoryCreateArgs>(args: SelectSubset<T, BatchHistoryCreateArgs<ExtArgs>>): Prisma__BatchHistoryClient<$Result.GetResult<Prisma.$BatchHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BatchHistories.
     * @param {BatchHistoryCreateManyArgs} args - Arguments to create many BatchHistories.
     * @example
     * // Create many BatchHistories
     * const batchHistory = await prisma.batchHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BatchHistoryCreateManyArgs>(args?: SelectSubset<T, BatchHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BatchHistories and returns the data saved in the database.
     * @param {BatchHistoryCreateManyAndReturnArgs} args - Arguments to create many BatchHistories.
     * @example
     * // Create many BatchHistories
     * const batchHistory = await prisma.batchHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BatchHistories and only return the `id`
     * const batchHistoryWithIdOnly = await prisma.batchHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BatchHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, BatchHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BatchHistory.
     * @param {BatchHistoryDeleteArgs} args - Arguments to delete one BatchHistory.
     * @example
     * // Delete one BatchHistory
     * const BatchHistory = await prisma.batchHistory.delete({
     *   where: {
     *     // ... filter to delete one BatchHistory
     *   }
     * })
     * 
     */
    delete<T extends BatchHistoryDeleteArgs>(args: SelectSubset<T, BatchHistoryDeleteArgs<ExtArgs>>): Prisma__BatchHistoryClient<$Result.GetResult<Prisma.$BatchHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BatchHistory.
     * @param {BatchHistoryUpdateArgs} args - Arguments to update one BatchHistory.
     * @example
     * // Update one BatchHistory
     * const batchHistory = await prisma.batchHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BatchHistoryUpdateArgs>(args: SelectSubset<T, BatchHistoryUpdateArgs<ExtArgs>>): Prisma__BatchHistoryClient<$Result.GetResult<Prisma.$BatchHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BatchHistories.
     * @param {BatchHistoryDeleteManyArgs} args - Arguments to filter BatchHistories to delete.
     * @example
     * // Delete a few BatchHistories
     * const { count } = await prisma.batchHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BatchHistoryDeleteManyArgs>(args?: SelectSubset<T, BatchHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BatchHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BatchHistories
     * const batchHistory = await prisma.batchHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BatchHistoryUpdateManyArgs>(args: SelectSubset<T, BatchHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BatchHistories and returns the data updated in the database.
     * @param {BatchHistoryUpdateManyAndReturnArgs} args - Arguments to update many BatchHistories.
     * @example
     * // Update many BatchHistories
     * const batchHistory = await prisma.batchHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BatchHistories and only return the `id`
     * const batchHistoryWithIdOnly = await prisma.batchHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BatchHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, BatchHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BatchHistory.
     * @param {BatchHistoryUpsertArgs} args - Arguments to update or create a BatchHistory.
     * @example
     * // Update or create a BatchHistory
     * const batchHistory = await prisma.batchHistory.upsert({
     *   create: {
     *     // ... data to create a BatchHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BatchHistory we want to update
     *   }
     * })
     */
    upsert<T extends BatchHistoryUpsertArgs>(args: SelectSubset<T, BatchHistoryUpsertArgs<ExtArgs>>): Prisma__BatchHistoryClient<$Result.GetResult<Prisma.$BatchHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BatchHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchHistoryCountArgs} args - Arguments to filter BatchHistories to count.
     * @example
     * // Count the number of BatchHistories
     * const count = await prisma.batchHistory.count({
     *   where: {
     *     // ... the filter for the BatchHistories we want to count
     *   }
     * })
    **/
    count<T extends BatchHistoryCountArgs>(
      args?: Subset<T, BatchHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BatchHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BatchHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BatchHistoryAggregateArgs>(args: Subset<T, BatchHistoryAggregateArgs>): Prisma.PrismaPromise<GetBatchHistoryAggregateType<T>>

    /**
     * Group by BatchHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BatchHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BatchHistoryGroupByArgs['orderBy'] }
        : { orderBy?: BatchHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BatchHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBatchHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BatchHistory model
   */
  readonly fields: BatchHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BatchHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BatchHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    batch<T extends BatchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BatchDefaultArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    brand<T extends DrugBrandDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DrugBrandDefaultArgs<ExtArgs>>): Prisma__DrugBrandClient<$Result.GetResult<Prisma.$DrugBrandPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    drug<T extends DrugDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DrugDefaultArgs<ExtArgs>>): Prisma__DrugClient<$Result.GetResult<Prisma.$DrugPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    unitConcentration<T extends UnitConcentrationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitConcentrationDefaultArgs<ExtArgs>>): Prisma__UnitConcentrationClient<$Result.GetResult<Prisma.$UnitConcentrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BatchHistory model
   */ 
  interface BatchHistoryFieldRefs {
    readonly id: FieldRef<"BatchHistory", 'Int'>
    readonly drugId: FieldRef<"BatchHistory", 'Int'>
    readonly type: FieldRef<"BatchHistory", 'DrugType'>
    readonly unitConcentrationId: FieldRef<"BatchHistory", 'Int'>
    readonly drugBrandId: FieldRef<"BatchHistory", 'Int'>
    readonly batchId: FieldRef<"BatchHistory", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * BatchHistory findUnique
   */
  export type BatchHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchHistory
     */
    select?: BatchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchHistory
     */
    omit?: BatchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchHistoryInclude<ExtArgs> | null
    /**
     * Filter, which BatchHistory to fetch.
     */
    where: BatchHistoryWhereUniqueInput
  }

  /**
   * BatchHistory findUniqueOrThrow
   */
  export type BatchHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchHistory
     */
    select?: BatchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchHistory
     */
    omit?: BatchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchHistoryInclude<ExtArgs> | null
    /**
     * Filter, which BatchHistory to fetch.
     */
    where: BatchHistoryWhereUniqueInput
  }

  /**
   * BatchHistory findFirst
   */
  export type BatchHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchHistory
     */
    select?: BatchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchHistory
     */
    omit?: BatchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchHistoryInclude<ExtArgs> | null
    /**
     * Filter, which BatchHistory to fetch.
     */
    where?: BatchHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BatchHistories to fetch.
     */
    orderBy?: BatchHistoryOrderByWithRelationInput | BatchHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BatchHistories.
     */
    cursor?: BatchHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BatchHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BatchHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BatchHistories.
     */
    distinct?: BatchHistoryScalarFieldEnum | BatchHistoryScalarFieldEnum[]
  }

  /**
   * BatchHistory findFirstOrThrow
   */
  export type BatchHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchHistory
     */
    select?: BatchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchHistory
     */
    omit?: BatchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchHistoryInclude<ExtArgs> | null
    /**
     * Filter, which BatchHistory to fetch.
     */
    where?: BatchHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BatchHistories to fetch.
     */
    orderBy?: BatchHistoryOrderByWithRelationInput | BatchHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BatchHistories.
     */
    cursor?: BatchHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BatchHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BatchHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BatchHistories.
     */
    distinct?: BatchHistoryScalarFieldEnum | BatchHistoryScalarFieldEnum[]
  }

  /**
   * BatchHistory findMany
   */
  export type BatchHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchHistory
     */
    select?: BatchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchHistory
     */
    omit?: BatchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchHistoryInclude<ExtArgs> | null
    /**
     * Filter, which BatchHistories to fetch.
     */
    where?: BatchHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BatchHistories to fetch.
     */
    orderBy?: BatchHistoryOrderByWithRelationInput | BatchHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BatchHistories.
     */
    cursor?: BatchHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BatchHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BatchHistories.
     */
    skip?: number
    distinct?: BatchHistoryScalarFieldEnum | BatchHistoryScalarFieldEnum[]
  }

  /**
   * BatchHistory create
   */
  export type BatchHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchHistory
     */
    select?: BatchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchHistory
     */
    omit?: BatchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a BatchHistory.
     */
    data: XOR<BatchHistoryCreateInput, BatchHistoryUncheckedCreateInput>
  }

  /**
   * BatchHistory createMany
   */
  export type BatchHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BatchHistories.
     */
    data: BatchHistoryCreateManyInput | BatchHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BatchHistory createManyAndReturn
   */
  export type BatchHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchHistory
     */
    select?: BatchHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BatchHistory
     */
    omit?: BatchHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many BatchHistories.
     */
    data: BatchHistoryCreateManyInput | BatchHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BatchHistory update
   */
  export type BatchHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchHistory
     */
    select?: BatchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchHistory
     */
    omit?: BatchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a BatchHistory.
     */
    data: XOR<BatchHistoryUpdateInput, BatchHistoryUncheckedUpdateInput>
    /**
     * Choose, which BatchHistory to update.
     */
    where: BatchHistoryWhereUniqueInput
  }

  /**
   * BatchHistory updateMany
   */
  export type BatchHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BatchHistories.
     */
    data: XOR<BatchHistoryUpdateManyMutationInput, BatchHistoryUncheckedUpdateManyInput>
    /**
     * Filter which BatchHistories to update
     */
    where?: BatchHistoryWhereInput
    /**
     * Limit how many BatchHistories to update.
     */
    limit?: number
  }

  /**
   * BatchHistory updateManyAndReturn
   */
  export type BatchHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchHistory
     */
    select?: BatchHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BatchHistory
     */
    omit?: BatchHistoryOmit<ExtArgs> | null
    /**
     * The data used to update BatchHistories.
     */
    data: XOR<BatchHistoryUpdateManyMutationInput, BatchHistoryUncheckedUpdateManyInput>
    /**
     * Filter which BatchHistories to update
     */
    where?: BatchHistoryWhereInput
    /**
     * Limit how many BatchHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BatchHistory upsert
   */
  export type BatchHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchHistory
     */
    select?: BatchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchHistory
     */
    omit?: BatchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the BatchHistory to update in case it exists.
     */
    where: BatchHistoryWhereUniqueInput
    /**
     * In case the BatchHistory found by the `where` argument doesn't exist, create a new BatchHistory with this data.
     */
    create: XOR<BatchHistoryCreateInput, BatchHistoryUncheckedCreateInput>
    /**
     * In case the BatchHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BatchHistoryUpdateInput, BatchHistoryUncheckedUpdateInput>
  }

  /**
   * BatchHistory delete
   */
  export type BatchHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchHistory
     */
    select?: BatchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchHistory
     */
    omit?: BatchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchHistoryInclude<ExtArgs> | null
    /**
     * Filter which BatchHistory to delete.
     */
    where: BatchHistoryWhereUniqueInput
  }

  /**
   * BatchHistory deleteMany
   */
  export type BatchHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BatchHistories to delete
     */
    where?: BatchHistoryWhereInput
    /**
     * Limit how many BatchHistories to delete.
     */
    limit?: number
  }

  /**
   * BatchHistory without action
   */
  export type BatchHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchHistory
     */
    select?: BatchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchHistory
     */
    omit?: BatchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchHistoryInclude<ExtArgs> | null
  }


  /**
   * Model Charge
   */

  export type AggregateCharge = {
    _count: ChargeCountAggregateOutputType | null
    _avg: ChargeAvgAggregateOutputType | null
    _sum: ChargeSumAggregateOutputType | null
    _min: ChargeMinAggregateOutputType | null
    _max: ChargeMaxAggregateOutputType | null
  }

  export type ChargeAvgAggregateOutputType = {
    id: number | null
    value: number | null
  }

  export type ChargeSumAggregateOutputType = {
    id: number | null
    value: number | null
  }

  export type ChargeMinAggregateOutputType = {
    id: number | null
    name: string | null
    type: $Enums.ChargeType | null
    value: number | null
    updatedAt: Date | null
  }

  export type ChargeMaxAggregateOutputType = {
    id: number | null
    name: string | null
    type: $Enums.ChargeType | null
    value: number | null
    updatedAt: Date | null
  }

  export type ChargeCountAggregateOutputType = {
    id: number
    name: number
    type: number
    value: number
    updatedAt: number
    _all: number
  }


  export type ChargeAvgAggregateInputType = {
    id?: true
    value?: true
  }

  export type ChargeSumAggregateInputType = {
    id?: true
    value?: true
  }

  export type ChargeMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    value?: true
    updatedAt?: true
  }

  export type ChargeMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    value?: true
    updatedAt?: true
  }

  export type ChargeCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    value?: true
    updatedAt?: true
    _all?: true
  }

  export type ChargeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Charge to aggregate.
     */
    where?: ChargeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Charges to fetch.
     */
    orderBy?: ChargeOrderByWithRelationInput | ChargeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChargeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Charges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Charges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Charges
    **/
    _count?: true | ChargeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChargeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChargeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChargeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChargeMaxAggregateInputType
  }

  export type GetChargeAggregateType<T extends ChargeAggregateArgs> = {
        [P in keyof T & keyof AggregateCharge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharge[P]>
      : GetScalarType<T[P], AggregateCharge[P]>
  }




  export type ChargeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChargeWhereInput
    orderBy?: ChargeOrderByWithAggregationInput | ChargeOrderByWithAggregationInput[]
    by: ChargeScalarFieldEnum[] | ChargeScalarFieldEnum
    having?: ChargeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChargeCountAggregateInputType | true
    _avg?: ChargeAvgAggregateInputType
    _sum?: ChargeSumAggregateInputType
    _min?: ChargeMinAggregateInputType
    _max?: ChargeMaxAggregateInputType
  }

  export type ChargeGroupByOutputType = {
    id: number
    name: string
    type: $Enums.ChargeType
    value: number
    updatedAt: Date
    _count: ChargeCountAggregateOutputType | null
    _avg: ChargeAvgAggregateOutputType | null
    _sum: ChargeSumAggregateOutputType | null
    _min: ChargeMinAggregateOutputType | null
    _max: ChargeMaxAggregateOutputType | null
  }

  type GetChargeGroupByPayload<T extends ChargeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChargeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChargeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChargeGroupByOutputType[P]>
            : GetScalarType<T[P], ChargeGroupByOutputType[P]>
        }
      >
    >


  export type ChargeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    value?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["charge"]>

  export type ChargeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    value?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["charge"]>

  export type ChargeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    value?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["charge"]>

  export type ChargeSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    value?: boolean
    updatedAt?: boolean
  }

  export type ChargeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "value" | "updatedAt", ExtArgs["result"]["charge"]>

  export type $ChargePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Charge"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      type: $Enums.ChargeType
      value: number
      updatedAt: Date
    }, ExtArgs["result"]["charge"]>
    composites: {}
  }

  type ChargeGetPayload<S extends boolean | null | undefined | ChargeDefaultArgs> = $Result.GetResult<Prisma.$ChargePayload, S>

  type ChargeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChargeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChargeCountAggregateInputType | true
    }

  export interface ChargeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Charge'], meta: { name: 'Charge' } }
    /**
     * Find zero or one Charge that matches the filter.
     * @param {ChargeFindUniqueArgs} args - Arguments to find a Charge
     * @example
     * // Get one Charge
     * const charge = await prisma.charge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChargeFindUniqueArgs>(args: SelectSubset<T, ChargeFindUniqueArgs<ExtArgs>>): Prisma__ChargeClient<$Result.GetResult<Prisma.$ChargePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Charge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChargeFindUniqueOrThrowArgs} args - Arguments to find a Charge
     * @example
     * // Get one Charge
     * const charge = await prisma.charge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChargeFindUniqueOrThrowArgs>(args: SelectSubset<T, ChargeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChargeClient<$Result.GetResult<Prisma.$ChargePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Charge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChargeFindFirstArgs} args - Arguments to find a Charge
     * @example
     * // Get one Charge
     * const charge = await prisma.charge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChargeFindFirstArgs>(args?: SelectSubset<T, ChargeFindFirstArgs<ExtArgs>>): Prisma__ChargeClient<$Result.GetResult<Prisma.$ChargePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Charge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChargeFindFirstOrThrowArgs} args - Arguments to find a Charge
     * @example
     * // Get one Charge
     * const charge = await prisma.charge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChargeFindFirstOrThrowArgs>(args?: SelectSubset<T, ChargeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChargeClient<$Result.GetResult<Prisma.$ChargePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Charges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChargeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Charges
     * const charges = await prisma.charge.findMany()
     * 
     * // Get first 10 Charges
     * const charges = await prisma.charge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chargeWithIdOnly = await prisma.charge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChargeFindManyArgs>(args?: SelectSubset<T, ChargeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChargePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Charge.
     * @param {ChargeCreateArgs} args - Arguments to create a Charge.
     * @example
     * // Create one Charge
     * const Charge = await prisma.charge.create({
     *   data: {
     *     // ... data to create a Charge
     *   }
     * })
     * 
     */
    create<T extends ChargeCreateArgs>(args: SelectSubset<T, ChargeCreateArgs<ExtArgs>>): Prisma__ChargeClient<$Result.GetResult<Prisma.$ChargePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Charges.
     * @param {ChargeCreateManyArgs} args - Arguments to create many Charges.
     * @example
     * // Create many Charges
     * const charge = await prisma.charge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChargeCreateManyArgs>(args?: SelectSubset<T, ChargeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Charges and returns the data saved in the database.
     * @param {ChargeCreateManyAndReturnArgs} args - Arguments to create many Charges.
     * @example
     * // Create many Charges
     * const charge = await prisma.charge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Charges and only return the `id`
     * const chargeWithIdOnly = await prisma.charge.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChargeCreateManyAndReturnArgs>(args?: SelectSubset<T, ChargeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChargePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Charge.
     * @param {ChargeDeleteArgs} args - Arguments to delete one Charge.
     * @example
     * // Delete one Charge
     * const Charge = await prisma.charge.delete({
     *   where: {
     *     // ... filter to delete one Charge
     *   }
     * })
     * 
     */
    delete<T extends ChargeDeleteArgs>(args: SelectSubset<T, ChargeDeleteArgs<ExtArgs>>): Prisma__ChargeClient<$Result.GetResult<Prisma.$ChargePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Charge.
     * @param {ChargeUpdateArgs} args - Arguments to update one Charge.
     * @example
     * // Update one Charge
     * const charge = await prisma.charge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChargeUpdateArgs>(args: SelectSubset<T, ChargeUpdateArgs<ExtArgs>>): Prisma__ChargeClient<$Result.GetResult<Prisma.$ChargePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Charges.
     * @param {ChargeDeleteManyArgs} args - Arguments to filter Charges to delete.
     * @example
     * // Delete a few Charges
     * const { count } = await prisma.charge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChargeDeleteManyArgs>(args?: SelectSubset<T, ChargeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Charges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChargeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Charges
     * const charge = await prisma.charge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChargeUpdateManyArgs>(args: SelectSubset<T, ChargeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Charges and returns the data updated in the database.
     * @param {ChargeUpdateManyAndReturnArgs} args - Arguments to update many Charges.
     * @example
     * // Update many Charges
     * const charge = await prisma.charge.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Charges and only return the `id`
     * const chargeWithIdOnly = await prisma.charge.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChargeUpdateManyAndReturnArgs>(args: SelectSubset<T, ChargeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChargePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Charge.
     * @param {ChargeUpsertArgs} args - Arguments to update or create a Charge.
     * @example
     * // Update or create a Charge
     * const charge = await prisma.charge.upsert({
     *   create: {
     *     // ... data to create a Charge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Charge we want to update
     *   }
     * })
     */
    upsert<T extends ChargeUpsertArgs>(args: SelectSubset<T, ChargeUpsertArgs<ExtArgs>>): Prisma__ChargeClient<$Result.GetResult<Prisma.$ChargePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Charges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChargeCountArgs} args - Arguments to filter Charges to count.
     * @example
     * // Count the number of Charges
     * const count = await prisma.charge.count({
     *   where: {
     *     // ... the filter for the Charges we want to count
     *   }
     * })
    **/
    count<T extends ChargeCountArgs>(
      args?: Subset<T, ChargeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChargeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Charge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChargeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChargeAggregateArgs>(args: Subset<T, ChargeAggregateArgs>): Prisma.PrismaPromise<GetChargeAggregateType<T>>

    /**
     * Group by Charge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChargeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChargeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChargeGroupByArgs['orderBy'] }
        : { orderBy?: ChargeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChargeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChargeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Charge model
   */
  readonly fields: ChargeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Charge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChargeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Charge model
   */ 
  interface ChargeFieldRefs {
    readonly id: FieldRef<"Charge", 'Int'>
    readonly name: FieldRef<"Charge", 'String'>
    readonly type: FieldRef<"Charge", 'ChargeType'>
    readonly value: FieldRef<"Charge", 'Float'>
    readonly updatedAt: FieldRef<"Charge", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Charge findUnique
   */
  export type ChargeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Charge
     */
    select?: ChargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Charge
     */
    omit?: ChargeOmit<ExtArgs> | null
    /**
     * Filter, which Charge to fetch.
     */
    where: ChargeWhereUniqueInput
  }

  /**
   * Charge findUniqueOrThrow
   */
  export type ChargeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Charge
     */
    select?: ChargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Charge
     */
    omit?: ChargeOmit<ExtArgs> | null
    /**
     * Filter, which Charge to fetch.
     */
    where: ChargeWhereUniqueInput
  }

  /**
   * Charge findFirst
   */
  export type ChargeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Charge
     */
    select?: ChargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Charge
     */
    omit?: ChargeOmit<ExtArgs> | null
    /**
     * Filter, which Charge to fetch.
     */
    where?: ChargeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Charges to fetch.
     */
    orderBy?: ChargeOrderByWithRelationInput | ChargeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Charges.
     */
    cursor?: ChargeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Charges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Charges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Charges.
     */
    distinct?: ChargeScalarFieldEnum | ChargeScalarFieldEnum[]
  }

  /**
   * Charge findFirstOrThrow
   */
  export type ChargeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Charge
     */
    select?: ChargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Charge
     */
    omit?: ChargeOmit<ExtArgs> | null
    /**
     * Filter, which Charge to fetch.
     */
    where?: ChargeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Charges to fetch.
     */
    orderBy?: ChargeOrderByWithRelationInput | ChargeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Charges.
     */
    cursor?: ChargeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Charges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Charges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Charges.
     */
    distinct?: ChargeScalarFieldEnum | ChargeScalarFieldEnum[]
  }

  /**
   * Charge findMany
   */
  export type ChargeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Charge
     */
    select?: ChargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Charge
     */
    omit?: ChargeOmit<ExtArgs> | null
    /**
     * Filter, which Charges to fetch.
     */
    where?: ChargeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Charges to fetch.
     */
    orderBy?: ChargeOrderByWithRelationInput | ChargeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Charges.
     */
    cursor?: ChargeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Charges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Charges.
     */
    skip?: number
    distinct?: ChargeScalarFieldEnum | ChargeScalarFieldEnum[]
  }

  /**
   * Charge create
   */
  export type ChargeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Charge
     */
    select?: ChargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Charge
     */
    omit?: ChargeOmit<ExtArgs> | null
    /**
     * The data needed to create a Charge.
     */
    data: XOR<ChargeCreateInput, ChargeUncheckedCreateInput>
  }

  /**
   * Charge createMany
   */
  export type ChargeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Charges.
     */
    data: ChargeCreateManyInput | ChargeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Charge createManyAndReturn
   */
  export type ChargeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Charge
     */
    select?: ChargeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Charge
     */
    omit?: ChargeOmit<ExtArgs> | null
    /**
     * The data used to create many Charges.
     */
    data: ChargeCreateManyInput | ChargeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Charge update
   */
  export type ChargeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Charge
     */
    select?: ChargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Charge
     */
    omit?: ChargeOmit<ExtArgs> | null
    /**
     * The data needed to update a Charge.
     */
    data: XOR<ChargeUpdateInput, ChargeUncheckedUpdateInput>
    /**
     * Choose, which Charge to update.
     */
    where: ChargeWhereUniqueInput
  }

  /**
   * Charge updateMany
   */
  export type ChargeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Charges.
     */
    data: XOR<ChargeUpdateManyMutationInput, ChargeUncheckedUpdateManyInput>
    /**
     * Filter which Charges to update
     */
    where?: ChargeWhereInput
    /**
     * Limit how many Charges to update.
     */
    limit?: number
  }

  /**
   * Charge updateManyAndReturn
   */
  export type ChargeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Charge
     */
    select?: ChargeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Charge
     */
    omit?: ChargeOmit<ExtArgs> | null
    /**
     * The data used to update Charges.
     */
    data: XOR<ChargeUpdateManyMutationInput, ChargeUncheckedUpdateManyInput>
    /**
     * Filter which Charges to update
     */
    where?: ChargeWhereInput
    /**
     * Limit how many Charges to update.
     */
    limit?: number
  }

  /**
   * Charge upsert
   */
  export type ChargeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Charge
     */
    select?: ChargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Charge
     */
    omit?: ChargeOmit<ExtArgs> | null
    /**
     * The filter to search for the Charge to update in case it exists.
     */
    where: ChargeWhereUniqueInput
    /**
     * In case the Charge found by the `where` argument doesn't exist, create a new Charge with this data.
     */
    create: XOR<ChargeCreateInput, ChargeUncheckedCreateInput>
    /**
     * In case the Charge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChargeUpdateInput, ChargeUncheckedUpdateInput>
  }

  /**
   * Charge delete
   */
  export type ChargeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Charge
     */
    select?: ChargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Charge
     */
    omit?: ChargeOmit<ExtArgs> | null
    /**
     * Filter which Charge to delete.
     */
    where: ChargeWhereUniqueInput
  }

  /**
   * Charge deleteMany
   */
  export type ChargeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Charges to delete
     */
    where?: ChargeWhereInput
    /**
     * Limit how many Charges to delete.
     */
    limit?: number
  }

  /**
   * Charge without action
   */
  export type ChargeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Charge
     */
    select?: ChargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Charge
     */
    omit?: ChargeOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const PatientScalarFieldEnum: {
    id: 'id',
    telephone: 'telephone',
    name: 'name',
    birthDate: 'birthDate',
    address: 'address',
    height: 'height',
    weight: 'weight',
    gender: 'gender',
    NIC: 'NIC'
  };

  export type PatientScalarFieldEnum = (typeof PatientScalarFieldEnum)[keyof typeof PatientScalarFieldEnum]


  export const PatientHistoryScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    description: 'description',
    type: 'type',
    time: 'time',
    name: 'name'
  };

  export type PatientHistoryScalarFieldEnum = (typeof PatientHistoryScalarFieldEnum)[keyof typeof PatientHistoryScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    gender: 'gender',
    image: 'image',
    mobile: 'mobile',
    password: 'password',
    role: 'role'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const QueueScalarFieldEnum: {
    id: 'id',
    start: 'start',
    end: 'end',
    status: 'status'
  };

  export type QueueScalarFieldEnum = (typeof QueueScalarFieldEnum)[keyof typeof QueueScalarFieldEnum]


  export const QueueEntryScalarFieldEnum: {
    id: 'id',
    token: 'token',
    status: 'status',
    queueId: 'queueId',
    patientId: 'patientId',
    time: 'time'
  };

  export type QueueEntryScalarFieldEnum = (typeof QueueEntryScalarFieldEnum)[keyof typeof QueueEntryScalarFieldEnum]


  export const DrugBrandScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description'
  };

  export type DrugBrandScalarFieldEnum = (typeof DrugBrandScalarFieldEnum)[keyof typeof DrugBrandScalarFieldEnum]


  export const DrugScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type DrugScalarFieldEnum = (typeof DrugScalarFieldEnum)[keyof typeof DrugScalarFieldEnum]


  export const BufferLevelScalarFieldEnum: {
    id: 'id',
    drugId: 'drugId',
    type: 'type',
    unitConcentrationId: 'unitConcentrationId',
    bufferAmount: 'bufferAmount'
  };

  export type BufferLevelScalarFieldEnum = (typeof BufferLevelScalarFieldEnum)[keyof typeof BufferLevelScalarFieldEnum]


  export const SupplierScalarFieldEnum: {
    id: 'id',
    name: 'name',
    contact: 'contact'
  };

  export type SupplierScalarFieldEnum = (typeof SupplierScalarFieldEnum)[keyof typeof SupplierScalarFieldEnum]


  export const BatchScalarFieldEnum: {
    id: 'id',
    number: 'number',
    drugId: 'drugId',
    drugBrandId: 'drugBrandId',
    type: 'type',
    fullAmount: 'fullAmount',
    expiry: 'expiry',
    stockDate: 'stockDate',
    remainingQuantity: 'remainingQuantity',
    wholesalePrice: 'wholesalePrice',
    retailPrice: 'retailPrice',
    status: 'status',
    unitConcentrationId: 'unitConcentrationId',
    supplierId: 'supplierId'
  };

  export type BatchScalarFieldEnum = (typeof BatchScalarFieldEnum)[keyof typeof BatchScalarFieldEnum]


  export const UnitConcentrationScalarFieldEnum: {
    id: 'id',
    concentration: 'concentration'
  };

  export type UnitConcentrationScalarFieldEnum = (typeof UnitConcentrationScalarFieldEnum)[keyof typeof UnitConcentrationScalarFieldEnum]


  export const PrescriptionScalarFieldEnum: {
    id: 'id',
    time: 'time',
    presentingSymptoms: 'presentingSymptoms',
    status: 'status',
    details: 'details',
    patientId: 'patientId',
    finalPrice: 'finalPrice'
  };

  export type PrescriptionScalarFieldEnum = (typeof PrescriptionScalarFieldEnum)[keyof typeof PrescriptionScalarFieldEnum]


  export const PrescriptionChargesScalarFieldEnum: {
    id: 'id',
    prescriptionId: 'prescriptionId',
    name: 'name',
    type: 'type',
    value: 'value',
    description: 'description'
  };

  export type PrescriptionChargesScalarFieldEnum = (typeof PrescriptionChargesScalarFieldEnum)[keyof typeof PrescriptionChargesScalarFieldEnum]


  export const VitalsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    icon: 'icon',
    color: 'color',
    placeholder: 'placeholder',
    forGender: 'forGender',
    type: 'type'
  };

  export type VitalsScalarFieldEnum = (typeof VitalsScalarFieldEnum)[keyof typeof VitalsScalarFieldEnum]


  export const PrescriptionVitalsScalarFieldEnum: {
    id: 'id',
    prescriptionId: 'prescriptionId',
    vitalId: 'vitalId',
    value: 'value'
  };

  export type PrescriptionVitalsScalarFieldEnum = (typeof PrescriptionVitalsScalarFieldEnum)[keyof typeof PrescriptionVitalsScalarFieldEnum]


  export const MedicalCertificateScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    nameOfThePatient: 'nameOfThePatient',
    addressOfThePatient: 'addressOfThePatient',
    fitForDuty: 'fitForDuty',
    dateOfSickness: 'dateOfSickness',
    recommendedLeaveDays: 'recommendedLeaveDays',
    natureOfTheDisease: 'natureOfTheDisease',
    ageOfThePatient: 'ageOfThePatient',
    reccomendations: 'reccomendations',
    time: 'time'
  };

  export type MedicalCertificateScalarFieldEnum = (typeof MedicalCertificateScalarFieldEnum)[keyof typeof MedicalCertificateScalarFieldEnum]


  export const USSReferralScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    nameOfThePatient: 'nameOfThePatient',
    presentingComplaint: 'presentingComplaint',
    duration: 'duration',
    onExamination: 'onExamination',
    pshx_pmhx: 'pshx_pmhx',
    ageOfThePatient: 'ageOfThePatient',
    reportDate: 'reportDate',
    USS_type: 'USS_type',
    radiologist: 'radiologist',
    radiologist_title: 'radiologist_title',
    time: 'time'
  };

  export type USSReferralScalarFieldEnum = (typeof USSReferralScalarFieldEnum)[keyof typeof USSReferralScalarFieldEnum]


  export const ReferralLetterScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    nameOfThePatient: 'nameOfThePatient',
    consultant_speciality: 'consultant_speciality',
    consultant_name: 'consultant_name',
    condition1: 'condition1',
    condition2: 'condition2',
    condition3: 'condition3',
    investigations: 'investigations',
    ageOfThePatient: 'ageOfThePatient',
    reportDate: 'reportDate',
    time: 'time'
  };

  export type ReferralLetterScalarFieldEnum = (typeof ReferralLetterScalarFieldEnum)[keyof typeof ReferralLetterScalarFieldEnum]


  export const OffRecordMedsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    prescriptionId: 'prescriptionId'
  };

  export type OffRecordMedsScalarFieldEnum = (typeof OffRecordMedsScalarFieldEnum)[keyof typeof OffRecordMedsScalarFieldEnum]


  export const IssueScalarFieldEnum: {
    id: 'id',
    prescriptionId: 'prescriptionId',
    batchId: 'batchId',
    drugId: 'drugId',
    brandId: 'brandId',
    strategy: 'strategy',
    quantity: 'quantity',
    dose: 'dose',
    details: 'details',
    meal: 'meal',
    type: 'type',
    unitConcentrationId: 'unitConcentrationId'
  };

  export type IssueScalarFieldEnum = (typeof IssueScalarFieldEnum)[keyof typeof IssueScalarFieldEnum]


  export const ReportParameterScalarFieldEnum: {
    id: 'id',
    name: 'name',
    units: 'units',
    reportTypeId: 'reportTypeId'
  };

  export type ReportParameterScalarFieldEnum = (typeof ReportParameterScalarFieldEnum)[keyof typeof ReportParameterScalarFieldEnum]


  export const ReportTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description'
  };

  export type ReportTypeScalarFieldEnum = (typeof ReportTypeScalarFieldEnum)[keyof typeof ReportTypeScalarFieldEnum]


  export const PatientReportScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    reportTypeId: 'reportTypeId',
    time: 'time'
  };

  export type PatientReportScalarFieldEnum = (typeof PatientReportScalarFieldEnum)[keyof typeof PatientReportScalarFieldEnum]


  export const ReportValueScalarFieldEnum: {
    id: 'id',
    reportParameterId: 'reportParameterId',
    attention: 'attention',
    value: 'value',
    patientReportId: 'patientReportId'
  };

  export type ReportValueScalarFieldEnum = (typeof ReportValueScalarFieldEnum)[keyof typeof ReportValueScalarFieldEnum]


  export const StratergyHistoryScalarFieldEnum: {
    id: 'id',
    drugId: 'drugId',
    issueId: 'issueId'
  };

  export type StratergyHistoryScalarFieldEnum = (typeof StratergyHistoryScalarFieldEnum)[keyof typeof StratergyHistoryScalarFieldEnum]


  export const BatchHistoryScalarFieldEnum: {
    id: 'id',
    drugId: 'drugId',
    type: 'type',
    unitConcentrationId: 'unitConcentrationId',
    drugBrandId: 'drugBrandId',
    batchId: 'batchId'
  };

  export type BatchHistoryScalarFieldEnum = (typeof BatchHistoryScalarFieldEnum)[keyof typeof BatchHistoryScalarFieldEnum]


  export const ChargeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    value: 'value',
    updatedAt: 'updatedAt'
  };

  export type ChargeScalarFieldEnum = (typeof ChargeScalarFieldEnum)[keyof typeof ChargeScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'Gender[]'
   */
  export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    


  /**
   * Reference to a field of type 'PatientHistoryType'
   */
  export type EnumPatientHistoryTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PatientHistoryType'>
    


  /**
   * Reference to a field of type 'PatientHistoryType[]'
   */
  export type ListEnumPatientHistoryTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PatientHistoryType[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'QueueStatus'
   */
  export type EnumQueueStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueueStatus'>
    


  /**
   * Reference to a field of type 'QueueStatus[]'
   */
  export type ListEnumQueueStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueueStatus[]'>
    


  /**
   * Reference to a field of type 'VisitStatus'
   */
  export type EnumVisitStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VisitStatus'>
    


  /**
   * Reference to a field of type 'VisitStatus[]'
   */
  export type ListEnumVisitStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VisitStatus[]'>
    


  /**
   * Reference to a field of type 'DrugType'
   */
  export type EnumDrugTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DrugType'>
    


  /**
   * Reference to a field of type 'DrugType[]'
   */
  export type ListEnumDrugTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DrugType[]'>
    


  /**
   * Reference to a field of type 'BatchStatus'
   */
  export type EnumBatchStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BatchStatus'>
    


  /**
   * Reference to a field of type 'BatchStatus[]'
   */
  export type ListEnumBatchStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BatchStatus[]'>
    


  /**
   * Reference to a field of type 'PrescriptionStatus'
   */
  export type EnumPrescriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PrescriptionStatus'>
    


  /**
   * Reference to a field of type 'PrescriptionStatus[]'
   */
  export type ListEnumPrescriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PrescriptionStatus[]'>
    


  /**
   * Reference to a field of type 'ChargeType'
   */
  export type EnumChargeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChargeType'>
    


  /**
   * Reference to a field of type 'ChargeType[]'
   */
  export type ListEnumChargeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChargeType[]'>
    


  /**
   * Reference to a field of type 'VitalType'
   */
  export type EnumVitalTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VitalType'>
    


  /**
   * Reference to a field of type 'VitalType[]'
   */
  export type ListEnumVitalTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VitalType[]'>
    


  /**
   * Reference to a field of type 'MedicalCertificateStatus'
   */
  export type EnumMedicalCertificateStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MedicalCertificateStatus'>
    


  /**
   * Reference to a field of type 'MedicalCertificateStatus[]'
   */
  export type ListEnumMedicalCertificateStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MedicalCertificateStatus[]'>
    


  /**
   * Reference to a field of type 'IssuingStrategy'
   */
  export type EnumIssuingStrategyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IssuingStrategy'>
    


  /**
   * Reference to a field of type 'IssuingStrategy[]'
   */
  export type ListEnumIssuingStrategyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IssuingStrategy[]'>
    


  /**
   * Reference to a field of type 'MEAL'
   */
  export type EnumMEALFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MEAL'>
    


  /**
   * Reference to a field of type 'MEAL[]'
   */
  export type ListEnumMEALFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MEAL[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    
  /**
   * Deep Input Types
   */


  export type PatientWhereInput = {
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    id?: IntFilter<"Patient"> | number
    telephone?: StringFilter<"Patient"> | string
    name?: StringFilter<"Patient"> | string
    birthDate?: DateTimeNullableFilter<"Patient"> | Date | string | null
    address?: StringNullableFilter<"Patient"> | string | null
    height?: FloatNullableFilter<"Patient"> | number | null
    weight?: FloatNullableFilter<"Patient"> | number | null
    gender?: EnumGenderFilter<"Patient"> | $Enums.Gender
    NIC?: StringNullableFilter<"Patient"> | string | null
    medicalCert?: MedicalCertificateListRelationFilter
    PatientHistory?: PatientHistoryListRelationFilter
    reports?: PatientReportListRelationFilter
    prescription?: PrescriptionListRelationFilter
    queueEntry?: QueueEntryListRelationFilter
    USSReferral?: USSReferralListRelationFilter
    referralLetters?: ReferralLetterListRelationFilter
  }

  export type PatientOrderByWithRelationInput = {
    id?: SortOrder
    telephone?: SortOrder
    name?: SortOrder
    birthDate?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    gender?: SortOrder
    NIC?: SortOrderInput | SortOrder
    medicalCert?: MedicalCertificateOrderByRelationAggregateInput
    PatientHistory?: PatientHistoryOrderByRelationAggregateInput
    reports?: PatientReportOrderByRelationAggregateInput
    prescription?: PrescriptionOrderByRelationAggregateInput
    queueEntry?: QueueEntryOrderByRelationAggregateInput
    USSReferral?: USSReferralOrderByRelationAggregateInput
    referralLetters?: ReferralLetterOrderByRelationAggregateInput
  }

  export type PatientWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    telephone?: StringFilter<"Patient"> | string
    name?: StringFilter<"Patient"> | string
    birthDate?: DateTimeNullableFilter<"Patient"> | Date | string | null
    address?: StringNullableFilter<"Patient"> | string | null
    height?: FloatNullableFilter<"Patient"> | number | null
    weight?: FloatNullableFilter<"Patient"> | number | null
    gender?: EnumGenderFilter<"Patient"> | $Enums.Gender
    NIC?: StringNullableFilter<"Patient"> | string | null
    medicalCert?: MedicalCertificateListRelationFilter
    PatientHistory?: PatientHistoryListRelationFilter
    reports?: PatientReportListRelationFilter
    prescription?: PrescriptionListRelationFilter
    queueEntry?: QueueEntryListRelationFilter
    USSReferral?: USSReferralListRelationFilter
    referralLetters?: ReferralLetterListRelationFilter
  }, "id">

  export type PatientOrderByWithAggregationInput = {
    id?: SortOrder
    telephone?: SortOrder
    name?: SortOrder
    birthDate?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    gender?: SortOrder
    NIC?: SortOrderInput | SortOrder
    _count?: PatientCountOrderByAggregateInput
    _avg?: PatientAvgOrderByAggregateInput
    _max?: PatientMaxOrderByAggregateInput
    _min?: PatientMinOrderByAggregateInput
    _sum?: PatientSumOrderByAggregateInput
  }

  export type PatientScalarWhereWithAggregatesInput = {
    AND?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    OR?: PatientScalarWhereWithAggregatesInput[]
    NOT?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Patient"> | number
    telephone?: StringWithAggregatesFilter<"Patient"> | string
    name?: StringWithAggregatesFilter<"Patient"> | string
    birthDate?: DateTimeNullableWithAggregatesFilter<"Patient"> | Date | string | null
    address?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    height?: FloatNullableWithAggregatesFilter<"Patient"> | number | null
    weight?: FloatNullableWithAggregatesFilter<"Patient"> | number | null
    gender?: EnumGenderWithAggregatesFilter<"Patient"> | $Enums.Gender
    NIC?: StringNullableWithAggregatesFilter<"Patient"> | string | null
  }

  export type PatientHistoryWhereInput = {
    AND?: PatientHistoryWhereInput | PatientHistoryWhereInput[]
    OR?: PatientHistoryWhereInput[]
    NOT?: PatientHistoryWhereInput | PatientHistoryWhereInput[]
    id?: IntFilter<"PatientHistory"> | number
    patientId?: IntFilter<"PatientHistory"> | number
    description?: StringNullableFilter<"PatientHistory"> | string | null
    type?: EnumPatientHistoryTypeFilter<"PatientHistory"> | $Enums.PatientHistoryType
    time?: DateTimeFilter<"PatientHistory"> | Date | string
    name?: StringFilter<"PatientHistory"> | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
  }

  export type PatientHistoryOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    time?: SortOrder
    name?: SortOrder
    patient?: PatientOrderByWithRelationInput
  }

  export type PatientHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PatientHistoryWhereInput | PatientHistoryWhereInput[]
    OR?: PatientHistoryWhereInput[]
    NOT?: PatientHistoryWhereInput | PatientHistoryWhereInput[]
    patientId?: IntFilter<"PatientHistory"> | number
    description?: StringNullableFilter<"PatientHistory"> | string | null
    type?: EnumPatientHistoryTypeFilter<"PatientHistory"> | $Enums.PatientHistoryType
    time?: DateTimeFilter<"PatientHistory"> | Date | string
    name?: StringFilter<"PatientHistory"> | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
  }, "id">

  export type PatientHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    time?: SortOrder
    name?: SortOrder
    _count?: PatientHistoryCountOrderByAggregateInput
    _avg?: PatientHistoryAvgOrderByAggregateInput
    _max?: PatientHistoryMaxOrderByAggregateInput
    _min?: PatientHistoryMinOrderByAggregateInput
    _sum?: PatientHistorySumOrderByAggregateInput
  }

  export type PatientHistoryScalarWhereWithAggregatesInput = {
    AND?: PatientHistoryScalarWhereWithAggregatesInput | PatientHistoryScalarWhereWithAggregatesInput[]
    OR?: PatientHistoryScalarWhereWithAggregatesInput[]
    NOT?: PatientHistoryScalarWhereWithAggregatesInput | PatientHistoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PatientHistory"> | number
    patientId?: IntWithAggregatesFilter<"PatientHistory"> | number
    description?: StringNullableWithAggregatesFilter<"PatientHistory"> | string | null
    type?: EnumPatientHistoryTypeWithAggregatesFilter<"PatientHistory"> | $Enums.PatientHistoryType
    time?: DateTimeWithAggregatesFilter<"PatientHistory"> | Date | string
    name?: StringWithAggregatesFilter<"PatientHistory"> | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    gender?: EnumGenderFilter<"User"> | $Enums.Gender
    image?: StringNullableFilter<"User"> | string | null
    mobile?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    gender?: SortOrder
    image?: SortOrderInput | SortOrder
    mobile?: SortOrder
    password?: SortOrder
    role?: SortOrder
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    gender?: EnumGenderFilter<"User"> | $Enums.Gender
    image?: StringNullableFilter<"User"> | string | null
    mobile?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    gender?: SortOrder
    image?: SortOrderInput | SortOrder
    mobile?: SortOrder
    password?: SortOrder
    role?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    gender?: EnumGenderWithAggregatesFilter<"User"> | $Enums.Gender
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    mobile?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
  }

  export type QueueWhereInput = {
    AND?: QueueWhereInput | QueueWhereInput[]
    OR?: QueueWhereInput[]
    NOT?: QueueWhereInput | QueueWhereInput[]
    id?: IntFilter<"Queue"> | number
    start?: DateTimeFilter<"Queue"> | Date | string
    end?: DateTimeNullableFilter<"Queue"> | Date | string | null
    status?: EnumQueueStatusFilter<"Queue"> | $Enums.QueueStatus
    entries?: QueueEntryListRelationFilter
  }

  export type QueueOrderByWithRelationInput = {
    id?: SortOrder
    start?: SortOrder
    end?: SortOrderInput | SortOrder
    status?: SortOrder
    entries?: QueueEntryOrderByRelationAggregateInput
  }

  export type QueueWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: QueueWhereInput | QueueWhereInput[]
    OR?: QueueWhereInput[]
    NOT?: QueueWhereInput | QueueWhereInput[]
    start?: DateTimeFilter<"Queue"> | Date | string
    end?: DateTimeNullableFilter<"Queue"> | Date | string | null
    status?: EnumQueueStatusFilter<"Queue"> | $Enums.QueueStatus
    entries?: QueueEntryListRelationFilter
  }, "id">

  export type QueueOrderByWithAggregationInput = {
    id?: SortOrder
    start?: SortOrder
    end?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: QueueCountOrderByAggregateInput
    _avg?: QueueAvgOrderByAggregateInput
    _max?: QueueMaxOrderByAggregateInput
    _min?: QueueMinOrderByAggregateInput
    _sum?: QueueSumOrderByAggregateInput
  }

  export type QueueScalarWhereWithAggregatesInput = {
    AND?: QueueScalarWhereWithAggregatesInput | QueueScalarWhereWithAggregatesInput[]
    OR?: QueueScalarWhereWithAggregatesInput[]
    NOT?: QueueScalarWhereWithAggregatesInput | QueueScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Queue"> | number
    start?: DateTimeWithAggregatesFilter<"Queue"> | Date | string
    end?: DateTimeNullableWithAggregatesFilter<"Queue"> | Date | string | null
    status?: EnumQueueStatusWithAggregatesFilter<"Queue"> | $Enums.QueueStatus
  }

  export type QueueEntryWhereInput = {
    AND?: QueueEntryWhereInput | QueueEntryWhereInput[]
    OR?: QueueEntryWhereInput[]
    NOT?: QueueEntryWhereInput | QueueEntryWhereInput[]
    id?: IntFilter<"QueueEntry"> | number
    token?: IntFilter<"QueueEntry"> | number
    status?: EnumVisitStatusFilter<"QueueEntry"> | $Enums.VisitStatus
    queueId?: IntFilter<"QueueEntry"> | number
    patientId?: IntFilter<"QueueEntry"> | number
    time?: DateTimeFilter<"QueueEntry"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    queue?: XOR<QueueScalarRelationFilter, QueueWhereInput>
  }

  export type QueueEntryOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    status?: SortOrder
    queueId?: SortOrder
    patientId?: SortOrder
    time?: SortOrder
    patient?: PatientOrderByWithRelationInput
    queue?: QueueOrderByWithRelationInput
  }

  export type QueueEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    queueId_token?: QueueEntryQueueIdTokenCompoundUniqueInput
    AND?: QueueEntryWhereInput | QueueEntryWhereInput[]
    OR?: QueueEntryWhereInput[]
    NOT?: QueueEntryWhereInput | QueueEntryWhereInput[]
    token?: IntFilter<"QueueEntry"> | number
    status?: EnumVisitStatusFilter<"QueueEntry"> | $Enums.VisitStatus
    queueId?: IntFilter<"QueueEntry"> | number
    patientId?: IntFilter<"QueueEntry"> | number
    time?: DateTimeFilter<"QueueEntry"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    queue?: XOR<QueueScalarRelationFilter, QueueWhereInput>
  }, "id" | "queueId_token">

  export type QueueEntryOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    status?: SortOrder
    queueId?: SortOrder
    patientId?: SortOrder
    time?: SortOrder
    _count?: QueueEntryCountOrderByAggregateInput
    _avg?: QueueEntryAvgOrderByAggregateInput
    _max?: QueueEntryMaxOrderByAggregateInput
    _min?: QueueEntryMinOrderByAggregateInput
    _sum?: QueueEntrySumOrderByAggregateInput
  }

  export type QueueEntryScalarWhereWithAggregatesInput = {
    AND?: QueueEntryScalarWhereWithAggregatesInput | QueueEntryScalarWhereWithAggregatesInput[]
    OR?: QueueEntryScalarWhereWithAggregatesInput[]
    NOT?: QueueEntryScalarWhereWithAggregatesInput | QueueEntryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"QueueEntry"> | number
    token?: IntWithAggregatesFilter<"QueueEntry"> | number
    status?: EnumVisitStatusWithAggregatesFilter<"QueueEntry"> | $Enums.VisitStatus
    queueId?: IntWithAggregatesFilter<"QueueEntry"> | number
    patientId?: IntWithAggregatesFilter<"QueueEntry"> | number
    time?: DateTimeWithAggregatesFilter<"QueueEntry"> | Date | string
  }

  export type DrugBrandWhereInput = {
    AND?: DrugBrandWhereInput | DrugBrandWhereInput[]
    OR?: DrugBrandWhereInput[]
    NOT?: DrugBrandWhereInput | DrugBrandWhereInput[]
    id?: IntFilter<"DrugBrand"> | number
    name?: StringFilter<"DrugBrand"> | string
    description?: StringNullableFilter<"DrugBrand"> | string | null
    Batch?: BatchListRelationFilter
    BatchHistory?: BatchHistoryListRelationFilter
    Issue?: IssueListRelationFilter
  }

  export type DrugBrandOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    Batch?: BatchOrderByRelationAggregateInput
    BatchHistory?: BatchHistoryOrderByRelationAggregateInput
    Issue?: IssueOrderByRelationAggregateInput
  }

  export type DrugBrandWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DrugBrandWhereInput | DrugBrandWhereInput[]
    OR?: DrugBrandWhereInput[]
    NOT?: DrugBrandWhereInput | DrugBrandWhereInput[]
    name?: StringFilter<"DrugBrand"> | string
    description?: StringNullableFilter<"DrugBrand"> | string | null
    Batch?: BatchListRelationFilter
    BatchHistory?: BatchHistoryListRelationFilter
    Issue?: IssueListRelationFilter
  }, "id">

  export type DrugBrandOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: DrugBrandCountOrderByAggregateInput
    _avg?: DrugBrandAvgOrderByAggregateInput
    _max?: DrugBrandMaxOrderByAggregateInput
    _min?: DrugBrandMinOrderByAggregateInput
    _sum?: DrugBrandSumOrderByAggregateInput
  }

  export type DrugBrandScalarWhereWithAggregatesInput = {
    AND?: DrugBrandScalarWhereWithAggregatesInput | DrugBrandScalarWhereWithAggregatesInput[]
    OR?: DrugBrandScalarWhereWithAggregatesInput[]
    NOT?: DrugBrandScalarWhereWithAggregatesInput | DrugBrandScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DrugBrand"> | number
    name?: StringWithAggregatesFilter<"DrugBrand"> | string
    description?: StringNullableWithAggregatesFilter<"DrugBrand"> | string | null
  }

  export type DrugWhereInput = {
    AND?: DrugWhereInput | DrugWhereInput[]
    OR?: DrugWhereInput[]
    NOT?: DrugWhereInput | DrugWhereInput[]
    id?: IntFilter<"Drug"> | number
    name?: StringFilter<"Drug"> | string
    batch?: BatchListRelationFilter
    BatchHistory?: BatchHistoryListRelationFilter
    Issue?: IssueListRelationFilter
    stratergyHistory?: XOR<StratergyHistoryNullableScalarRelationFilter, StratergyHistoryWhereInput> | null
    bufferLevels?: BufferLevelListRelationFilter
  }

  export type DrugOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    batch?: BatchOrderByRelationAggregateInput
    BatchHistory?: BatchHistoryOrderByRelationAggregateInput
    Issue?: IssueOrderByRelationAggregateInput
    stratergyHistory?: StratergyHistoryOrderByWithRelationInput
    bufferLevels?: BufferLevelOrderByRelationAggregateInput
  }

  export type DrugWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DrugWhereInput | DrugWhereInput[]
    OR?: DrugWhereInput[]
    NOT?: DrugWhereInput | DrugWhereInput[]
    name?: StringFilter<"Drug"> | string
    batch?: BatchListRelationFilter
    BatchHistory?: BatchHistoryListRelationFilter
    Issue?: IssueListRelationFilter
    stratergyHistory?: XOR<StratergyHistoryNullableScalarRelationFilter, StratergyHistoryWhereInput> | null
    bufferLevels?: BufferLevelListRelationFilter
  }, "id">

  export type DrugOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: DrugCountOrderByAggregateInput
    _avg?: DrugAvgOrderByAggregateInput
    _max?: DrugMaxOrderByAggregateInput
    _min?: DrugMinOrderByAggregateInput
    _sum?: DrugSumOrderByAggregateInput
  }

  export type DrugScalarWhereWithAggregatesInput = {
    AND?: DrugScalarWhereWithAggregatesInput | DrugScalarWhereWithAggregatesInput[]
    OR?: DrugScalarWhereWithAggregatesInput[]
    NOT?: DrugScalarWhereWithAggregatesInput | DrugScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Drug"> | number
    name?: StringWithAggregatesFilter<"Drug"> | string
  }

  export type BufferLevelWhereInput = {
    AND?: BufferLevelWhereInput | BufferLevelWhereInput[]
    OR?: BufferLevelWhereInput[]
    NOT?: BufferLevelWhereInput | BufferLevelWhereInput[]
    id?: IntFilter<"BufferLevel"> | number
    drugId?: IntFilter<"BufferLevel"> | number
    type?: EnumDrugTypeFilter<"BufferLevel"> | $Enums.DrugType
    unitConcentrationId?: IntFilter<"BufferLevel"> | number
    bufferAmount?: IntFilter<"BufferLevel"> | number
    drug?: XOR<DrugScalarRelationFilter, DrugWhereInput>
    unitConcentration?: XOR<UnitConcentrationScalarRelationFilter, UnitConcentrationWhereInput>
  }

  export type BufferLevelOrderByWithRelationInput = {
    id?: SortOrder
    drugId?: SortOrder
    type?: SortOrder
    unitConcentrationId?: SortOrder
    bufferAmount?: SortOrder
    drug?: DrugOrderByWithRelationInput
    unitConcentration?: UnitConcentrationOrderByWithRelationInput
  }

  export type BufferLevelWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    drugId_type_unitConcentrationId?: BufferLevelDrugIdTypeUnitConcentrationIdCompoundUniqueInput
    AND?: BufferLevelWhereInput | BufferLevelWhereInput[]
    OR?: BufferLevelWhereInput[]
    NOT?: BufferLevelWhereInput | BufferLevelWhereInput[]
    drugId?: IntFilter<"BufferLevel"> | number
    type?: EnumDrugTypeFilter<"BufferLevel"> | $Enums.DrugType
    unitConcentrationId?: IntFilter<"BufferLevel"> | number
    bufferAmount?: IntFilter<"BufferLevel"> | number
    drug?: XOR<DrugScalarRelationFilter, DrugWhereInput>
    unitConcentration?: XOR<UnitConcentrationScalarRelationFilter, UnitConcentrationWhereInput>
  }, "id" | "drugId_type_unitConcentrationId">

  export type BufferLevelOrderByWithAggregationInput = {
    id?: SortOrder
    drugId?: SortOrder
    type?: SortOrder
    unitConcentrationId?: SortOrder
    bufferAmount?: SortOrder
    _count?: BufferLevelCountOrderByAggregateInput
    _avg?: BufferLevelAvgOrderByAggregateInput
    _max?: BufferLevelMaxOrderByAggregateInput
    _min?: BufferLevelMinOrderByAggregateInput
    _sum?: BufferLevelSumOrderByAggregateInput
  }

  export type BufferLevelScalarWhereWithAggregatesInput = {
    AND?: BufferLevelScalarWhereWithAggregatesInput | BufferLevelScalarWhereWithAggregatesInput[]
    OR?: BufferLevelScalarWhereWithAggregatesInput[]
    NOT?: BufferLevelScalarWhereWithAggregatesInput | BufferLevelScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BufferLevel"> | number
    drugId?: IntWithAggregatesFilter<"BufferLevel"> | number
    type?: EnumDrugTypeWithAggregatesFilter<"BufferLevel"> | $Enums.DrugType
    unitConcentrationId?: IntWithAggregatesFilter<"BufferLevel"> | number
    bufferAmount?: IntWithAggregatesFilter<"BufferLevel"> | number
  }

  export type SupplierWhereInput = {
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    id?: IntFilter<"Supplier"> | number
    name?: StringFilter<"Supplier"> | string
    contact?: StringNullableFilter<"Supplier"> | string | null
    batches?: BatchListRelationFilter
  }

  export type SupplierOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    contact?: SortOrderInput | SortOrder
    batches?: BatchOrderByRelationAggregateInput
  }

  export type SupplierWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    contact?: StringNullableFilter<"Supplier"> | string | null
    batches?: BatchListRelationFilter
  }, "id" | "name">

  export type SupplierOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    contact?: SortOrderInput | SortOrder
    _count?: SupplierCountOrderByAggregateInput
    _avg?: SupplierAvgOrderByAggregateInput
    _max?: SupplierMaxOrderByAggregateInput
    _min?: SupplierMinOrderByAggregateInput
    _sum?: SupplierSumOrderByAggregateInput
  }

  export type SupplierScalarWhereWithAggregatesInput = {
    AND?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    OR?: SupplierScalarWhereWithAggregatesInput[]
    NOT?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Supplier"> | number
    name?: StringWithAggregatesFilter<"Supplier"> | string
    contact?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
  }

  export type BatchWhereInput = {
    AND?: BatchWhereInput | BatchWhereInput[]
    OR?: BatchWhereInput[]
    NOT?: BatchWhereInput | BatchWhereInput[]
    id?: IntFilter<"Batch"> | number
    number?: StringFilter<"Batch"> | string
    drugId?: IntFilter<"Batch"> | number
    drugBrandId?: IntFilter<"Batch"> | number
    type?: EnumDrugTypeFilter<"Batch"> | $Enums.DrugType
    fullAmount?: FloatFilter<"Batch"> | number
    expiry?: DateTimeFilter<"Batch"> | Date | string
    stockDate?: DateTimeFilter<"Batch"> | Date | string
    remainingQuantity?: FloatFilter<"Batch"> | number
    wholesalePrice?: FloatFilter<"Batch"> | number
    retailPrice?: FloatFilter<"Batch"> | number
    status?: EnumBatchStatusFilter<"Batch"> | $Enums.BatchStatus
    unitConcentrationId?: IntFilter<"Batch"> | number
    supplierId?: IntFilter<"Batch"> | number
    drugBrand?: XOR<DrugBrandScalarRelationFilter, DrugBrandWhereInput>
    drug?: XOR<DrugScalarRelationFilter, DrugWhereInput>
    Supplier?: XOR<SupplierScalarRelationFilter, SupplierWhereInput>
    unitConcentration?: XOR<UnitConcentrationScalarRelationFilter, UnitConcentrationWhereInput>
    BatchHistory?: BatchHistoryListRelationFilter
    Issue?: IssueListRelationFilter
  }

  export type BatchOrderByWithRelationInput = {
    id?: SortOrder
    number?: SortOrder
    drugId?: SortOrder
    drugBrandId?: SortOrder
    type?: SortOrder
    fullAmount?: SortOrder
    expiry?: SortOrder
    stockDate?: SortOrder
    remainingQuantity?: SortOrder
    wholesalePrice?: SortOrder
    retailPrice?: SortOrder
    status?: SortOrder
    unitConcentrationId?: SortOrder
    supplierId?: SortOrder
    drugBrand?: DrugBrandOrderByWithRelationInput
    drug?: DrugOrderByWithRelationInput
    Supplier?: SupplierOrderByWithRelationInput
    unitConcentration?: UnitConcentrationOrderByWithRelationInput
    BatchHistory?: BatchHistoryOrderByRelationAggregateInput
    Issue?: IssueOrderByRelationAggregateInput
  }

  export type BatchWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BatchWhereInput | BatchWhereInput[]
    OR?: BatchWhereInput[]
    NOT?: BatchWhereInput | BatchWhereInput[]
    number?: StringFilter<"Batch"> | string
    drugId?: IntFilter<"Batch"> | number
    drugBrandId?: IntFilter<"Batch"> | number
    type?: EnumDrugTypeFilter<"Batch"> | $Enums.DrugType
    fullAmount?: FloatFilter<"Batch"> | number
    expiry?: DateTimeFilter<"Batch"> | Date | string
    stockDate?: DateTimeFilter<"Batch"> | Date | string
    remainingQuantity?: FloatFilter<"Batch"> | number
    wholesalePrice?: FloatFilter<"Batch"> | number
    retailPrice?: FloatFilter<"Batch"> | number
    status?: EnumBatchStatusFilter<"Batch"> | $Enums.BatchStatus
    unitConcentrationId?: IntFilter<"Batch"> | number
    supplierId?: IntFilter<"Batch"> | number
    drugBrand?: XOR<DrugBrandScalarRelationFilter, DrugBrandWhereInput>
    drug?: XOR<DrugScalarRelationFilter, DrugWhereInput>
    Supplier?: XOR<SupplierScalarRelationFilter, SupplierWhereInput>
    unitConcentration?: XOR<UnitConcentrationScalarRelationFilter, UnitConcentrationWhereInput>
    BatchHistory?: BatchHistoryListRelationFilter
    Issue?: IssueListRelationFilter
  }, "id">

  export type BatchOrderByWithAggregationInput = {
    id?: SortOrder
    number?: SortOrder
    drugId?: SortOrder
    drugBrandId?: SortOrder
    type?: SortOrder
    fullAmount?: SortOrder
    expiry?: SortOrder
    stockDate?: SortOrder
    remainingQuantity?: SortOrder
    wholesalePrice?: SortOrder
    retailPrice?: SortOrder
    status?: SortOrder
    unitConcentrationId?: SortOrder
    supplierId?: SortOrder
    _count?: BatchCountOrderByAggregateInput
    _avg?: BatchAvgOrderByAggregateInput
    _max?: BatchMaxOrderByAggregateInput
    _min?: BatchMinOrderByAggregateInput
    _sum?: BatchSumOrderByAggregateInput
  }

  export type BatchScalarWhereWithAggregatesInput = {
    AND?: BatchScalarWhereWithAggregatesInput | BatchScalarWhereWithAggregatesInput[]
    OR?: BatchScalarWhereWithAggregatesInput[]
    NOT?: BatchScalarWhereWithAggregatesInput | BatchScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Batch"> | number
    number?: StringWithAggregatesFilter<"Batch"> | string
    drugId?: IntWithAggregatesFilter<"Batch"> | number
    drugBrandId?: IntWithAggregatesFilter<"Batch"> | number
    type?: EnumDrugTypeWithAggregatesFilter<"Batch"> | $Enums.DrugType
    fullAmount?: FloatWithAggregatesFilter<"Batch"> | number
    expiry?: DateTimeWithAggregatesFilter<"Batch"> | Date | string
    stockDate?: DateTimeWithAggregatesFilter<"Batch"> | Date | string
    remainingQuantity?: FloatWithAggregatesFilter<"Batch"> | number
    wholesalePrice?: FloatWithAggregatesFilter<"Batch"> | number
    retailPrice?: FloatWithAggregatesFilter<"Batch"> | number
    status?: EnumBatchStatusWithAggregatesFilter<"Batch"> | $Enums.BatchStatus
    unitConcentrationId?: IntWithAggregatesFilter<"Batch"> | number
    supplierId?: IntWithAggregatesFilter<"Batch"> | number
  }

  export type UnitConcentrationWhereInput = {
    AND?: UnitConcentrationWhereInput | UnitConcentrationWhereInput[]
    OR?: UnitConcentrationWhereInput[]
    NOT?: UnitConcentrationWhereInput | UnitConcentrationWhereInput[]
    id?: IntFilter<"UnitConcentration"> | number
    concentration?: FloatFilter<"UnitConcentration"> | number
    Batch?: BatchListRelationFilter
    BatchHistory?: BatchHistoryListRelationFilter
    Issue?: IssueListRelationFilter
    BufferLevel?: BufferLevelListRelationFilter
  }

  export type UnitConcentrationOrderByWithRelationInput = {
    id?: SortOrder
    concentration?: SortOrder
    Batch?: BatchOrderByRelationAggregateInput
    BatchHistory?: BatchHistoryOrderByRelationAggregateInput
    Issue?: IssueOrderByRelationAggregateInput
    BufferLevel?: BufferLevelOrderByRelationAggregateInput
  }

  export type UnitConcentrationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    concentration?: number
    AND?: UnitConcentrationWhereInput | UnitConcentrationWhereInput[]
    OR?: UnitConcentrationWhereInput[]
    NOT?: UnitConcentrationWhereInput | UnitConcentrationWhereInput[]
    Batch?: BatchListRelationFilter
    BatchHistory?: BatchHistoryListRelationFilter
    Issue?: IssueListRelationFilter
    BufferLevel?: BufferLevelListRelationFilter
  }, "id" | "concentration">

  export type UnitConcentrationOrderByWithAggregationInput = {
    id?: SortOrder
    concentration?: SortOrder
    _count?: UnitConcentrationCountOrderByAggregateInput
    _avg?: UnitConcentrationAvgOrderByAggregateInput
    _max?: UnitConcentrationMaxOrderByAggregateInput
    _min?: UnitConcentrationMinOrderByAggregateInput
    _sum?: UnitConcentrationSumOrderByAggregateInput
  }

  export type UnitConcentrationScalarWhereWithAggregatesInput = {
    AND?: UnitConcentrationScalarWhereWithAggregatesInput | UnitConcentrationScalarWhereWithAggregatesInput[]
    OR?: UnitConcentrationScalarWhereWithAggregatesInput[]
    NOT?: UnitConcentrationScalarWhereWithAggregatesInput | UnitConcentrationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UnitConcentration"> | number
    concentration?: FloatWithAggregatesFilter<"UnitConcentration"> | number
  }

  export type PrescriptionWhereInput = {
    AND?: PrescriptionWhereInput | PrescriptionWhereInput[]
    OR?: PrescriptionWhereInput[]
    NOT?: PrescriptionWhereInput | PrescriptionWhereInput[]
    id?: IntFilter<"Prescription"> | number
    time?: DateTimeFilter<"Prescription"> | Date | string
    presentingSymptoms?: StringFilter<"Prescription"> | string
    status?: EnumPrescriptionStatusFilter<"Prescription"> | $Enums.PrescriptionStatus
    details?: StringNullableFilter<"Prescription"> | string | null
    patientId?: IntFilter<"Prescription"> | number
    finalPrice?: FloatNullableFilter<"Prescription"> | number | null
    issues?: IssueListRelationFilter
    OffRecordMeds?: OffRecordMedsListRelationFilter
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    PrescriptionVitals?: PrescriptionVitalsListRelationFilter
    Charges?: PrescriptionChargesListRelationFilter
  }

  export type PrescriptionOrderByWithRelationInput = {
    id?: SortOrder
    time?: SortOrder
    presentingSymptoms?: SortOrder
    status?: SortOrder
    details?: SortOrderInput | SortOrder
    patientId?: SortOrder
    finalPrice?: SortOrderInput | SortOrder
    issues?: IssueOrderByRelationAggregateInput
    OffRecordMeds?: OffRecordMedsOrderByRelationAggregateInput
    patient?: PatientOrderByWithRelationInput
    PrescriptionVitals?: PrescriptionVitalsOrderByRelationAggregateInput
    Charges?: PrescriptionChargesOrderByRelationAggregateInput
  }

  export type PrescriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PrescriptionWhereInput | PrescriptionWhereInput[]
    OR?: PrescriptionWhereInput[]
    NOT?: PrescriptionWhereInput | PrescriptionWhereInput[]
    time?: DateTimeFilter<"Prescription"> | Date | string
    presentingSymptoms?: StringFilter<"Prescription"> | string
    status?: EnumPrescriptionStatusFilter<"Prescription"> | $Enums.PrescriptionStatus
    details?: StringNullableFilter<"Prescription"> | string | null
    patientId?: IntFilter<"Prescription"> | number
    finalPrice?: FloatNullableFilter<"Prescription"> | number | null
    issues?: IssueListRelationFilter
    OffRecordMeds?: OffRecordMedsListRelationFilter
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    PrescriptionVitals?: PrescriptionVitalsListRelationFilter
    Charges?: PrescriptionChargesListRelationFilter
  }, "id">

  export type PrescriptionOrderByWithAggregationInput = {
    id?: SortOrder
    time?: SortOrder
    presentingSymptoms?: SortOrder
    status?: SortOrder
    details?: SortOrderInput | SortOrder
    patientId?: SortOrder
    finalPrice?: SortOrderInput | SortOrder
    _count?: PrescriptionCountOrderByAggregateInput
    _avg?: PrescriptionAvgOrderByAggregateInput
    _max?: PrescriptionMaxOrderByAggregateInput
    _min?: PrescriptionMinOrderByAggregateInput
    _sum?: PrescriptionSumOrderByAggregateInput
  }

  export type PrescriptionScalarWhereWithAggregatesInput = {
    AND?: PrescriptionScalarWhereWithAggregatesInput | PrescriptionScalarWhereWithAggregatesInput[]
    OR?: PrescriptionScalarWhereWithAggregatesInput[]
    NOT?: PrescriptionScalarWhereWithAggregatesInput | PrescriptionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Prescription"> | number
    time?: DateTimeWithAggregatesFilter<"Prescription"> | Date | string
    presentingSymptoms?: StringWithAggregatesFilter<"Prescription"> | string
    status?: EnumPrescriptionStatusWithAggregatesFilter<"Prescription"> | $Enums.PrescriptionStatus
    details?: StringNullableWithAggregatesFilter<"Prescription"> | string | null
    patientId?: IntWithAggregatesFilter<"Prescription"> | number
    finalPrice?: FloatNullableWithAggregatesFilter<"Prescription"> | number | null
  }

  export type PrescriptionChargesWhereInput = {
    AND?: PrescriptionChargesWhereInput | PrescriptionChargesWhereInput[]
    OR?: PrescriptionChargesWhereInput[]
    NOT?: PrescriptionChargesWhereInput | PrescriptionChargesWhereInput[]
    id?: IntFilter<"PrescriptionCharges"> | number
    prescriptionId?: IntFilter<"PrescriptionCharges"> | number
    name?: StringFilter<"PrescriptionCharges"> | string
    type?: EnumChargeTypeFilter<"PrescriptionCharges"> | $Enums.ChargeType
    value?: FloatFilter<"PrescriptionCharges"> | number
    description?: StringNullableFilter<"PrescriptionCharges"> | string | null
    Prescription?: XOR<PrescriptionScalarRelationFilter, PrescriptionWhereInput>
  }

  export type PrescriptionChargesOrderByWithRelationInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    Prescription?: PrescriptionOrderByWithRelationInput
  }

  export type PrescriptionChargesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PrescriptionChargesWhereInput | PrescriptionChargesWhereInput[]
    OR?: PrescriptionChargesWhereInput[]
    NOT?: PrescriptionChargesWhereInput | PrescriptionChargesWhereInput[]
    prescriptionId?: IntFilter<"PrescriptionCharges"> | number
    name?: StringFilter<"PrescriptionCharges"> | string
    type?: EnumChargeTypeFilter<"PrescriptionCharges"> | $Enums.ChargeType
    value?: FloatFilter<"PrescriptionCharges"> | number
    description?: StringNullableFilter<"PrescriptionCharges"> | string | null
    Prescription?: XOR<PrescriptionScalarRelationFilter, PrescriptionWhereInput>
  }, "id">

  export type PrescriptionChargesOrderByWithAggregationInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: PrescriptionChargesCountOrderByAggregateInput
    _avg?: PrescriptionChargesAvgOrderByAggregateInput
    _max?: PrescriptionChargesMaxOrderByAggregateInput
    _min?: PrescriptionChargesMinOrderByAggregateInput
    _sum?: PrescriptionChargesSumOrderByAggregateInput
  }

  export type PrescriptionChargesScalarWhereWithAggregatesInput = {
    AND?: PrescriptionChargesScalarWhereWithAggregatesInput | PrescriptionChargesScalarWhereWithAggregatesInput[]
    OR?: PrescriptionChargesScalarWhereWithAggregatesInput[]
    NOT?: PrescriptionChargesScalarWhereWithAggregatesInput | PrescriptionChargesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PrescriptionCharges"> | number
    prescriptionId?: IntWithAggregatesFilter<"PrescriptionCharges"> | number
    name?: StringWithAggregatesFilter<"PrescriptionCharges"> | string
    type?: EnumChargeTypeWithAggregatesFilter<"PrescriptionCharges"> | $Enums.ChargeType
    value?: FloatWithAggregatesFilter<"PrescriptionCharges"> | number
    description?: StringNullableWithAggregatesFilter<"PrescriptionCharges"> | string | null
  }

  export type VitalsWhereInput = {
    AND?: VitalsWhereInput | VitalsWhereInput[]
    OR?: VitalsWhereInput[]
    NOT?: VitalsWhereInput | VitalsWhereInput[]
    id?: IntFilter<"Vitals"> | number
    name?: StringFilter<"Vitals"> | string
    icon?: StringFilter<"Vitals"> | string
    color?: StringFilter<"Vitals"> | string
    placeholder?: StringFilter<"Vitals"> | string
    forGender?: EnumGenderNullableFilter<"Vitals"> | $Enums.Gender | null
    type?: EnumVitalTypeFilter<"Vitals"> | $Enums.VitalType
    PrescriptionVitals?: PrescriptionVitalsListRelationFilter
  }

  export type VitalsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    placeholder?: SortOrder
    forGender?: SortOrderInput | SortOrder
    type?: SortOrder
    PrescriptionVitals?: PrescriptionVitalsOrderByRelationAggregateInput
  }

  export type VitalsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: VitalsWhereInput | VitalsWhereInput[]
    OR?: VitalsWhereInput[]
    NOT?: VitalsWhereInput | VitalsWhereInput[]
    name?: StringFilter<"Vitals"> | string
    icon?: StringFilter<"Vitals"> | string
    color?: StringFilter<"Vitals"> | string
    placeholder?: StringFilter<"Vitals"> | string
    forGender?: EnumGenderNullableFilter<"Vitals"> | $Enums.Gender | null
    type?: EnumVitalTypeFilter<"Vitals"> | $Enums.VitalType
    PrescriptionVitals?: PrescriptionVitalsListRelationFilter
  }, "id">

  export type VitalsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    placeholder?: SortOrder
    forGender?: SortOrderInput | SortOrder
    type?: SortOrder
    _count?: VitalsCountOrderByAggregateInput
    _avg?: VitalsAvgOrderByAggregateInput
    _max?: VitalsMaxOrderByAggregateInput
    _min?: VitalsMinOrderByAggregateInput
    _sum?: VitalsSumOrderByAggregateInput
  }

  export type VitalsScalarWhereWithAggregatesInput = {
    AND?: VitalsScalarWhereWithAggregatesInput | VitalsScalarWhereWithAggregatesInput[]
    OR?: VitalsScalarWhereWithAggregatesInput[]
    NOT?: VitalsScalarWhereWithAggregatesInput | VitalsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Vitals"> | number
    name?: StringWithAggregatesFilter<"Vitals"> | string
    icon?: StringWithAggregatesFilter<"Vitals"> | string
    color?: StringWithAggregatesFilter<"Vitals"> | string
    placeholder?: StringWithAggregatesFilter<"Vitals"> | string
    forGender?: EnumGenderNullableWithAggregatesFilter<"Vitals"> | $Enums.Gender | null
    type?: EnumVitalTypeWithAggregatesFilter<"Vitals"> | $Enums.VitalType
  }

  export type PrescriptionVitalsWhereInput = {
    AND?: PrescriptionVitalsWhereInput | PrescriptionVitalsWhereInput[]
    OR?: PrescriptionVitalsWhereInput[]
    NOT?: PrescriptionVitalsWhereInput | PrescriptionVitalsWhereInput[]
    id?: IntFilter<"PrescriptionVitals"> | number
    prescriptionId?: IntFilter<"PrescriptionVitals"> | number
    vitalId?: IntFilter<"PrescriptionVitals"> | number
    value?: StringFilter<"PrescriptionVitals"> | string
    prescription?: XOR<PrescriptionScalarRelationFilter, PrescriptionWhereInput>
    vital?: XOR<VitalsScalarRelationFilter, VitalsWhereInput>
  }

  export type PrescriptionVitalsOrderByWithRelationInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    vitalId?: SortOrder
    value?: SortOrder
    prescription?: PrescriptionOrderByWithRelationInput
    vital?: VitalsOrderByWithRelationInput
  }

  export type PrescriptionVitalsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PrescriptionVitalsWhereInput | PrescriptionVitalsWhereInput[]
    OR?: PrescriptionVitalsWhereInput[]
    NOT?: PrescriptionVitalsWhereInput | PrescriptionVitalsWhereInput[]
    prescriptionId?: IntFilter<"PrescriptionVitals"> | number
    vitalId?: IntFilter<"PrescriptionVitals"> | number
    value?: StringFilter<"PrescriptionVitals"> | string
    prescription?: XOR<PrescriptionScalarRelationFilter, PrescriptionWhereInput>
    vital?: XOR<VitalsScalarRelationFilter, VitalsWhereInput>
  }, "id">

  export type PrescriptionVitalsOrderByWithAggregationInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    vitalId?: SortOrder
    value?: SortOrder
    _count?: PrescriptionVitalsCountOrderByAggregateInput
    _avg?: PrescriptionVitalsAvgOrderByAggregateInput
    _max?: PrescriptionVitalsMaxOrderByAggregateInput
    _min?: PrescriptionVitalsMinOrderByAggregateInput
    _sum?: PrescriptionVitalsSumOrderByAggregateInput
  }

  export type PrescriptionVitalsScalarWhereWithAggregatesInput = {
    AND?: PrescriptionVitalsScalarWhereWithAggregatesInput | PrescriptionVitalsScalarWhereWithAggregatesInput[]
    OR?: PrescriptionVitalsScalarWhereWithAggregatesInput[]
    NOT?: PrescriptionVitalsScalarWhereWithAggregatesInput | PrescriptionVitalsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PrescriptionVitals"> | number
    prescriptionId?: IntWithAggregatesFilter<"PrescriptionVitals"> | number
    vitalId?: IntWithAggregatesFilter<"PrescriptionVitals"> | number
    value?: StringWithAggregatesFilter<"PrescriptionVitals"> | string
  }

  export type MedicalCertificateWhereInput = {
    AND?: MedicalCertificateWhereInput | MedicalCertificateWhereInput[]
    OR?: MedicalCertificateWhereInput[]
    NOT?: MedicalCertificateWhereInput | MedicalCertificateWhereInput[]
    id?: IntFilter<"MedicalCertificate"> | number
    patientId?: IntFilter<"MedicalCertificate"> | number
    nameOfThePatient?: StringFilter<"MedicalCertificate"> | string
    addressOfThePatient?: StringFilter<"MedicalCertificate"> | string
    fitForDuty?: EnumMedicalCertificateStatusFilter<"MedicalCertificate"> | $Enums.MedicalCertificateStatus
    dateOfSickness?: DateTimeFilter<"MedicalCertificate"> | Date | string
    recommendedLeaveDays?: IntFilter<"MedicalCertificate"> | number
    natureOfTheDisease?: StringFilter<"MedicalCertificate"> | string
    ageOfThePatient?: IntFilter<"MedicalCertificate"> | number
    reccomendations?: StringFilter<"MedicalCertificate"> | string
    time?: DateTimeFilter<"MedicalCertificate"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
  }

  export type MedicalCertificateOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    nameOfThePatient?: SortOrder
    addressOfThePatient?: SortOrder
    fitForDuty?: SortOrder
    dateOfSickness?: SortOrder
    recommendedLeaveDays?: SortOrder
    natureOfTheDisease?: SortOrder
    ageOfThePatient?: SortOrder
    reccomendations?: SortOrder
    time?: SortOrder
    patient?: PatientOrderByWithRelationInput
  }

  export type MedicalCertificateWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MedicalCertificateWhereInput | MedicalCertificateWhereInput[]
    OR?: MedicalCertificateWhereInput[]
    NOT?: MedicalCertificateWhereInput | MedicalCertificateWhereInput[]
    patientId?: IntFilter<"MedicalCertificate"> | number
    nameOfThePatient?: StringFilter<"MedicalCertificate"> | string
    addressOfThePatient?: StringFilter<"MedicalCertificate"> | string
    fitForDuty?: EnumMedicalCertificateStatusFilter<"MedicalCertificate"> | $Enums.MedicalCertificateStatus
    dateOfSickness?: DateTimeFilter<"MedicalCertificate"> | Date | string
    recommendedLeaveDays?: IntFilter<"MedicalCertificate"> | number
    natureOfTheDisease?: StringFilter<"MedicalCertificate"> | string
    ageOfThePatient?: IntFilter<"MedicalCertificate"> | number
    reccomendations?: StringFilter<"MedicalCertificate"> | string
    time?: DateTimeFilter<"MedicalCertificate"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
  }, "id">

  export type MedicalCertificateOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    nameOfThePatient?: SortOrder
    addressOfThePatient?: SortOrder
    fitForDuty?: SortOrder
    dateOfSickness?: SortOrder
    recommendedLeaveDays?: SortOrder
    natureOfTheDisease?: SortOrder
    ageOfThePatient?: SortOrder
    reccomendations?: SortOrder
    time?: SortOrder
    _count?: MedicalCertificateCountOrderByAggregateInput
    _avg?: MedicalCertificateAvgOrderByAggregateInput
    _max?: MedicalCertificateMaxOrderByAggregateInput
    _min?: MedicalCertificateMinOrderByAggregateInput
    _sum?: MedicalCertificateSumOrderByAggregateInput
  }

  export type MedicalCertificateScalarWhereWithAggregatesInput = {
    AND?: MedicalCertificateScalarWhereWithAggregatesInput | MedicalCertificateScalarWhereWithAggregatesInput[]
    OR?: MedicalCertificateScalarWhereWithAggregatesInput[]
    NOT?: MedicalCertificateScalarWhereWithAggregatesInput | MedicalCertificateScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MedicalCertificate"> | number
    patientId?: IntWithAggregatesFilter<"MedicalCertificate"> | number
    nameOfThePatient?: StringWithAggregatesFilter<"MedicalCertificate"> | string
    addressOfThePatient?: StringWithAggregatesFilter<"MedicalCertificate"> | string
    fitForDuty?: EnumMedicalCertificateStatusWithAggregatesFilter<"MedicalCertificate"> | $Enums.MedicalCertificateStatus
    dateOfSickness?: DateTimeWithAggregatesFilter<"MedicalCertificate"> | Date | string
    recommendedLeaveDays?: IntWithAggregatesFilter<"MedicalCertificate"> | number
    natureOfTheDisease?: StringWithAggregatesFilter<"MedicalCertificate"> | string
    ageOfThePatient?: IntWithAggregatesFilter<"MedicalCertificate"> | number
    reccomendations?: StringWithAggregatesFilter<"MedicalCertificate"> | string
    time?: DateTimeWithAggregatesFilter<"MedicalCertificate"> | Date | string
  }

  export type USSReferralWhereInput = {
    AND?: USSReferralWhereInput | USSReferralWhereInput[]
    OR?: USSReferralWhereInput[]
    NOT?: USSReferralWhereInput | USSReferralWhereInput[]
    id?: IntFilter<"USSReferral"> | number
    patientId?: IntFilter<"USSReferral"> | number
    nameOfThePatient?: StringFilter<"USSReferral"> | string
    presentingComplaint?: StringFilter<"USSReferral"> | string
    duration?: StringFilter<"USSReferral"> | string
    onExamination?: StringFilter<"USSReferral"> | string
    pshx_pmhx?: StringFilter<"USSReferral"> | string
    ageOfThePatient?: IntFilter<"USSReferral"> | number
    reportDate?: DateTimeFilter<"USSReferral"> | Date | string
    USS_type?: StringFilter<"USSReferral"> | string
    radiologist?: StringFilter<"USSReferral"> | string
    radiologist_title?: StringFilter<"USSReferral"> | string
    time?: DateTimeFilter<"USSReferral"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
  }

  export type USSReferralOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    nameOfThePatient?: SortOrder
    presentingComplaint?: SortOrder
    duration?: SortOrder
    onExamination?: SortOrder
    pshx_pmhx?: SortOrder
    ageOfThePatient?: SortOrder
    reportDate?: SortOrder
    USS_type?: SortOrder
    radiologist?: SortOrder
    radiologist_title?: SortOrder
    time?: SortOrder
    patient?: PatientOrderByWithRelationInput
  }

  export type USSReferralWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: USSReferralWhereInput | USSReferralWhereInput[]
    OR?: USSReferralWhereInput[]
    NOT?: USSReferralWhereInput | USSReferralWhereInput[]
    patientId?: IntFilter<"USSReferral"> | number
    nameOfThePatient?: StringFilter<"USSReferral"> | string
    presentingComplaint?: StringFilter<"USSReferral"> | string
    duration?: StringFilter<"USSReferral"> | string
    onExamination?: StringFilter<"USSReferral"> | string
    pshx_pmhx?: StringFilter<"USSReferral"> | string
    ageOfThePatient?: IntFilter<"USSReferral"> | number
    reportDate?: DateTimeFilter<"USSReferral"> | Date | string
    USS_type?: StringFilter<"USSReferral"> | string
    radiologist?: StringFilter<"USSReferral"> | string
    radiologist_title?: StringFilter<"USSReferral"> | string
    time?: DateTimeFilter<"USSReferral"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
  }, "id">

  export type USSReferralOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    nameOfThePatient?: SortOrder
    presentingComplaint?: SortOrder
    duration?: SortOrder
    onExamination?: SortOrder
    pshx_pmhx?: SortOrder
    ageOfThePatient?: SortOrder
    reportDate?: SortOrder
    USS_type?: SortOrder
    radiologist?: SortOrder
    radiologist_title?: SortOrder
    time?: SortOrder
    _count?: USSReferralCountOrderByAggregateInput
    _avg?: USSReferralAvgOrderByAggregateInput
    _max?: USSReferralMaxOrderByAggregateInput
    _min?: USSReferralMinOrderByAggregateInput
    _sum?: USSReferralSumOrderByAggregateInput
  }

  export type USSReferralScalarWhereWithAggregatesInput = {
    AND?: USSReferralScalarWhereWithAggregatesInput | USSReferralScalarWhereWithAggregatesInput[]
    OR?: USSReferralScalarWhereWithAggregatesInput[]
    NOT?: USSReferralScalarWhereWithAggregatesInput | USSReferralScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"USSReferral"> | number
    patientId?: IntWithAggregatesFilter<"USSReferral"> | number
    nameOfThePatient?: StringWithAggregatesFilter<"USSReferral"> | string
    presentingComplaint?: StringWithAggregatesFilter<"USSReferral"> | string
    duration?: StringWithAggregatesFilter<"USSReferral"> | string
    onExamination?: StringWithAggregatesFilter<"USSReferral"> | string
    pshx_pmhx?: StringWithAggregatesFilter<"USSReferral"> | string
    ageOfThePatient?: IntWithAggregatesFilter<"USSReferral"> | number
    reportDate?: DateTimeWithAggregatesFilter<"USSReferral"> | Date | string
    USS_type?: StringWithAggregatesFilter<"USSReferral"> | string
    radiologist?: StringWithAggregatesFilter<"USSReferral"> | string
    radiologist_title?: StringWithAggregatesFilter<"USSReferral"> | string
    time?: DateTimeWithAggregatesFilter<"USSReferral"> | Date | string
  }

  export type ReferralLetterWhereInput = {
    AND?: ReferralLetterWhereInput | ReferralLetterWhereInput[]
    OR?: ReferralLetterWhereInput[]
    NOT?: ReferralLetterWhereInput | ReferralLetterWhereInput[]
    id?: IntFilter<"ReferralLetter"> | number
    patientId?: IntFilter<"ReferralLetter"> | number
    nameOfThePatient?: StringFilter<"ReferralLetter"> | string
    consultant_speciality?: StringFilter<"ReferralLetter"> | string
    consultant_name?: StringFilter<"ReferralLetter"> | string
    condition1?: StringFilter<"ReferralLetter"> | string
    condition2?: StringFilter<"ReferralLetter"> | string
    condition3?: StringFilter<"ReferralLetter"> | string
    investigations?: StringFilter<"ReferralLetter"> | string
    ageOfThePatient?: IntFilter<"ReferralLetter"> | number
    reportDate?: DateTimeFilter<"ReferralLetter"> | Date | string
    time?: DateTimeFilter<"ReferralLetter"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
  }

  export type ReferralLetterOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    nameOfThePatient?: SortOrder
    consultant_speciality?: SortOrder
    consultant_name?: SortOrder
    condition1?: SortOrder
    condition2?: SortOrder
    condition3?: SortOrder
    investigations?: SortOrder
    ageOfThePatient?: SortOrder
    reportDate?: SortOrder
    time?: SortOrder
    patient?: PatientOrderByWithRelationInput
  }

  export type ReferralLetterWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReferralLetterWhereInput | ReferralLetterWhereInput[]
    OR?: ReferralLetterWhereInput[]
    NOT?: ReferralLetterWhereInput | ReferralLetterWhereInput[]
    patientId?: IntFilter<"ReferralLetter"> | number
    nameOfThePatient?: StringFilter<"ReferralLetter"> | string
    consultant_speciality?: StringFilter<"ReferralLetter"> | string
    consultant_name?: StringFilter<"ReferralLetter"> | string
    condition1?: StringFilter<"ReferralLetter"> | string
    condition2?: StringFilter<"ReferralLetter"> | string
    condition3?: StringFilter<"ReferralLetter"> | string
    investigations?: StringFilter<"ReferralLetter"> | string
    ageOfThePatient?: IntFilter<"ReferralLetter"> | number
    reportDate?: DateTimeFilter<"ReferralLetter"> | Date | string
    time?: DateTimeFilter<"ReferralLetter"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
  }, "id">

  export type ReferralLetterOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    nameOfThePatient?: SortOrder
    consultant_speciality?: SortOrder
    consultant_name?: SortOrder
    condition1?: SortOrder
    condition2?: SortOrder
    condition3?: SortOrder
    investigations?: SortOrder
    ageOfThePatient?: SortOrder
    reportDate?: SortOrder
    time?: SortOrder
    _count?: ReferralLetterCountOrderByAggregateInput
    _avg?: ReferralLetterAvgOrderByAggregateInput
    _max?: ReferralLetterMaxOrderByAggregateInput
    _min?: ReferralLetterMinOrderByAggregateInput
    _sum?: ReferralLetterSumOrderByAggregateInput
  }

  export type ReferralLetterScalarWhereWithAggregatesInput = {
    AND?: ReferralLetterScalarWhereWithAggregatesInput | ReferralLetterScalarWhereWithAggregatesInput[]
    OR?: ReferralLetterScalarWhereWithAggregatesInput[]
    NOT?: ReferralLetterScalarWhereWithAggregatesInput | ReferralLetterScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ReferralLetter"> | number
    patientId?: IntWithAggregatesFilter<"ReferralLetter"> | number
    nameOfThePatient?: StringWithAggregatesFilter<"ReferralLetter"> | string
    consultant_speciality?: StringWithAggregatesFilter<"ReferralLetter"> | string
    consultant_name?: StringWithAggregatesFilter<"ReferralLetter"> | string
    condition1?: StringWithAggregatesFilter<"ReferralLetter"> | string
    condition2?: StringWithAggregatesFilter<"ReferralLetter"> | string
    condition3?: StringWithAggregatesFilter<"ReferralLetter"> | string
    investigations?: StringWithAggregatesFilter<"ReferralLetter"> | string
    ageOfThePatient?: IntWithAggregatesFilter<"ReferralLetter"> | number
    reportDate?: DateTimeWithAggregatesFilter<"ReferralLetter"> | Date | string
    time?: DateTimeWithAggregatesFilter<"ReferralLetter"> | Date | string
  }

  export type OffRecordMedsWhereInput = {
    AND?: OffRecordMedsWhereInput | OffRecordMedsWhereInput[]
    OR?: OffRecordMedsWhereInput[]
    NOT?: OffRecordMedsWhereInput | OffRecordMedsWhereInput[]
    id?: IntFilter<"OffRecordMeds"> | number
    name?: StringFilter<"OffRecordMeds"> | string
    description?: StringNullableFilter<"OffRecordMeds"> | string | null
    prescriptionId?: IntFilter<"OffRecordMeds"> | number
    prescription?: XOR<PrescriptionScalarRelationFilter, PrescriptionWhereInput>
  }

  export type OffRecordMedsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    prescriptionId?: SortOrder
    prescription?: PrescriptionOrderByWithRelationInput
  }

  export type OffRecordMedsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OffRecordMedsWhereInput | OffRecordMedsWhereInput[]
    OR?: OffRecordMedsWhereInput[]
    NOT?: OffRecordMedsWhereInput | OffRecordMedsWhereInput[]
    name?: StringFilter<"OffRecordMeds"> | string
    description?: StringNullableFilter<"OffRecordMeds"> | string | null
    prescriptionId?: IntFilter<"OffRecordMeds"> | number
    prescription?: XOR<PrescriptionScalarRelationFilter, PrescriptionWhereInput>
  }, "id">

  export type OffRecordMedsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    prescriptionId?: SortOrder
    _count?: OffRecordMedsCountOrderByAggregateInput
    _avg?: OffRecordMedsAvgOrderByAggregateInput
    _max?: OffRecordMedsMaxOrderByAggregateInput
    _min?: OffRecordMedsMinOrderByAggregateInput
    _sum?: OffRecordMedsSumOrderByAggregateInput
  }

  export type OffRecordMedsScalarWhereWithAggregatesInput = {
    AND?: OffRecordMedsScalarWhereWithAggregatesInput | OffRecordMedsScalarWhereWithAggregatesInput[]
    OR?: OffRecordMedsScalarWhereWithAggregatesInput[]
    NOT?: OffRecordMedsScalarWhereWithAggregatesInput | OffRecordMedsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OffRecordMeds"> | number
    name?: StringWithAggregatesFilter<"OffRecordMeds"> | string
    description?: StringNullableWithAggregatesFilter<"OffRecordMeds"> | string | null
    prescriptionId?: IntWithAggregatesFilter<"OffRecordMeds"> | number
  }

  export type IssueWhereInput = {
    AND?: IssueWhereInput | IssueWhereInput[]
    OR?: IssueWhereInput[]
    NOT?: IssueWhereInput | IssueWhereInput[]
    id?: IntFilter<"Issue"> | number
    prescriptionId?: IntFilter<"Issue"> | number
    batchId?: IntNullableFilter<"Issue"> | number | null
    drugId?: IntFilter<"Issue"> | number
    brandId?: IntFilter<"Issue"> | number
    strategy?: EnumIssuingStrategyFilter<"Issue"> | $Enums.IssuingStrategy
    quantity?: FloatFilter<"Issue"> | number
    dose?: FloatFilter<"Issue"> | number
    details?: StringNullableFilter<"Issue"> | string | null
    meal?: EnumMEALNullableFilter<"Issue"> | $Enums.MEAL | null
    type?: EnumDrugTypeFilter<"Issue"> | $Enums.DrugType
    unitConcentrationId?: IntFilter<"Issue"> | number
    batch?: XOR<BatchNullableScalarRelationFilter, BatchWhereInput> | null
    brand?: XOR<DrugBrandScalarRelationFilter, DrugBrandWhereInput>
    drug?: XOR<DrugScalarRelationFilter, DrugWhereInput>
    prescription?: XOR<PrescriptionScalarRelationFilter, PrescriptionWhereInput>
    unitConcentration?: XOR<UnitConcentrationScalarRelationFilter, UnitConcentrationWhereInput>
    stratergyHistory?: StratergyHistoryListRelationFilter
  }

  export type IssueOrderByWithRelationInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    batchId?: SortOrderInput | SortOrder
    drugId?: SortOrder
    brandId?: SortOrder
    strategy?: SortOrder
    quantity?: SortOrder
    dose?: SortOrder
    details?: SortOrderInput | SortOrder
    meal?: SortOrderInput | SortOrder
    type?: SortOrder
    unitConcentrationId?: SortOrder
    batch?: BatchOrderByWithRelationInput
    brand?: DrugBrandOrderByWithRelationInput
    drug?: DrugOrderByWithRelationInput
    prescription?: PrescriptionOrderByWithRelationInput
    unitConcentration?: UnitConcentrationOrderByWithRelationInput
    stratergyHistory?: StratergyHistoryOrderByRelationAggregateInput
  }

  export type IssueWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: IssueWhereInput | IssueWhereInput[]
    OR?: IssueWhereInput[]
    NOT?: IssueWhereInput | IssueWhereInput[]
    prescriptionId?: IntFilter<"Issue"> | number
    batchId?: IntNullableFilter<"Issue"> | number | null
    drugId?: IntFilter<"Issue"> | number
    brandId?: IntFilter<"Issue"> | number
    strategy?: EnumIssuingStrategyFilter<"Issue"> | $Enums.IssuingStrategy
    quantity?: FloatFilter<"Issue"> | number
    dose?: FloatFilter<"Issue"> | number
    details?: StringNullableFilter<"Issue"> | string | null
    meal?: EnumMEALNullableFilter<"Issue"> | $Enums.MEAL | null
    type?: EnumDrugTypeFilter<"Issue"> | $Enums.DrugType
    unitConcentrationId?: IntFilter<"Issue"> | number
    batch?: XOR<BatchNullableScalarRelationFilter, BatchWhereInput> | null
    brand?: XOR<DrugBrandScalarRelationFilter, DrugBrandWhereInput>
    drug?: XOR<DrugScalarRelationFilter, DrugWhereInput>
    prescription?: XOR<PrescriptionScalarRelationFilter, PrescriptionWhereInput>
    unitConcentration?: XOR<UnitConcentrationScalarRelationFilter, UnitConcentrationWhereInput>
    stratergyHistory?: StratergyHistoryListRelationFilter
  }, "id">

  export type IssueOrderByWithAggregationInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    batchId?: SortOrderInput | SortOrder
    drugId?: SortOrder
    brandId?: SortOrder
    strategy?: SortOrder
    quantity?: SortOrder
    dose?: SortOrder
    details?: SortOrderInput | SortOrder
    meal?: SortOrderInput | SortOrder
    type?: SortOrder
    unitConcentrationId?: SortOrder
    _count?: IssueCountOrderByAggregateInput
    _avg?: IssueAvgOrderByAggregateInput
    _max?: IssueMaxOrderByAggregateInput
    _min?: IssueMinOrderByAggregateInput
    _sum?: IssueSumOrderByAggregateInput
  }

  export type IssueScalarWhereWithAggregatesInput = {
    AND?: IssueScalarWhereWithAggregatesInput | IssueScalarWhereWithAggregatesInput[]
    OR?: IssueScalarWhereWithAggregatesInput[]
    NOT?: IssueScalarWhereWithAggregatesInput | IssueScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Issue"> | number
    prescriptionId?: IntWithAggregatesFilter<"Issue"> | number
    batchId?: IntNullableWithAggregatesFilter<"Issue"> | number | null
    drugId?: IntWithAggregatesFilter<"Issue"> | number
    brandId?: IntWithAggregatesFilter<"Issue"> | number
    strategy?: EnumIssuingStrategyWithAggregatesFilter<"Issue"> | $Enums.IssuingStrategy
    quantity?: FloatWithAggregatesFilter<"Issue"> | number
    dose?: FloatWithAggregatesFilter<"Issue"> | number
    details?: StringNullableWithAggregatesFilter<"Issue"> | string | null
    meal?: EnumMEALNullableWithAggregatesFilter<"Issue"> | $Enums.MEAL | null
    type?: EnumDrugTypeWithAggregatesFilter<"Issue"> | $Enums.DrugType
    unitConcentrationId?: IntWithAggregatesFilter<"Issue"> | number
  }

  export type ReportParameterWhereInput = {
    AND?: ReportParameterWhereInput | ReportParameterWhereInput[]
    OR?: ReportParameterWhereInput[]
    NOT?: ReportParameterWhereInput | ReportParameterWhereInput[]
    id?: IntFilter<"ReportParameter"> | number
    name?: StringFilter<"ReportParameter"> | string
    units?: StringNullableFilter<"ReportParameter"> | string | null
    reportTypeId?: IntNullableFilter<"ReportParameter"> | number | null
    ReportType?: XOR<ReportTypeNullableScalarRelationFilter, ReportTypeWhereInput> | null
    ReportValue?: ReportValueListRelationFilter
  }

  export type ReportParameterOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    units?: SortOrderInput | SortOrder
    reportTypeId?: SortOrderInput | SortOrder
    ReportType?: ReportTypeOrderByWithRelationInput
    ReportValue?: ReportValueOrderByRelationAggregateInput
  }

  export type ReportParameterWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReportParameterWhereInput | ReportParameterWhereInput[]
    OR?: ReportParameterWhereInput[]
    NOT?: ReportParameterWhereInput | ReportParameterWhereInput[]
    name?: StringFilter<"ReportParameter"> | string
    units?: StringNullableFilter<"ReportParameter"> | string | null
    reportTypeId?: IntNullableFilter<"ReportParameter"> | number | null
    ReportType?: XOR<ReportTypeNullableScalarRelationFilter, ReportTypeWhereInput> | null
    ReportValue?: ReportValueListRelationFilter
  }, "id">

  export type ReportParameterOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    units?: SortOrderInput | SortOrder
    reportTypeId?: SortOrderInput | SortOrder
    _count?: ReportParameterCountOrderByAggregateInput
    _avg?: ReportParameterAvgOrderByAggregateInput
    _max?: ReportParameterMaxOrderByAggregateInput
    _min?: ReportParameterMinOrderByAggregateInput
    _sum?: ReportParameterSumOrderByAggregateInput
  }

  export type ReportParameterScalarWhereWithAggregatesInput = {
    AND?: ReportParameterScalarWhereWithAggregatesInput | ReportParameterScalarWhereWithAggregatesInput[]
    OR?: ReportParameterScalarWhereWithAggregatesInput[]
    NOT?: ReportParameterScalarWhereWithAggregatesInput | ReportParameterScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ReportParameter"> | number
    name?: StringWithAggregatesFilter<"ReportParameter"> | string
    units?: StringNullableWithAggregatesFilter<"ReportParameter"> | string | null
    reportTypeId?: IntNullableWithAggregatesFilter<"ReportParameter"> | number | null
  }

  export type ReportTypeWhereInput = {
    AND?: ReportTypeWhereInput | ReportTypeWhereInput[]
    OR?: ReportTypeWhereInput[]
    NOT?: ReportTypeWhereInput | ReportTypeWhereInput[]
    id?: IntFilter<"ReportType"> | number
    name?: StringFilter<"ReportType"> | string
    description?: StringNullableFilter<"ReportType"> | string | null
    PatientReport?: PatientReportListRelationFilter
    parameters?: ReportParameterListRelationFilter
  }

  export type ReportTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    PatientReport?: PatientReportOrderByRelationAggregateInput
    parameters?: ReportParameterOrderByRelationAggregateInput
  }

  export type ReportTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: ReportTypeWhereInput | ReportTypeWhereInput[]
    OR?: ReportTypeWhereInput[]
    NOT?: ReportTypeWhereInput | ReportTypeWhereInput[]
    description?: StringNullableFilter<"ReportType"> | string | null
    PatientReport?: PatientReportListRelationFilter
    parameters?: ReportParameterListRelationFilter
  }, "id" | "name">

  export type ReportTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: ReportTypeCountOrderByAggregateInput
    _avg?: ReportTypeAvgOrderByAggregateInput
    _max?: ReportTypeMaxOrderByAggregateInput
    _min?: ReportTypeMinOrderByAggregateInput
    _sum?: ReportTypeSumOrderByAggregateInput
  }

  export type ReportTypeScalarWhereWithAggregatesInput = {
    AND?: ReportTypeScalarWhereWithAggregatesInput | ReportTypeScalarWhereWithAggregatesInput[]
    OR?: ReportTypeScalarWhereWithAggregatesInput[]
    NOT?: ReportTypeScalarWhereWithAggregatesInput | ReportTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ReportType"> | number
    name?: StringWithAggregatesFilter<"ReportType"> | string
    description?: StringNullableWithAggregatesFilter<"ReportType"> | string | null
  }

  export type PatientReportWhereInput = {
    AND?: PatientReportWhereInput | PatientReportWhereInput[]
    OR?: PatientReportWhereInput[]
    NOT?: PatientReportWhereInput | PatientReportWhereInput[]
    id?: IntFilter<"PatientReport"> | number
    patientId?: IntFilter<"PatientReport"> | number
    reportTypeId?: IntFilter<"PatientReport"> | number
    time?: DateTimeFilter<"PatientReport"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    reportType?: XOR<ReportTypeScalarRelationFilter, ReportTypeWhereInput>
    parameters?: ReportValueListRelationFilter
  }

  export type PatientReportOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    reportTypeId?: SortOrder
    time?: SortOrder
    patient?: PatientOrderByWithRelationInput
    reportType?: ReportTypeOrderByWithRelationInput
    parameters?: ReportValueOrderByRelationAggregateInput
  }

  export type PatientReportWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PatientReportWhereInput | PatientReportWhereInput[]
    OR?: PatientReportWhereInput[]
    NOT?: PatientReportWhereInput | PatientReportWhereInput[]
    patientId?: IntFilter<"PatientReport"> | number
    reportTypeId?: IntFilter<"PatientReport"> | number
    time?: DateTimeFilter<"PatientReport"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    reportType?: XOR<ReportTypeScalarRelationFilter, ReportTypeWhereInput>
    parameters?: ReportValueListRelationFilter
  }, "id">

  export type PatientReportOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    reportTypeId?: SortOrder
    time?: SortOrder
    _count?: PatientReportCountOrderByAggregateInput
    _avg?: PatientReportAvgOrderByAggregateInput
    _max?: PatientReportMaxOrderByAggregateInput
    _min?: PatientReportMinOrderByAggregateInput
    _sum?: PatientReportSumOrderByAggregateInput
  }

  export type PatientReportScalarWhereWithAggregatesInput = {
    AND?: PatientReportScalarWhereWithAggregatesInput | PatientReportScalarWhereWithAggregatesInput[]
    OR?: PatientReportScalarWhereWithAggregatesInput[]
    NOT?: PatientReportScalarWhereWithAggregatesInput | PatientReportScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PatientReport"> | number
    patientId?: IntWithAggregatesFilter<"PatientReport"> | number
    reportTypeId?: IntWithAggregatesFilter<"PatientReport"> | number
    time?: DateTimeWithAggregatesFilter<"PatientReport"> | Date | string
  }

  export type ReportValueWhereInput = {
    AND?: ReportValueWhereInput | ReportValueWhereInput[]
    OR?: ReportValueWhereInput[]
    NOT?: ReportValueWhereInput | ReportValueWhereInput[]
    id?: IntFilter<"ReportValue"> | number
    reportParameterId?: IntFilter<"ReportValue"> | number
    attention?: BoolFilter<"ReportValue"> | boolean
    value?: StringFilter<"ReportValue"> | string
    patientReportId?: IntNullableFilter<"ReportValue"> | number | null
    PatientReport?: XOR<PatientReportNullableScalarRelationFilter, PatientReportWhereInput> | null
    reportParameter?: XOR<ReportParameterScalarRelationFilter, ReportParameterWhereInput>
  }

  export type ReportValueOrderByWithRelationInput = {
    id?: SortOrder
    reportParameterId?: SortOrder
    attention?: SortOrder
    value?: SortOrder
    patientReportId?: SortOrderInput | SortOrder
    PatientReport?: PatientReportOrderByWithRelationInput
    reportParameter?: ReportParameterOrderByWithRelationInput
  }

  export type ReportValueWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReportValueWhereInput | ReportValueWhereInput[]
    OR?: ReportValueWhereInput[]
    NOT?: ReportValueWhereInput | ReportValueWhereInput[]
    reportParameterId?: IntFilter<"ReportValue"> | number
    attention?: BoolFilter<"ReportValue"> | boolean
    value?: StringFilter<"ReportValue"> | string
    patientReportId?: IntNullableFilter<"ReportValue"> | number | null
    PatientReport?: XOR<PatientReportNullableScalarRelationFilter, PatientReportWhereInput> | null
    reportParameter?: XOR<ReportParameterScalarRelationFilter, ReportParameterWhereInput>
  }, "id">

  export type ReportValueOrderByWithAggregationInput = {
    id?: SortOrder
    reportParameterId?: SortOrder
    attention?: SortOrder
    value?: SortOrder
    patientReportId?: SortOrderInput | SortOrder
    _count?: ReportValueCountOrderByAggregateInput
    _avg?: ReportValueAvgOrderByAggregateInput
    _max?: ReportValueMaxOrderByAggregateInput
    _min?: ReportValueMinOrderByAggregateInput
    _sum?: ReportValueSumOrderByAggregateInput
  }

  export type ReportValueScalarWhereWithAggregatesInput = {
    AND?: ReportValueScalarWhereWithAggregatesInput | ReportValueScalarWhereWithAggregatesInput[]
    OR?: ReportValueScalarWhereWithAggregatesInput[]
    NOT?: ReportValueScalarWhereWithAggregatesInput | ReportValueScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ReportValue"> | number
    reportParameterId?: IntWithAggregatesFilter<"ReportValue"> | number
    attention?: BoolWithAggregatesFilter<"ReportValue"> | boolean
    value?: StringWithAggregatesFilter<"ReportValue"> | string
    patientReportId?: IntNullableWithAggregatesFilter<"ReportValue"> | number | null
  }

  export type StratergyHistoryWhereInput = {
    AND?: StratergyHistoryWhereInput | StratergyHistoryWhereInput[]
    OR?: StratergyHistoryWhereInput[]
    NOT?: StratergyHistoryWhereInput | StratergyHistoryWhereInput[]
    id?: IntFilter<"StratergyHistory"> | number
    drugId?: IntFilter<"StratergyHistory"> | number
    issueId?: IntFilter<"StratergyHistory"> | number
    drug?: XOR<DrugScalarRelationFilter, DrugWhereInput>
    issue?: XOR<IssueScalarRelationFilter, IssueWhereInput>
  }

  export type StratergyHistoryOrderByWithRelationInput = {
    id?: SortOrder
    drugId?: SortOrder
    issueId?: SortOrder
    drug?: DrugOrderByWithRelationInput
    issue?: IssueOrderByWithRelationInput
  }

  export type StratergyHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    drugId?: number
    AND?: StratergyHistoryWhereInput | StratergyHistoryWhereInput[]
    OR?: StratergyHistoryWhereInput[]
    NOT?: StratergyHistoryWhereInput | StratergyHistoryWhereInput[]
    issueId?: IntFilter<"StratergyHistory"> | number
    drug?: XOR<DrugScalarRelationFilter, DrugWhereInput>
    issue?: XOR<IssueScalarRelationFilter, IssueWhereInput>
  }, "id" | "drugId">

  export type StratergyHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    drugId?: SortOrder
    issueId?: SortOrder
    _count?: StratergyHistoryCountOrderByAggregateInput
    _avg?: StratergyHistoryAvgOrderByAggregateInput
    _max?: StratergyHistoryMaxOrderByAggregateInput
    _min?: StratergyHistoryMinOrderByAggregateInput
    _sum?: StratergyHistorySumOrderByAggregateInput
  }

  export type StratergyHistoryScalarWhereWithAggregatesInput = {
    AND?: StratergyHistoryScalarWhereWithAggregatesInput | StratergyHistoryScalarWhereWithAggregatesInput[]
    OR?: StratergyHistoryScalarWhereWithAggregatesInput[]
    NOT?: StratergyHistoryScalarWhereWithAggregatesInput | StratergyHistoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"StratergyHistory"> | number
    drugId?: IntWithAggregatesFilter<"StratergyHistory"> | number
    issueId?: IntWithAggregatesFilter<"StratergyHistory"> | number
  }

  export type BatchHistoryWhereInput = {
    AND?: BatchHistoryWhereInput | BatchHistoryWhereInput[]
    OR?: BatchHistoryWhereInput[]
    NOT?: BatchHistoryWhereInput | BatchHistoryWhereInput[]
    id?: IntFilter<"BatchHistory"> | number
    drugId?: IntFilter<"BatchHistory"> | number
    type?: EnumDrugTypeFilter<"BatchHistory"> | $Enums.DrugType
    unitConcentrationId?: IntFilter<"BatchHistory"> | number
    drugBrandId?: IntFilter<"BatchHistory"> | number
    batchId?: IntFilter<"BatchHistory"> | number
    batch?: XOR<BatchScalarRelationFilter, BatchWhereInput>
    brand?: XOR<DrugBrandScalarRelationFilter, DrugBrandWhereInput>
    drug?: XOR<DrugScalarRelationFilter, DrugWhereInput>
    unitConcentration?: XOR<UnitConcentrationScalarRelationFilter, UnitConcentrationWhereInput>
  }

  export type BatchHistoryOrderByWithRelationInput = {
    id?: SortOrder
    drugId?: SortOrder
    type?: SortOrder
    unitConcentrationId?: SortOrder
    drugBrandId?: SortOrder
    batchId?: SortOrder
    batch?: BatchOrderByWithRelationInput
    brand?: DrugBrandOrderByWithRelationInput
    drug?: DrugOrderByWithRelationInput
    unitConcentration?: UnitConcentrationOrderByWithRelationInput
  }

  export type BatchHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    drugId_drugBrandId_type_unitConcentrationId?: BatchHistoryDrugIdDrugBrandIdTypeUnitConcentrationIdCompoundUniqueInput
    AND?: BatchHistoryWhereInput | BatchHistoryWhereInput[]
    OR?: BatchHistoryWhereInput[]
    NOT?: BatchHistoryWhereInput | BatchHistoryWhereInput[]
    drugId?: IntFilter<"BatchHistory"> | number
    type?: EnumDrugTypeFilter<"BatchHistory"> | $Enums.DrugType
    unitConcentrationId?: IntFilter<"BatchHistory"> | number
    drugBrandId?: IntFilter<"BatchHistory"> | number
    batchId?: IntFilter<"BatchHistory"> | number
    batch?: XOR<BatchScalarRelationFilter, BatchWhereInput>
    brand?: XOR<DrugBrandScalarRelationFilter, DrugBrandWhereInput>
    drug?: XOR<DrugScalarRelationFilter, DrugWhereInput>
    unitConcentration?: XOR<UnitConcentrationScalarRelationFilter, UnitConcentrationWhereInput>
  }, "id" | "drugId_drugBrandId_type_unitConcentrationId">

  export type BatchHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    drugId?: SortOrder
    type?: SortOrder
    unitConcentrationId?: SortOrder
    drugBrandId?: SortOrder
    batchId?: SortOrder
    _count?: BatchHistoryCountOrderByAggregateInput
    _avg?: BatchHistoryAvgOrderByAggregateInput
    _max?: BatchHistoryMaxOrderByAggregateInput
    _min?: BatchHistoryMinOrderByAggregateInput
    _sum?: BatchHistorySumOrderByAggregateInput
  }

  export type BatchHistoryScalarWhereWithAggregatesInput = {
    AND?: BatchHistoryScalarWhereWithAggregatesInput | BatchHistoryScalarWhereWithAggregatesInput[]
    OR?: BatchHistoryScalarWhereWithAggregatesInput[]
    NOT?: BatchHistoryScalarWhereWithAggregatesInput | BatchHistoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BatchHistory"> | number
    drugId?: IntWithAggregatesFilter<"BatchHistory"> | number
    type?: EnumDrugTypeWithAggregatesFilter<"BatchHistory"> | $Enums.DrugType
    unitConcentrationId?: IntWithAggregatesFilter<"BatchHistory"> | number
    drugBrandId?: IntWithAggregatesFilter<"BatchHistory"> | number
    batchId?: IntWithAggregatesFilter<"BatchHistory"> | number
  }

  export type ChargeWhereInput = {
    AND?: ChargeWhereInput | ChargeWhereInput[]
    OR?: ChargeWhereInput[]
    NOT?: ChargeWhereInput | ChargeWhereInput[]
    id?: IntFilter<"Charge"> | number
    name?: StringFilter<"Charge"> | string
    type?: EnumChargeTypeFilter<"Charge"> | $Enums.ChargeType
    value?: FloatFilter<"Charge"> | number
    updatedAt?: DateTimeFilter<"Charge"> | Date | string
  }

  export type ChargeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    value?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChargeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: ChargeWhereInput | ChargeWhereInput[]
    OR?: ChargeWhereInput[]
    NOT?: ChargeWhereInput | ChargeWhereInput[]
    type?: EnumChargeTypeFilter<"Charge"> | $Enums.ChargeType
    value?: FloatFilter<"Charge"> | number
    updatedAt?: DateTimeFilter<"Charge"> | Date | string
  }, "id" | "name">

  export type ChargeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    value?: SortOrder
    updatedAt?: SortOrder
    _count?: ChargeCountOrderByAggregateInput
    _avg?: ChargeAvgOrderByAggregateInput
    _max?: ChargeMaxOrderByAggregateInput
    _min?: ChargeMinOrderByAggregateInput
    _sum?: ChargeSumOrderByAggregateInput
  }

  export type ChargeScalarWhereWithAggregatesInput = {
    AND?: ChargeScalarWhereWithAggregatesInput | ChargeScalarWhereWithAggregatesInput[]
    OR?: ChargeScalarWhereWithAggregatesInput[]
    NOT?: ChargeScalarWhereWithAggregatesInput | ChargeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Charge"> | number
    name?: StringWithAggregatesFilter<"Charge"> | string
    type?: EnumChargeTypeWithAggregatesFilter<"Charge"> | $Enums.ChargeType
    value?: FloatWithAggregatesFilter<"Charge"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"Charge"> | Date | string
  }

  export type PatientCreateInput = {
    telephone: string
    name: string
    birthDate?: Date | string | null
    address?: string | null
    height?: number | null
    weight?: number | null
    gender: $Enums.Gender
    NIC?: string | null
    medicalCert?: MedicalCertificateCreateNestedManyWithoutPatientInput
    PatientHistory?: PatientHistoryCreateNestedManyWithoutPatientInput
    reports?: PatientReportCreateNestedManyWithoutPatientInput
    prescription?: PrescriptionCreateNestedManyWithoutPatientInput
    queueEntry?: QueueEntryCreateNestedManyWithoutPatientInput
    USSReferral?: USSReferralCreateNestedManyWithoutPatientInput
    referralLetters?: ReferralLetterCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateInput = {
    id?: number
    telephone: string
    name: string
    birthDate?: Date | string | null
    address?: string | null
    height?: number | null
    weight?: number | null
    gender: $Enums.Gender
    NIC?: string | null
    medicalCert?: MedicalCertificateUncheckedCreateNestedManyWithoutPatientInput
    PatientHistory?: PatientHistoryUncheckedCreateNestedManyWithoutPatientInput
    reports?: PatientReportUncheckedCreateNestedManyWithoutPatientInput
    prescription?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    queueEntry?: QueueEntryUncheckedCreateNestedManyWithoutPatientInput
    USSReferral?: USSReferralUncheckedCreateNestedManyWithoutPatientInput
    referralLetters?: ReferralLetterUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientUpdateInput = {
    telephone?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
    medicalCert?: MedicalCertificateUpdateManyWithoutPatientNestedInput
    PatientHistory?: PatientHistoryUpdateManyWithoutPatientNestedInput
    reports?: PatientReportUpdateManyWithoutPatientNestedInput
    prescription?: PrescriptionUpdateManyWithoutPatientNestedInput
    queueEntry?: QueueEntryUpdateManyWithoutPatientNestedInput
    USSReferral?: USSReferralUpdateManyWithoutPatientNestedInput
    referralLetters?: ReferralLetterUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    telephone?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
    medicalCert?: MedicalCertificateUncheckedUpdateManyWithoutPatientNestedInput
    PatientHistory?: PatientHistoryUncheckedUpdateManyWithoutPatientNestedInput
    reports?: PatientReportUncheckedUpdateManyWithoutPatientNestedInput
    prescription?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    queueEntry?: QueueEntryUncheckedUpdateManyWithoutPatientNestedInput
    USSReferral?: USSReferralUncheckedUpdateManyWithoutPatientNestedInput
    referralLetters?: ReferralLetterUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientCreateManyInput = {
    id?: number
    telephone: string
    name: string
    birthDate?: Date | string | null
    address?: string | null
    height?: number | null
    weight?: number | null
    gender: $Enums.Gender
    NIC?: string | null
  }

  export type PatientUpdateManyMutationInput = {
    telephone?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PatientUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    telephone?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PatientHistoryCreateInput = {
    description?: string | null
    type: $Enums.PatientHistoryType
    time?: Date | string
    name: string
    patient: PatientCreateNestedOneWithoutPatientHistoryInput
  }

  export type PatientHistoryUncheckedCreateInput = {
    id?: number
    patientId: number
    description?: string | null
    type: $Enums.PatientHistoryType
    time?: Date | string
    name: string
  }

  export type PatientHistoryUpdateInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPatientHistoryTypeFieldUpdateOperationsInput | $Enums.PatientHistoryType
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    patient?: PatientUpdateOneRequiredWithoutPatientHistoryNestedInput
  }

  export type PatientHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPatientHistoryTypeFieldUpdateOperationsInput | $Enums.PatientHistoryType
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PatientHistoryCreateManyInput = {
    id?: number
    patientId: number
    description?: string | null
    type: $Enums.PatientHistoryType
    time?: Date | string
    name: string
  }

  export type PatientHistoryUpdateManyMutationInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPatientHistoryTypeFieldUpdateOperationsInput | $Enums.PatientHistoryType
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PatientHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPatientHistoryTypeFieldUpdateOperationsInput | $Enums.PatientHistoryType
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateInput = {
    email: string
    name: string
    gender: $Enums.Gender
    image?: string | null
    mobile: string
    password: string
    role: $Enums.Role
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    name: string
    gender: $Enums.Gender
    image?: string | null
    mobile: string
    password: string
    role: $Enums.Role
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    image?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    image?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    name: string
    gender: $Enums.Gender
    image?: string | null
    mobile: string
    password: string
    role: $Enums.Role
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    image?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    image?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type QueueCreateInput = {
    start?: Date | string
    end?: Date | string | null
    status?: $Enums.QueueStatus
    entries?: QueueEntryCreateNestedManyWithoutQueueInput
  }

  export type QueueUncheckedCreateInput = {
    id?: number
    start?: Date | string
    end?: Date | string | null
    status?: $Enums.QueueStatus
    entries?: QueueEntryUncheckedCreateNestedManyWithoutQueueInput
  }

  export type QueueUpdateInput = {
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus
    entries?: QueueEntryUpdateManyWithoutQueueNestedInput
  }

  export type QueueUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus
    entries?: QueueEntryUncheckedUpdateManyWithoutQueueNestedInput
  }

  export type QueueCreateManyInput = {
    id?: number
    start?: Date | string
    end?: Date | string | null
    status?: $Enums.QueueStatus
  }

  export type QueueUpdateManyMutationInput = {
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus
  }

  export type QueueUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus
  }

  export type QueueEntryCreateInput = {
    token: number
    status?: $Enums.VisitStatus
    time?: Date | string
    patient: PatientCreateNestedOneWithoutQueueEntryInput
    queue: QueueCreateNestedOneWithoutEntriesInput
  }

  export type QueueEntryUncheckedCreateInput = {
    id?: number
    token: number
    status?: $Enums.VisitStatus
    queueId: number
    patientId: number
    time?: Date | string
  }

  export type QueueEntryUpdateInput = {
    token?: IntFieldUpdateOperationsInput | number
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutQueueEntryNestedInput
    queue?: QueueUpdateOneRequiredWithoutEntriesNestedInput
  }

  export type QueueEntryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: IntFieldUpdateOperationsInput | number
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    queueId?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QueueEntryCreateManyInput = {
    id?: number
    token: number
    status?: $Enums.VisitStatus
    queueId: number
    patientId: number
    time?: Date | string
  }

  export type QueueEntryUpdateManyMutationInput = {
    token?: IntFieldUpdateOperationsInput | number
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QueueEntryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: IntFieldUpdateOperationsInput | number
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    queueId?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DrugBrandCreateInput = {
    name: string
    description?: string | null
    Batch?: BatchCreateNestedManyWithoutDrugBrandInput
    BatchHistory?: BatchHistoryCreateNestedManyWithoutBrandInput
    Issue?: IssueCreateNestedManyWithoutBrandInput
  }

  export type DrugBrandUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    Batch?: BatchUncheckedCreateNestedManyWithoutDrugBrandInput
    BatchHistory?: BatchHistoryUncheckedCreateNestedManyWithoutBrandInput
    Issue?: IssueUncheckedCreateNestedManyWithoutBrandInput
  }

  export type DrugBrandUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    Batch?: BatchUpdateManyWithoutDrugBrandNestedInput
    BatchHistory?: BatchHistoryUpdateManyWithoutBrandNestedInput
    Issue?: IssueUpdateManyWithoutBrandNestedInput
  }

  export type DrugBrandUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    Batch?: BatchUncheckedUpdateManyWithoutDrugBrandNestedInput
    BatchHistory?: BatchHistoryUncheckedUpdateManyWithoutBrandNestedInput
    Issue?: IssueUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type DrugBrandCreateManyInput = {
    id?: number
    name: string
    description?: string | null
  }

  export type DrugBrandUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DrugBrandUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DrugCreateInput = {
    name: string
    batch?: BatchCreateNestedManyWithoutDrugInput
    BatchHistory?: BatchHistoryCreateNestedManyWithoutDrugInput
    Issue?: IssueCreateNestedManyWithoutDrugInput
    stratergyHistory?: StratergyHistoryCreateNestedOneWithoutDrugInput
    bufferLevels?: BufferLevelCreateNestedManyWithoutDrugInput
  }

  export type DrugUncheckedCreateInput = {
    id?: number
    name: string
    batch?: BatchUncheckedCreateNestedManyWithoutDrugInput
    BatchHistory?: BatchHistoryUncheckedCreateNestedManyWithoutDrugInput
    Issue?: IssueUncheckedCreateNestedManyWithoutDrugInput
    stratergyHistory?: StratergyHistoryUncheckedCreateNestedOneWithoutDrugInput
    bufferLevels?: BufferLevelUncheckedCreateNestedManyWithoutDrugInput
  }

  export type DrugUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    batch?: BatchUpdateManyWithoutDrugNestedInput
    BatchHistory?: BatchHistoryUpdateManyWithoutDrugNestedInput
    Issue?: IssueUpdateManyWithoutDrugNestedInput
    stratergyHistory?: StratergyHistoryUpdateOneWithoutDrugNestedInput
    bufferLevels?: BufferLevelUpdateManyWithoutDrugNestedInput
  }

  export type DrugUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    batch?: BatchUncheckedUpdateManyWithoutDrugNestedInput
    BatchHistory?: BatchHistoryUncheckedUpdateManyWithoutDrugNestedInput
    Issue?: IssueUncheckedUpdateManyWithoutDrugNestedInput
    stratergyHistory?: StratergyHistoryUncheckedUpdateOneWithoutDrugNestedInput
    bufferLevels?: BufferLevelUncheckedUpdateManyWithoutDrugNestedInput
  }

  export type DrugCreateManyInput = {
    id?: number
    name: string
  }

  export type DrugUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DrugUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type BufferLevelCreateInput = {
    type: $Enums.DrugType
    bufferAmount: number
    drug: DrugCreateNestedOneWithoutBufferLevelsInput
    unitConcentration: UnitConcentrationCreateNestedOneWithoutBufferLevelInput
  }

  export type BufferLevelUncheckedCreateInput = {
    id?: number
    drugId: number
    type: $Enums.DrugType
    unitConcentrationId: number
    bufferAmount: number
  }

  export type BufferLevelUpdateInput = {
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    bufferAmount?: IntFieldUpdateOperationsInput | number
    drug?: DrugUpdateOneRequiredWithoutBufferLevelsNestedInput
    unitConcentration?: UnitConcentrationUpdateOneRequiredWithoutBufferLevelNestedInput
  }

  export type BufferLevelUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    drugId?: IntFieldUpdateOperationsInput | number
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    unitConcentrationId?: IntFieldUpdateOperationsInput | number
    bufferAmount?: IntFieldUpdateOperationsInput | number
  }

  export type BufferLevelCreateManyInput = {
    id?: number
    drugId: number
    type: $Enums.DrugType
    unitConcentrationId: number
    bufferAmount: number
  }

  export type BufferLevelUpdateManyMutationInput = {
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    bufferAmount?: IntFieldUpdateOperationsInput | number
  }

  export type BufferLevelUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    drugId?: IntFieldUpdateOperationsInput | number
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    unitConcentrationId?: IntFieldUpdateOperationsInput | number
    bufferAmount?: IntFieldUpdateOperationsInput | number
  }

  export type SupplierCreateInput = {
    name: string
    contact?: string | null
    batches?: BatchCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateInput = {
    id?: number
    name: string
    contact?: string | null
    batches?: BatchUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    batches?: BatchUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    batches?: BatchUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierCreateManyInput = {
    id?: number
    name: string
    contact?: string | null
  }

  export type SupplierUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SupplierUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BatchCreateInput = {
    number: string
    type: $Enums.DrugType
    fullAmount: number
    expiry: Date | string
    stockDate?: Date | string
    remainingQuantity: number
    wholesalePrice: number
    retailPrice: number
    status: $Enums.BatchStatus
    drugBrand: DrugBrandCreateNestedOneWithoutBatchInput
    drug: DrugCreateNestedOneWithoutBatchInput
    Supplier: SupplierCreateNestedOneWithoutBatchesInput
    unitConcentration: UnitConcentrationCreateNestedOneWithoutBatchInput
    BatchHistory?: BatchHistoryCreateNestedManyWithoutBatchInput
    Issue?: IssueCreateNestedManyWithoutBatchInput
  }

  export type BatchUncheckedCreateInput = {
    id?: number
    number: string
    drugId: number
    drugBrandId: number
    type: $Enums.DrugType
    fullAmount: number
    expiry: Date | string
    stockDate?: Date | string
    remainingQuantity: number
    wholesalePrice: number
    retailPrice: number
    status: $Enums.BatchStatus
    unitConcentrationId: number
    supplierId: number
    BatchHistory?: BatchHistoryUncheckedCreateNestedManyWithoutBatchInput
    Issue?: IssueUncheckedCreateNestedManyWithoutBatchInput
  }

  export type BatchUpdateInput = {
    number?: StringFieldUpdateOperationsInput | string
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    fullAmount?: FloatFieldUpdateOperationsInput | number
    expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    stockDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remainingQuantity?: FloatFieldUpdateOperationsInput | number
    wholesalePrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    drugBrand?: DrugBrandUpdateOneRequiredWithoutBatchNestedInput
    drug?: DrugUpdateOneRequiredWithoutBatchNestedInput
    Supplier?: SupplierUpdateOneRequiredWithoutBatchesNestedInput
    unitConcentration?: UnitConcentrationUpdateOneRequiredWithoutBatchNestedInput
    BatchHistory?: BatchHistoryUpdateManyWithoutBatchNestedInput
    Issue?: IssueUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    drugId?: IntFieldUpdateOperationsInput | number
    drugBrandId?: IntFieldUpdateOperationsInput | number
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    fullAmount?: FloatFieldUpdateOperationsInput | number
    expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    stockDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remainingQuantity?: FloatFieldUpdateOperationsInput | number
    wholesalePrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    unitConcentrationId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    BatchHistory?: BatchHistoryUncheckedUpdateManyWithoutBatchNestedInput
    Issue?: IssueUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type BatchCreateManyInput = {
    id?: number
    number: string
    drugId: number
    drugBrandId: number
    type: $Enums.DrugType
    fullAmount: number
    expiry: Date | string
    stockDate?: Date | string
    remainingQuantity: number
    wholesalePrice: number
    retailPrice: number
    status: $Enums.BatchStatus
    unitConcentrationId: number
    supplierId: number
  }

  export type BatchUpdateManyMutationInput = {
    number?: StringFieldUpdateOperationsInput | string
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    fullAmount?: FloatFieldUpdateOperationsInput | number
    expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    stockDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remainingQuantity?: FloatFieldUpdateOperationsInput | number
    wholesalePrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
  }

  export type BatchUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    drugId?: IntFieldUpdateOperationsInput | number
    drugBrandId?: IntFieldUpdateOperationsInput | number
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    fullAmount?: FloatFieldUpdateOperationsInput | number
    expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    stockDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remainingQuantity?: FloatFieldUpdateOperationsInput | number
    wholesalePrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    unitConcentrationId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
  }

  export type UnitConcentrationCreateInput = {
    concentration: number
    Batch?: BatchCreateNestedManyWithoutUnitConcentrationInput
    BatchHistory?: BatchHistoryCreateNestedManyWithoutUnitConcentrationInput
    Issue?: IssueCreateNestedManyWithoutUnitConcentrationInput
    BufferLevel?: BufferLevelCreateNestedManyWithoutUnitConcentrationInput
  }

  export type UnitConcentrationUncheckedCreateInput = {
    id?: number
    concentration: number
    Batch?: BatchUncheckedCreateNestedManyWithoutUnitConcentrationInput
    BatchHistory?: BatchHistoryUncheckedCreateNestedManyWithoutUnitConcentrationInput
    Issue?: IssueUncheckedCreateNestedManyWithoutUnitConcentrationInput
    BufferLevel?: BufferLevelUncheckedCreateNestedManyWithoutUnitConcentrationInput
  }

  export type UnitConcentrationUpdateInput = {
    concentration?: FloatFieldUpdateOperationsInput | number
    Batch?: BatchUpdateManyWithoutUnitConcentrationNestedInput
    BatchHistory?: BatchHistoryUpdateManyWithoutUnitConcentrationNestedInput
    Issue?: IssueUpdateManyWithoutUnitConcentrationNestedInput
    BufferLevel?: BufferLevelUpdateManyWithoutUnitConcentrationNestedInput
  }

  export type UnitConcentrationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    concentration?: FloatFieldUpdateOperationsInput | number
    Batch?: BatchUncheckedUpdateManyWithoutUnitConcentrationNestedInput
    BatchHistory?: BatchHistoryUncheckedUpdateManyWithoutUnitConcentrationNestedInput
    Issue?: IssueUncheckedUpdateManyWithoutUnitConcentrationNestedInput
    BufferLevel?: BufferLevelUncheckedUpdateManyWithoutUnitConcentrationNestedInput
  }

  export type UnitConcentrationCreateManyInput = {
    id?: number
    concentration: number
  }

  export type UnitConcentrationUpdateManyMutationInput = {
    concentration?: FloatFieldUpdateOperationsInput | number
  }

  export type UnitConcentrationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    concentration?: FloatFieldUpdateOperationsInput | number
  }

  export type PrescriptionCreateInput = {
    time?: Date | string
    presentingSymptoms: string
    status?: $Enums.PrescriptionStatus
    details?: string | null
    finalPrice?: number | null
    issues?: IssueCreateNestedManyWithoutPrescriptionInput
    OffRecordMeds?: OffRecordMedsCreateNestedManyWithoutPrescriptionInput
    patient: PatientCreateNestedOneWithoutPrescriptionInput
    PrescriptionVitals?: PrescriptionVitalsCreateNestedManyWithoutPrescriptionInput
    Charges?: PrescriptionChargesCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionUncheckedCreateInput = {
    id?: number
    time?: Date | string
    presentingSymptoms: string
    status?: $Enums.PrescriptionStatus
    details?: string | null
    patientId: number
    finalPrice?: number | null
    issues?: IssueUncheckedCreateNestedManyWithoutPrescriptionInput
    OffRecordMeds?: OffRecordMedsUncheckedCreateNestedManyWithoutPrescriptionInput
    PrescriptionVitals?: PrescriptionVitalsUncheckedCreateNestedManyWithoutPrescriptionInput
    Charges?: PrescriptionChargesUncheckedCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionUpdateInput = {
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    presentingSymptoms?: StringFieldUpdateOperationsInput | string
    status?: EnumPrescriptionStatusFieldUpdateOperationsInput | $Enums.PrescriptionStatus
    details?: NullableStringFieldUpdateOperationsInput | string | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    issues?: IssueUpdateManyWithoutPrescriptionNestedInput
    OffRecordMeds?: OffRecordMedsUpdateManyWithoutPrescriptionNestedInput
    patient?: PatientUpdateOneRequiredWithoutPrescriptionNestedInput
    PrescriptionVitals?: PrescriptionVitalsUpdateManyWithoutPrescriptionNestedInput
    Charges?: PrescriptionChargesUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    presentingSymptoms?: StringFieldUpdateOperationsInput | string
    status?: EnumPrescriptionStatusFieldUpdateOperationsInput | $Enums.PrescriptionStatus
    details?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: IntFieldUpdateOperationsInput | number
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    issues?: IssueUncheckedUpdateManyWithoutPrescriptionNestedInput
    OffRecordMeds?: OffRecordMedsUncheckedUpdateManyWithoutPrescriptionNestedInput
    PrescriptionVitals?: PrescriptionVitalsUncheckedUpdateManyWithoutPrescriptionNestedInput
    Charges?: PrescriptionChargesUncheckedUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionCreateManyInput = {
    id?: number
    time?: Date | string
    presentingSymptoms: string
    status?: $Enums.PrescriptionStatus
    details?: string | null
    patientId: number
    finalPrice?: number | null
  }

  export type PrescriptionUpdateManyMutationInput = {
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    presentingSymptoms?: StringFieldUpdateOperationsInput | string
    status?: EnumPrescriptionStatusFieldUpdateOperationsInput | $Enums.PrescriptionStatus
    details?: NullableStringFieldUpdateOperationsInput | string | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type PrescriptionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    presentingSymptoms?: StringFieldUpdateOperationsInput | string
    status?: EnumPrescriptionStatusFieldUpdateOperationsInput | $Enums.PrescriptionStatus
    details?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: IntFieldUpdateOperationsInput | number
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type PrescriptionChargesCreateInput = {
    name: string
    type: $Enums.ChargeType
    value: number
    description?: string | null
    Prescription: PrescriptionCreateNestedOneWithoutChargesInput
  }

  export type PrescriptionChargesUncheckedCreateInput = {
    id?: number
    prescriptionId: number
    name: string
    type: $Enums.ChargeType
    value: number
    description?: string | null
  }

  export type PrescriptionChargesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumChargeTypeFieldUpdateOperationsInput | $Enums.ChargeType
    value?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    Prescription?: PrescriptionUpdateOneRequiredWithoutChargesNestedInput
  }

  export type PrescriptionChargesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    prescriptionId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumChargeTypeFieldUpdateOperationsInput | $Enums.ChargeType
    value?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PrescriptionChargesCreateManyInput = {
    id?: number
    prescriptionId: number
    name: string
    type: $Enums.ChargeType
    value: number
    description?: string | null
  }

  export type PrescriptionChargesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumChargeTypeFieldUpdateOperationsInput | $Enums.ChargeType
    value?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PrescriptionChargesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    prescriptionId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumChargeTypeFieldUpdateOperationsInput | $Enums.ChargeType
    value?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VitalsCreateInput = {
    name: string
    icon: string
    color: string
    placeholder: string
    forGender?: $Enums.Gender | null
    type: $Enums.VitalType
    PrescriptionVitals?: PrescriptionVitalsCreateNestedManyWithoutVitalInput
  }

  export type VitalsUncheckedCreateInput = {
    id?: number
    name: string
    icon: string
    color: string
    placeholder: string
    forGender?: $Enums.Gender | null
    type: $Enums.VitalType
    PrescriptionVitals?: PrescriptionVitalsUncheckedCreateNestedManyWithoutVitalInput
  }

  export type VitalsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    placeholder?: StringFieldUpdateOperationsInput | string
    forGender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    type?: EnumVitalTypeFieldUpdateOperationsInput | $Enums.VitalType
    PrescriptionVitals?: PrescriptionVitalsUpdateManyWithoutVitalNestedInput
  }

  export type VitalsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    placeholder?: StringFieldUpdateOperationsInput | string
    forGender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    type?: EnumVitalTypeFieldUpdateOperationsInput | $Enums.VitalType
    PrescriptionVitals?: PrescriptionVitalsUncheckedUpdateManyWithoutVitalNestedInput
  }

  export type VitalsCreateManyInput = {
    id?: number
    name: string
    icon: string
    color: string
    placeholder: string
    forGender?: $Enums.Gender | null
    type: $Enums.VitalType
  }

  export type VitalsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    placeholder?: StringFieldUpdateOperationsInput | string
    forGender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    type?: EnumVitalTypeFieldUpdateOperationsInput | $Enums.VitalType
  }

  export type VitalsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    placeholder?: StringFieldUpdateOperationsInput | string
    forGender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    type?: EnumVitalTypeFieldUpdateOperationsInput | $Enums.VitalType
  }

  export type PrescriptionVitalsCreateInput = {
    value: string
    prescription: PrescriptionCreateNestedOneWithoutPrescriptionVitalsInput
    vital: VitalsCreateNestedOneWithoutPrescriptionVitalsInput
  }

  export type PrescriptionVitalsUncheckedCreateInput = {
    id?: number
    prescriptionId: number
    vitalId: number
    value: string
  }

  export type PrescriptionVitalsUpdateInput = {
    value?: StringFieldUpdateOperationsInput | string
    prescription?: PrescriptionUpdateOneRequiredWithoutPrescriptionVitalsNestedInput
    vital?: VitalsUpdateOneRequiredWithoutPrescriptionVitalsNestedInput
  }

  export type PrescriptionVitalsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    prescriptionId?: IntFieldUpdateOperationsInput | number
    vitalId?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
  }

  export type PrescriptionVitalsCreateManyInput = {
    id?: number
    prescriptionId: number
    vitalId: number
    value: string
  }

  export type PrescriptionVitalsUpdateManyMutationInput = {
    value?: StringFieldUpdateOperationsInput | string
  }

  export type PrescriptionVitalsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    prescriptionId?: IntFieldUpdateOperationsInput | number
    vitalId?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
  }

  export type MedicalCertificateCreateInput = {
    nameOfThePatient: string
    addressOfThePatient: string
    fitForDuty: $Enums.MedicalCertificateStatus
    dateOfSickness: Date | string
    recommendedLeaveDays: number
    natureOfTheDisease: string
    ageOfThePatient: number
    reccomendations: string
    time: Date | string
    patient: PatientCreateNestedOneWithoutMedicalCertInput
  }

  export type MedicalCertificateUncheckedCreateInput = {
    id?: number
    patientId: number
    nameOfThePatient: string
    addressOfThePatient: string
    fitForDuty: $Enums.MedicalCertificateStatus
    dateOfSickness: Date | string
    recommendedLeaveDays: number
    natureOfTheDisease: string
    ageOfThePatient: number
    reccomendations: string
    time: Date | string
  }

  export type MedicalCertificateUpdateInput = {
    nameOfThePatient?: StringFieldUpdateOperationsInput | string
    addressOfThePatient?: StringFieldUpdateOperationsInput | string
    fitForDuty?: EnumMedicalCertificateStatusFieldUpdateOperationsInput | $Enums.MedicalCertificateStatus
    dateOfSickness?: DateTimeFieldUpdateOperationsInput | Date | string
    recommendedLeaveDays?: IntFieldUpdateOperationsInput | number
    natureOfTheDisease?: StringFieldUpdateOperationsInput | string
    ageOfThePatient?: IntFieldUpdateOperationsInput | number
    reccomendations?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutMedicalCertNestedInput
  }

  export type MedicalCertificateUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    nameOfThePatient?: StringFieldUpdateOperationsInput | string
    addressOfThePatient?: StringFieldUpdateOperationsInput | string
    fitForDuty?: EnumMedicalCertificateStatusFieldUpdateOperationsInput | $Enums.MedicalCertificateStatus
    dateOfSickness?: DateTimeFieldUpdateOperationsInput | Date | string
    recommendedLeaveDays?: IntFieldUpdateOperationsInput | number
    natureOfTheDisease?: StringFieldUpdateOperationsInput | string
    ageOfThePatient?: IntFieldUpdateOperationsInput | number
    reccomendations?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalCertificateCreateManyInput = {
    id?: number
    patientId: number
    nameOfThePatient: string
    addressOfThePatient: string
    fitForDuty: $Enums.MedicalCertificateStatus
    dateOfSickness: Date | string
    recommendedLeaveDays: number
    natureOfTheDisease: string
    ageOfThePatient: number
    reccomendations: string
    time: Date | string
  }

  export type MedicalCertificateUpdateManyMutationInput = {
    nameOfThePatient?: StringFieldUpdateOperationsInput | string
    addressOfThePatient?: StringFieldUpdateOperationsInput | string
    fitForDuty?: EnumMedicalCertificateStatusFieldUpdateOperationsInput | $Enums.MedicalCertificateStatus
    dateOfSickness?: DateTimeFieldUpdateOperationsInput | Date | string
    recommendedLeaveDays?: IntFieldUpdateOperationsInput | number
    natureOfTheDisease?: StringFieldUpdateOperationsInput | string
    ageOfThePatient?: IntFieldUpdateOperationsInput | number
    reccomendations?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalCertificateUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    nameOfThePatient?: StringFieldUpdateOperationsInput | string
    addressOfThePatient?: StringFieldUpdateOperationsInput | string
    fitForDuty?: EnumMedicalCertificateStatusFieldUpdateOperationsInput | $Enums.MedicalCertificateStatus
    dateOfSickness?: DateTimeFieldUpdateOperationsInput | Date | string
    recommendedLeaveDays?: IntFieldUpdateOperationsInput | number
    natureOfTheDisease?: StringFieldUpdateOperationsInput | string
    ageOfThePatient?: IntFieldUpdateOperationsInput | number
    reccomendations?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type USSReferralCreateInput = {
    nameOfThePatient: string
    presentingComplaint: string
    duration: string
    onExamination: string
    pshx_pmhx: string
    ageOfThePatient: number
    reportDate: Date | string
    USS_type: string
    radiologist: string
    radiologist_title: string
    time?: Date | string
    patient: PatientCreateNestedOneWithoutUSSReferralInput
  }

  export type USSReferralUncheckedCreateInput = {
    id?: number
    patientId: number
    nameOfThePatient: string
    presentingComplaint: string
    duration: string
    onExamination: string
    pshx_pmhx: string
    ageOfThePatient: number
    reportDate: Date | string
    USS_type: string
    radiologist: string
    radiologist_title: string
    time?: Date | string
  }

  export type USSReferralUpdateInput = {
    nameOfThePatient?: StringFieldUpdateOperationsInput | string
    presentingComplaint?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    onExamination?: StringFieldUpdateOperationsInput | string
    pshx_pmhx?: StringFieldUpdateOperationsInput | string
    ageOfThePatient?: IntFieldUpdateOperationsInput | number
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    USS_type?: StringFieldUpdateOperationsInput | string
    radiologist?: StringFieldUpdateOperationsInput | string
    radiologist_title?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutUSSReferralNestedInput
  }

  export type USSReferralUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    nameOfThePatient?: StringFieldUpdateOperationsInput | string
    presentingComplaint?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    onExamination?: StringFieldUpdateOperationsInput | string
    pshx_pmhx?: StringFieldUpdateOperationsInput | string
    ageOfThePatient?: IntFieldUpdateOperationsInput | number
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    USS_type?: StringFieldUpdateOperationsInput | string
    radiologist?: StringFieldUpdateOperationsInput | string
    radiologist_title?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type USSReferralCreateManyInput = {
    id?: number
    patientId: number
    nameOfThePatient: string
    presentingComplaint: string
    duration: string
    onExamination: string
    pshx_pmhx: string
    ageOfThePatient: number
    reportDate: Date | string
    USS_type: string
    radiologist: string
    radiologist_title: string
    time?: Date | string
  }

  export type USSReferralUpdateManyMutationInput = {
    nameOfThePatient?: StringFieldUpdateOperationsInput | string
    presentingComplaint?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    onExamination?: StringFieldUpdateOperationsInput | string
    pshx_pmhx?: StringFieldUpdateOperationsInput | string
    ageOfThePatient?: IntFieldUpdateOperationsInput | number
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    USS_type?: StringFieldUpdateOperationsInput | string
    radiologist?: StringFieldUpdateOperationsInput | string
    radiologist_title?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type USSReferralUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    nameOfThePatient?: StringFieldUpdateOperationsInput | string
    presentingComplaint?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    onExamination?: StringFieldUpdateOperationsInput | string
    pshx_pmhx?: StringFieldUpdateOperationsInput | string
    ageOfThePatient?: IntFieldUpdateOperationsInput | number
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    USS_type?: StringFieldUpdateOperationsInput | string
    radiologist?: StringFieldUpdateOperationsInput | string
    radiologist_title?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralLetterCreateInput = {
    nameOfThePatient: string
    consultant_speciality: string
    consultant_name: string
    condition1: string
    condition2: string
    condition3: string
    investigations: string
    ageOfThePatient: number
    reportDate: Date | string
    time?: Date | string
    patient: PatientCreateNestedOneWithoutReferralLettersInput
  }

  export type ReferralLetterUncheckedCreateInput = {
    id?: number
    patientId: number
    nameOfThePatient: string
    consultant_speciality: string
    consultant_name: string
    condition1: string
    condition2: string
    condition3: string
    investigations: string
    ageOfThePatient: number
    reportDate: Date | string
    time?: Date | string
  }

  export type ReferralLetterUpdateInput = {
    nameOfThePatient?: StringFieldUpdateOperationsInput | string
    consultant_speciality?: StringFieldUpdateOperationsInput | string
    consultant_name?: StringFieldUpdateOperationsInput | string
    condition1?: StringFieldUpdateOperationsInput | string
    condition2?: StringFieldUpdateOperationsInput | string
    condition3?: StringFieldUpdateOperationsInput | string
    investigations?: StringFieldUpdateOperationsInput | string
    ageOfThePatient?: IntFieldUpdateOperationsInput | number
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutReferralLettersNestedInput
  }

  export type ReferralLetterUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    nameOfThePatient?: StringFieldUpdateOperationsInput | string
    consultant_speciality?: StringFieldUpdateOperationsInput | string
    consultant_name?: StringFieldUpdateOperationsInput | string
    condition1?: StringFieldUpdateOperationsInput | string
    condition2?: StringFieldUpdateOperationsInput | string
    condition3?: StringFieldUpdateOperationsInput | string
    investigations?: StringFieldUpdateOperationsInput | string
    ageOfThePatient?: IntFieldUpdateOperationsInput | number
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralLetterCreateManyInput = {
    id?: number
    patientId: number
    nameOfThePatient: string
    consultant_speciality: string
    consultant_name: string
    condition1: string
    condition2: string
    condition3: string
    investigations: string
    ageOfThePatient: number
    reportDate: Date | string
    time?: Date | string
  }

  export type ReferralLetterUpdateManyMutationInput = {
    nameOfThePatient?: StringFieldUpdateOperationsInput | string
    consultant_speciality?: StringFieldUpdateOperationsInput | string
    consultant_name?: StringFieldUpdateOperationsInput | string
    condition1?: StringFieldUpdateOperationsInput | string
    condition2?: StringFieldUpdateOperationsInput | string
    condition3?: StringFieldUpdateOperationsInput | string
    investigations?: StringFieldUpdateOperationsInput | string
    ageOfThePatient?: IntFieldUpdateOperationsInput | number
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralLetterUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    nameOfThePatient?: StringFieldUpdateOperationsInput | string
    consultant_speciality?: StringFieldUpdateOperationsInput | string
    consultant_name?: StringFieldUpdateOperationsInput | string
    condition1?: StringFieldUpdateOperationsInput | string
    condition2?: StringFieldUpdateOperationsInput | string
    condition3?: StringFieldUpdateOperationsInput | string
    investigations?: StringFieldUpdateOperationsInput | string
    ageOfThePatient?: IntFieldUpdateOperationsInput | number
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OffRecordMedsCreateInput = {
    name: string
    description?: string | null
    prescription: PrescriptionCreateNestedOneWithoutOffRecordMedsInput
  }

  export type OffRecordMedsUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    prescriptionId: number
  }

  export type OffRecordMedsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    prescription?: PrescriptionUpdateOneRequiredWithoutOffRecordMedsNestedInput
  }

  export type OffRecordMedsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    prescriptionId?: IntFieldUpdateOperationsInput | number
  }

  export type OffRecordMedsCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    prescriptionId: number
  }

  export type OffRecordMedsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OffRecordMedsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    prescriptionId?: IntFieldUpdateOperationsInput | number
  }

  export type IssueCreateInput = {
    strategy: $Enums.IssuingStrategy
    quantity: number
    dose: number
    details?: string | null
    meal?: $Enums.MEAL | null
    type: $Enums.DrugType
    batch?: BatchCreateNestedOneWithoutIssueInput
    brand: DrugBrandCreateNestedOneWithoutIssueInput
    drug: DrugCreateNestedOneWithoutIssueInput
    prescription: PrescriptionCreateNestedOneWithoutIssuesInput
    unitConcentration: UnitConcentrationCreateNestedOneWithoutIssueInput
    stratergyHistory?: StratergyHistoryCreateNestedManyWithoutIssueInput
  }

  export type IssueUncheckedCreateInput = {
    id?: number
    prescriptionId: number
    batchId?: number | null
    drugId: number
    brandId: number
    strategy: $Enums.IssuingStrategy
    quantity: number
    dose: number
    details?: string | null
    meal?: $Enums.MEAL | null
    type: $Enums.DrugType
    unitConcentrationId: number
    stratergyHistory?: StratergyHistoryUncheckedCreateNestedManyWithoutIssueInput
  }

  export type IssueUpdateInput = {
    strategy?: EnumIssuingStrategyFieldUpdateOperationsInput | $Enums.IssuingStrategy
    quantity?: FloatFieldUpdateOperationsInput | number
    dose?: FloatFieldUpdateOperationsInput | number
    details?: NullableStringFieldUpdateOperationsInput | string | null
    meal?: NullableEnumMEALFieldUpdateOperationsInput | $Enums.MEAL | null
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    batch?: BatchUpdateOneWithoutIssueNestedInput
    brand?: DrugBrandUpdateOneRequiredWithoutIssueNestedInput
    drug?: DrugUpdateOneRequiredWithoutIssueNestedInput
    prescription?: PrescriptionUpdateOneRequiredWithoutIssuesNestedInput
    unitConcentration?: UnitConcentrationUpdateOneRequiredWithoutIssueNestedInput
    stratergyHistory?: StratergyHistoryUpdateManyWithoutIssueNestedInput
  }

  export type IssueUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    prescriptionId?: IntFieldUpdateOperationsInput | number
    batchId?: NullableIntFieldUpdateOperationsInput | number | null
    drugId?: IntFieldUpdateOperationsInput | number
    brandId?: IntFieldUpdateOperationsInput | number
    strategy?: EnumIssuingStrategyFieldUpdateOperationsInput | $Enums.IssuingStrategy
    quantity?: FloatFieldUpdateOperationsInput | number
    dose?: FloatFieldUpdateOperationsInput | number
    details?: NullableStringFieldUpdateOperationsInput | string | null
    meal?: NullableEnumMEALFieldUpdateOperationsInput | $Enums.MEAL | null
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    unitConcentrationId?: IntFieldUpdateOperationsInput | number
    stratergyHistory?: StratergyHistoryUncheckedUpdateManyWithoutIssueNestedInput
  }

  export type IssueCreateManyInput = {
    id?: number
    prescriptionId: number
    batchId?: number | null
    drugId: number
    brandId: number
    strategy: $Enums.IssuingStrategy
    quantity: number
    dose: number
    details?: string | null
    meal?: $Enums.MEAL | null
    type: $Enums.DrugType
    unitConcentrationId: number
  }

  export type IssueUpdateManyMutationInput = {
    strategy?: EnumIssuingStrategyFieldUpdateOperationsInput | $Enums.IssuingStrategy
    quantity?: FloatFieldUpdateOperationsInput | number
    dose?: FloatFieldUpdateOperationsInput | number
    details?: NullableStringFieldUpdateOperationsInput | string | null
    meal?: NullableEnumMEALFieldUpdateOperationsInput | $Enums.MEAL | null
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
  }

  export type IssueUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    prescriptionId?: IntFieldUpdateOperationsInput | number
    batchId?: NullableIntFieldUpdateOperationsInput | number | null
    drugId?: IntFieldUpdateOperationsInput | number
    brandId?: IntFieldUpdateOperationsInput | number
    strategy?: EnumIssuingStrategyFieldUpdateOperationsInput | $Enums.IssuingStrategy
    quantity?: FloatFieldUpdateOperationsInput | number
    dose?: FloatFieldUpdateOperationsInput | number
    details?: NullableStringFieldUpdateOperationsInput | string | null
    meal?: NullableEnumMEALFieldUpdateOperationsInput | $Enums.MEAL | null
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    unitConcentrationId?: IntFieldUpdateOperationsInput | number
  }

  export type ReportParameterCreateInput = {
    name: string
    units?: string | null
    ReportType?: ReportTypeCreateNestedOneWithoutParametersInput
    ReportValue?: ReportValueCreateNestedManyWithoutReportParameterInput
  }

  export type ReportParameterUncheckedCreateInput = {
    id?: number
    name: string
    units?: string | null
    reportTypeId?: number | null
    ReportValue?: ReportValueUncheckedCreateNestedManyWithoutReportParameterInput
  }

  export type ReportParameterUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    units?: NullableStringFieldUpdateOperationsInput | string | null
    ReportType?: ReportTypeUpdateOneWithoutParametersNestedInput
    ReportValue?: ReportValueUpdateManyWithoutReportParameterNestedInput
  }

  export type ReportParameterUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    units?: NullableStringFieldUpdateOperationsInput | string | null
    reportTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    ReportValue?: ReportValueUncheckedUpdateManyWithoutReportParameterNestedInput
  }

  export type ReportParameterCreateManyInput = {
    id?: number
    name: string
    units?: string | null
    reportTypeId?: number | null
  }

  export type ReportParameterUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    units?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReportParameterUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    units?: NullableStringFieldUpdateOperationsInput | string | null
    reportTypeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ReportTypeCreateInput = {
    name: string
    description?: string | null
    PatientReport?: PatientReportCreateNestedManyWithoutReportTypeInput
    parameters?: ReportParameterCreateNestedManyWithoutReportTypeInput
  }

  export type ReportTypeUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    PatientReport?: PatientReportUncheckedCreateNestedManyWithoutReportTypeInput
    parameters?: ReportParameterUncheckedCreateNestedManyWithoutReportTypeInput
  }

  export type ReportTypeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    PatientReport?: PatientReportUpdateManyWithoutReportTypeNestedInput
    parameters?: ReportParameterUpdateManyWithoutReportTypeNestedInput
  }

  export type ReportTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    PatientReport?: PatientReportUncheckedUpdateManyWithoutReportTypeNestedInput
    parameters?: ReportParameterUncheckedUpdateManyWithoutReportTypeNestedInput
  }

  export type ReportTypeCreateManyInput = {
    id?: number
    name: string
    description?: string | null
  }

  export type ReportTypeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReportTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PatientReportCreateInput = {
    time?: Date | string
    patient: PatientCreateNestedOneWithoutReportsInput
    reportType: ReportTypeCreateNestedOneWithoutPatientReportInput
    parameters?: ReportValueCreateNestedManyWithoutPatientReportInput
  }

  export type PatientReportUncheckedCreateInput = {
    id?: number
    patientId: number
    reportTypeId: number
    time?: Date | string
    parameters?: ReportValueUncheckedCreateNestedManyWithoutPatientReportInput
  }

  export type PatientReportUpdateInput = {
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutReportsNestedInput
    reportType?: ReportTypeUpdateOneRequiredWithoutPatientReportNestedInput
    parameters?: ReportValueUpdateManyWithoutPatientReportNestedInput
  }

  export type PatientReportUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    reportTypeId?: IntFieldUpdateOperationsInput | number
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    parameters?: ReportValueUncheckedUpdateManyWithoutPatientReportNestedInput
  }

  export type PatientReportCreateManyInput = {
    id?: number
    patientId: number
    reportTypeId: number
    time?: Date | string
  }

  export type PatientReportUpdateManyMutationInput = {
    time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientReportUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    reportTypeId?: IntFieldUpdateOperationsInput | number
    time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportValueCreateInput = {
    attention?: boolean
    value: string
    PatientReport?: PatientReportCreateNestedOneWithoutParametersInput
    reportParameter: ReportParameterCreateNestedOneWithoutReportValueInput
  }

  export type ReportValueUncheckedCreateInput = {
    id?: number
    reportParameterId: number
    attention?: boolean
    value: string
    patientReportId?: number | null
  }

  export type ReportValueUpdateInput = {
    attention?: BoolFieldUpdateOperationsInput | boolean
    value?: StringFieldUpdateOperationsInput | string
    PatientReport?: PatientReportUpdateOneWithoutParametersNestedInput
    reportParameter?: ReportParameterUpdateOneRequiredWithoutReportValueNestedInput
  }

  export type ReportValueUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    reportParameterId?: IntFieldUpdateOperationsInput | number
    attention?: BoolFieldUpdateOperationsInput | boolean
    value?: StringFieldUpdateOperationsInput | string
    patientReportId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ReportValueCreateManyInput = {
    id?: number
    reportParameterId: number
    attention?: boolean
    value: string
    patientReportId?: number | null
  }

  export type ReportValueUpdateManyMutationInput = {
    attention?: BoolFieldUpdateOperationsInput | boolean
    value?: StringFieldUpdateOperationsInput | string
  }

  export type ReportValueUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    reportParameterId?: IntFieldUpdateOperationsInput | number
    attention?: BoolFieldUpdateOperationsInput | boolean
    value?: StringFieldUpdateOperationsInput | string
    patientReportId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StratergyHistoryCreateInput = {
    drug: DrugCreateNestedOneWithoutStratergyHistoryInput
    issue: IssueCreateNestedOneWithoutStratergyHistoryInput
  }

  export type StratergyHistoryUncheckedCreateInput = {
    id?: number
    drugId: number
    issueId: number
  }

  export type StratergyHistoryUpdateInput = {
    drug?: DrugUpdateOneRequiredWithoutStratergyHistoryNestedInput
    issue?: IssueUpdateOneRequiredWithoutStratergyHistoryNestedInput
  }

  export type StratergyHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    drugId?: IntFieldUpdateOperationsInput | number
    issueId?: IntFieldUpdateOperationsInput | number
  }

  export type StratergyHistoryCreateManyInput = {
    id?: number
    drugId: number
    issueId: number
  }

  export type StratergyHistoryUpdateManyMutationInput = {

  }

  export type StratergyHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    drugId?: IntFieldUpdateOperationsInput | number
    issueId?: IntFieldUpdateOperationsInput | number
  }

  export type BatchHistoryCreateInput = {
    type: $Enums.DrugType
    batch: BatchCreateNestedOneWithoutBatchHistoryInput
    brand: DrugBrandCreateNestedOneWithoutBatchHistoryInput
    drug: DrugCreateNestedOneWithoutBatchHistoryInput
    unitConcentration: UnitConcentrationCreateNestedOneWithoutBatchHistoryInput
  }

  export type BatchHistoryUncheckedCreateInput = {
    id?: number
    drugId: number
    type: $Enums.DrugType
    unitConcentrationId: number
    drugBrandId: number
    batchId: number
  }

  export type BatchHistoryUpdateInput = {
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    batch?: BatchUpdateOneRequiredWithoutBatchHistoryNestedInput
    brand?: DrugBrandUpdateOneRequiredWithoutBatchHistoryNestedInput
    drug?: DrugUpdateOneRequiredWithoutBatchHistoryNestedInput
    unitConcentration?: UnitConcentrationUpdateOneRequiredWithoutBatchHistoryNestedInput
  }

  export type BatchHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    drugId?: IntFieldUpdateOperationsInput | number
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    unitConcentrationId?: IntFieldUpdateOperationsInput | number
    drugBrandId?: IntFieldUpdateOperationsInput | number
    batchId?: IntFieldUpdateOperationsInput | number
  }

  export type BatchHistoryCreateManyInput = {
    id?: number
    drugId: number
    type: $Enums.DrugType
    unitConcentrationId: number
    drugBrandId: number
    batchId: number
  }

  export type BatchHistoryUpdateManyMutationInput = {
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
  }

  export type BatchHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    drugId?: IntFieldUpdateOperationsInput | number
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    unitConcentrationId?: IntFieldUpdateOperationsInput | number
    drugBrandId?: IntFieldUpdateOperationsInput | number
    batchId?: IntFieldUpdateOperationsInput | number
  }

  export type ChargeCreateInput = {
    name: string
    type: $Enums.ChargeType
    value: number
    updatedAt?: Date | string
  }

  export type ChargeUncheckedCreateInput = {
    id?: number
    name: string
    type: $Enums.ChargeType
    value: number
    updatedAt?: Date | string
  }

  export type ChargeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumChargeTypeFieldUpdateOperationsInput | $Enums.ChargeType
    value?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChargeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumChargeTypeFieldUpdateOperationsInput | $Enums.ChargeType
    value?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChargeCreateManyInput = {
    id?: number
    name: string
    type: $Enums.ChargeType
    value: number
    updatedAt?: Date | string
  }

  export type ChargeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumChargeTypeFieldUpdateOperationsInput | $Enums.ChargeType
    value?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChargeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumChargeTypeFieldUpdateOperationsInput | $Enums.ChargeType
    value?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type MedicalCertificateListRelationFilter = {
    every?: MedicalCertificateWhereInput
    some?: MedicalCertificateWhereInput
    none?: MedicalCertificateWhereInput
  }

  export type PatientHistoryListRelationFilter = {
    every?: PatientHistoryWhereInput
    some?: PatientHistoryWhereInput
    none?: PatientHistoryWhereInput
  }

  export type PatientReportListRelationFilter = {
    every?: PatientReportWhereInput
    some?: PatientReportWhereInput
    none?: PatientReportWhereInput
  }

  export type PrescriptionListRelationFilter = {
    every?: PrescriptionWhereInput
    some?: PrescriptionWhereInput
    none?: PrescriptionWhereInput
  }

  export type QueueEntryListRelationFilter = {
    every?: QueueEntryWhereInput
    some?: QueueEntryWhereInput
    none?: QueueEntryWhereInput
  }

  export type USSReferralListRelationFilter = {
    every?: USSReferralWhereInput
    some?: USSReferralWhereInput
    none?: USSReferralWhereInput
  }

  export type ReferralLetterListRelationFilter = {
    every?: ReferralLetterWhereInput
    some?: ReferralLetterWhereInput
    none?: ReferralLetterWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type MedicalCertificateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PatientHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PatientReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PrescriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QueueEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type USSReferralOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReferralLetterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PatientCountOrderByAggregateInput = {
    id?: SortOrder
    telephone?: SortOrder
    name?: SortOrder
    birthDate?: SortOrder
    address?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    gender?: SortOrder
    NIC?: SortOrder
  }

  export type PatientAvgOrderByAggregateInput = {
    id?: SortOrder
    height?: SortOrder
    weight?: SortOrder
  }

  export type PatientMaxOrderByAggregateInput = {
    id?: SortOrder
    telephone?: SortOrder
    name?: SortOrder
    birthDate?: SortOrder
    address?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    gender?: SortOrder
    NIC?: SortOrder
  }

  export type PatientMinOrderByAggregateInput = {
    id?: SortOrder
    telephone?: SortOrder
    name?: SortOrder
    birthDate?: SortOrder
    address?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    gender?: SortOrder
    NIC?: SortOrder
  }

  export type PatientSumOrderByAggregateInput = {
    id?: SortOrder
    height?: SortOrder
    weight?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type EnumPatientHistoryTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PatientHistoryType | EnumPatientHistoryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PatientHistoryType[] | ListEnumPatientHistoryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PatientHistoryType[] | ListEnumPatientHistoryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPatientHistoryTypeFilter<$PrismaModel> | $Enums.PatientHistoryType
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type PatientScalarRelationFilter = {
    is?: PatientWhereInput
    isNot?: PatientWhereInput
  }

  export type PatientHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    description?: SortOrder
    type?: SortOrder
    time?: SortOrder
    name?: SortOrder
  }

  export type PatientHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
  }

  export type PatientHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    description?: SortOrder
    type?: SortOrder
    time?: SortOrder
    name?: SortOrder
  }

  export type PatientHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    description?: SortOrder
    type?: SortOrder
    time?: SortOrder
    name?: SortOrder
  }

  export type PatientHistorySumOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
  }

  export type EnumPatientHistoryTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PatientHistoryType | EnumPatientHistoryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PatientHistoryType[] | ListEnumPatientHistoryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PatientHistoryType[] | ListEnumPatientHistoryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPatientHistoryTypeWithAggregatesFilter<$PrismaModel> | $Enums.PatientHistoryType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPatientHistoryTypeFilter<$PrismaModel>
    _max?: NestedEnumPatientHistoryTypeFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    gender?: SortOrder
    image?: SortOrder
    mobile?: SortOrder
    password?: SortOrder
    role?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    gender?: SortOrder
    image?: SortOrder
    mobile?: SortOrder
    password?: SortOrder
    role?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    gender?: SortOrder
    image?: SortOrder
    mobile?: SortOrder
    password?: SortOrder
    role?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type EnumQueueStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QueueStatus | EnumQueueStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QueueStatus[] | ListEnumQueueStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QueueStatus[] | ListEnumQueueStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQueueStatusFilter<$PrismaModel> | $Enums.QueueStatus
  }

  export type QueueCountOrderByAggregateInput = {
    id?: SortOrder
    start?: SortOrder
    end?: SortOrder
    status?: SortOrder
  }

  export type QueueAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type QueueMaxOrderByAggregateInput = {
    id?: SortOrder
    start?: SortOrder
    end?: SortOrder
    status?: SortOrder
  }

  export type QueueMinOrderByAggregateInput = {
    id?: SortOrder
    start?: SortOrder
    end?: SortOrder
    status?: SortOrder
  }

  export type QueueSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumQueueStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QueueStatus | EnumQueueStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QueueStatus[] | ListEnumQueueStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QueueStatus[] | ListEnumQueueStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQueueStatusWithAggregatesFilter<$PrismaModel> | $Enums.QueueStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQueueStatusFilter<$PrismaModel>
    _max?: NestedEnumQueueStatusFilter<$PrismaModel>
  }

  export type EnumVisitStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitStatus | EnumVisitStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VisitStatus[] | ListEnumVisitStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VisitStatus[] | ListEnumVisitStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVisitStatusFilter<$PrismaModel> | $Enums.VisitStatus
  }

  export type QueueScalarRelationFilter = {
    is?: QueueWhereInput
    isNot?: QueueWhereInput
  }

  export type QueueEntryQueueIdTokenCompoundUniqueInput = {
    queueId: number
    token: number
  }

  export type QueueEntryCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    status?: SortOrder
    queueId?: SortOrder
    patientId?: SortOrder
    time?: SortOrder
  }

  export type QueueEntryAvgOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    queueId?: SortOrder
    patientId?: SortOrder
  }

  export type QueueEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    status?: SortOrder
    queueId?: SortOrder
    patientId?: SortOrder
    time?: SortOrder
  }

  export type QueueEntryMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    status?: SortOrder
    queueId?: SortOrder
    patientId?: SortOrder
    time?: SortOrder
  }

  export type QueueEntrySumOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    queueId?: SortOrder
    patientId?: SortOrder
  }

  export type EnumVisitStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitStatus | EnumVisitStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VisitStatus[] | ListEnumVisitStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VisitStatus[] | ListEnumVisitStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVisitStatusWithAggregatesFilter<$PrismaModel> | $Enums.VisitStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVisitStatusFilter<$PrismaModel>
    _max?: NestedEnumVisitStatusFilter<$PrismaModel>
  }

  export type BatchListRelationFilter = {
    every?: BatchWhereInput
    some?: BatchWhereInput
    none?: BatchWhereInput
  }

  export type BatchHistoryListRelationFilter = {
    every?: BatchHistoryWhereInput
    some?: BatchHistoryWhereInput
    none?: BatchHistoryWhereInput
  }

  export type IssueListRelationFilter = {
    every?: IssueWhereInput
    some?: IssueWhereInput
    none?: IssueWhereInput
  }

  export type BatchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BatchHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IssueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DrugBrandCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type DrugBrandAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DrugBrandMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type DrugBrandMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type DrugBrandSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StratergyHistoryNullableScalarRelationFilter = {
    is?: StratergyHistoryWhereInput | null
    isNot?: StratergyHistoryWhereInput | null
  }

  export type BufferLevelListRelationFilter = {
    every?: BufferLevelWhereInput
    some?: BufferLevelWhereInput
    none?: BufferLevelWhereInput
  }

  export type BufferLevelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DrugCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type DrugAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DrugMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type DrugMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type DrugSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumDrugTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DrugType | EnumDrugTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DrugType[] | ListEnumDrugTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DrugType[] | ListEnumDrugTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDrugTypeFilter<$PrismaModel> | $Enums.DrugType
  }

  export type DrugScalarRelationFilter = {
    is?: DrugWhereInput
    isNot?: DrugWhereInput
  }

  export type UnitConcentrationScalarRelationFilter = {
    is?: UnitConcentrationWhereInput
    isNot?: UnitConcentrationWhereInput
  }

  export type BufferLevelDrugIdTypeUnitConcentrationIdCompoundUniqueInput = {
    drugId: number
    type: $Enums.DrugType
    unitConcentrationId: number
  }

  export type BufferLevelCountOrderByAggregateInput = {
    id?: SortOrder
    drugId?: SortOrder
    type?: SortOrder
    unitConcentrationId?: SortOrder
    bufferAmount?: SortOrder
  }

  export type BufferLevelAvgOrderByAggregateInput = {
    id?: SortOrder
    drugId?: SortOrder
    unitConcentrationId?: SortOrder
    bufferAmount?: SortOrder
  }

  export type BufferLevelMaxOrderByAggregateInput = {
    id?: SortOrder
    drugId?: SortOrder
    type?: SortOrder
    unitConcentrationId?: SortOrder
    bufferAmount?: SortOrder
  }

  export type BufferLevelMinOrderByAggregateInput = {
    id?: SortOrder
    drugId?: SortOrder
    type?: SortOrder
    unitConcentrationId?: SortOrder
    bufferAmount?: SortOrder
  }

  export type BufferLevelSumOrderByAggregateInput = {
    id?: SortOrder
    drugId?: SortOrder
    unitConcentrationId?: SortOrder
    bufferAmount?: SortOrder
  }

  export type EnumDrugTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DrugType | EnumDrugTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DrugType[] | ListEnumDrugTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DrugType[] | ListEnumDrugTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDrugTypeWithAggregatesFilter<$PrismaModel> | $Enums.DrugType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDrugTypeFilter<$PrismaModel>
    _max?: NestedEnumDrugTypeFilter<$PrismaModel>
  }

  export type SupplierCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contact?: SortOrder
  }

  export type SupplierAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SupplierMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contact?: SortOrder
  }

  export type SupplierMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contact?: SortOrder
  }

  export type SupplierSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumBatchStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BatchStatus | EnumBatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BatchStatus[] | ListEnumBatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BatchStatus[] | ListEnumBatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBatchStatusFilter<$PrismaModel> | $Enums.BatchStatus
  }

  export type DrugBrandScalarRelationFilter = {
    is?: DrugBrandWhereInput
    isNot?: DrugBrandWhereInput
  }

  export type SupplierScalarRelationFilter = {
    is?: SupplierWhereInput
    isNot?: SupplierWhereInput
  }

  export type BatchCountOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    drugId?: SortOrder
    drugBrandId?: SortOrder
    type?: SortOrder
    fullAmount?: SortOrder
    expiry?: SortOrder
    stockDate?: SortOrder
    remainingQuantity?: SortOrder
    wholesalePrice?: SortOrder
    retailPrice?: SortOrder
    status?: SortOrder
    unitConcentrationId?: SortOrder
    supplierId?: SortOrder
  }

  export type BatchAvgOrderByAggregateInput = {
    id?: SortOrder
    drugId?: SortOrder
    drugBrandId?: SortOrder
    fullAmount?: SortOrder
    remainingQuantity?: SortOrder
    wholesalePrice?: SortOrder
    retailPrice?: SortOrder
    unitConcentrationId?: SortOrder
    supplierId?: SortOrder
  }

  export type BatchMaxOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    drugId?: SortOrder
    drugBrandId?: SortOrder
    type?: SortOrder
    fullAmount?: SortOrder
    expiry?: SortOrder
    stockDate?: SortOrder
    remainingQuantity?: SortOrder
    wholesalePrice?: SortOrder
    retailPrice?: SortOrder
    status?: SortOrder
    unitConcentrationId?: SortOrder
    supplierId?: SortOrder
  }

  export type BatchMinOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    drugId?: SortOrder
    drugBrandId?: SortOrder
    type?: SortOrder
    fullAmount?: SortOrder
    expiry?: SortOrder
    stockDate?: SortOrder
    remainingQuantity?: SortOrder
    wholesalePrice?: SortOrder
    retailPrice?: SortOrder
    status?: SortOrder
    unitConcentrationId?: SortOrder
    supplierId?: SortOrder
  }

  export type BatchSumOrderByAggregateInput = {
    id?: SortOrder
    drugId?: SortOrder
    drugBrandId?: SortOrder
    fullAmount?: SortOrder
    remainingQuantity?: SortOrder
    wholesalePrice?: SortOrder
    retailPrice?: SortOrder
    unitConcentrationId?: SortOrder
    supplierId?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumBatchStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BatchStatus | EnumBatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BatchStatus[] | ListEnumBatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BatchStatus[] | ListEnumBatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBatchStatusWithAggregatesFilter<$PrismaModel> | $Enums.BatchStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBatchStatusFilter<$PrismaModel>
    _max?: NestedEnumBatchStatusFilter<$PrismaModel>
  }

  export type UnitConcentrationCountOrderByAggregateInput = {
    id?: SortOrder
    concentration?: SortOrder
  }

  export type UnitConcentrationAvgOrderByAggregateInput = {
    id?: SortOrder
    concentration?: SortOrder
  }

  export type UnitConcentrationMaxOrderByAggregateInput = {
    id?: SortOrder
    concentration?: SortOrder
  }

  export type UnitConcentrationMinOrderByAggregateInput = {
    id?: SortOrder
    concentration?: SortOrder
  }

  export type UnitConcentrationSumOrderByAggregateInput = {
    id?: SortOrder
    concentration?: SortOrder
  }

  export type EnumPrescriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PrescriptionStatus | EnumPrescriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PrescriptionStatus[] | ListEnumPrescriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PrescriptionStatus[] | ListEnumPrescriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPrescriptionStatusFilter<$PrismaModel> | $Enums.PrescriptionStatus
  }

  export type OffRecordMedsListRelationFilter = {
    every?: OffRecordMedsWhereInput
    some?: OffRecordMedsWhereInput
    none?: OffRecordMedsWhereInput
  }

  export type PrescriptionVitalsListRelationFilter = {
    every?: PrescriptionVitalsWhereInput
    some?: PrescriptionVitalsWhereInput
    none?: PrescriptionVitalsWhereInput
  }

  export type PrescriptionChargesListRelationFilter = {
    every?: PrescriptionChargesWhereInput
    some?: PrescriptionChargesWhereInput
    none?: PrescriptionChargesWhereInput
  }

  export type OffRecordMedsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PrescriptionVitalsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PrescriptionChargesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PrescriptionCountOrderByAggregateInput = {
    id?: SortOrder
    time?: SortOrder
    presentingSymptoms?: SortOrder
    status?: SortOrder
    details?: SortOrder
    patientId?: SortOrder
    finalPrice?: SortOrder
  }

  export type PrescriptionAvgOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    finalPrice?: SortOrder
  }

  export type PrescriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    time?: SortOrder
    presentingSymptoms?: SortOrder
    status?: SortOrder
    details?: SortOrder
    patientId?: SortOrder
    finalPrice?: SortOrder
  }

  export type PrescriptionMinOrderByAggregateInput = {
    id?: SortOrder
    time?: SortOrder
    presentingSymptoms?: SortOrder
    status?: SortOrder
    details?: SortOrder
    patientId?: SortOrder
    finalPrice?: SortOrder
  }

  export type PrescriptionSumOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    finalPrice?: SortOrder
  }

  export type EnumPrescriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PrescriptionStatus | EnumPrescriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PrescriptionStatus[] | ListEnumPrescriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PrescriptionStatus[] | ListEnumPrescriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPrescriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.PrescriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPrescriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumPrescriptionStatusFilter<$PrismaModel>
  }

  export type EnumChargeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ChargeType | EnumChargeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChargeType[] | ListEnumChargeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChargeType[] | ListEnumChargeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChargeTypeFilter<$PrismaModel> | $Enums.ChargeType
  }

  export type PrescriptionScalarRelationFilter = {
    is?: PrescriptionWhereInput
    isNot?: PrescriptionWhereInput
  }

  export type PrescriptionChargesCountOrderByAggregateInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    value?: SortOrder
    description?: SortOrder
  }

  export type PrescriptionChargesAvgOrderByAggregateInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    value?: SortOrder
  }

  export type PrescriptionChargesMaxOrderByAggregateInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    value?: SortOrder
    description?: SortOrder
  }

  export type PrescriptionChargesMinOrderByAggregateInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    value?: SortOrder
    description?: SortOrder
  }

  export type PrescriptionChargesSumOrderByAggregateInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    value?: SortOrder
  }

  export type EnumChargeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChargeType | EnumChargeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChargeType[] | ListEnumChargeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChargeType[] | ListEnumChargeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChargeTypeWithAggregatesFilter<$PrismaModel> | $Enums.ChargeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChargeTypeFilter<$PrismaModel>
    _max?: NestedEnumChargeTypeFilter<$PrismaModel>
  }

  export type EnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type EnumVitalTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.VitalType | EnumVitalTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VitalType[] | ListEnumVitalTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VitalType[] | ListEnumVitalTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVitalTypeFilter<$PrismaModel> | $Enums.VitalType
  }

  export type VitalsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    placeholder?: SortOrder
    forGender?: SortOrder
    type?: SortOrder
  }

  export type VitalsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type VitalsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    placeholder?: SortOrder
    forGender?: SortOrder
    type?: SortOrder
  }

  export type VitalsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    placeholder?: SortOrder
    forGender?: SortOrder
    type?: SortOrder
  }

  export type VitalsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type EnumVitalTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VitalType | EnumVitalTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VitalType[] | ListEnumVitalTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VitalType[] | ListEnumVitalTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVitalTypeWithAggregatesFilter<$PrismaModel> | $Enums.VitalType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVitalTypeFilter<$PrismaModel>
    _max?: NestedEnumVitalTypeFilter<$PrismaModel>
  }

  export type VitalsScalarRelationFilter = {
    is?: VitalsWhereInput
    isNot?: VitalsWhereInput
  }

  export type PrescriptionVitalsCountOrderByAggregateInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    vitalId?: SortOrder
    value?: SortOrder
  }

  export type PrescriptionVitalsAvgOrderByAggregateInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    vitalId?: SortOrder
  }

  export type PrescriptionVitalsMaxOrderByAggregateInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    vitalId?: SortOrder
    value?: SortOrder
  }

  export type PrescriptionVitalsMinOrderByAggregateInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    vitalId?: SortOrder
    value?: SortOrder
  }

  export type PrescriptionVitalsSumOrderByAggregateInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    vitalId?: SortOrder
  }

  export type EnumMedicalCertificateStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MedicalCertificateStatus | EnumMedicalCertificateStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MedicalCertificateStatus[] | ListEnumMedicalCertificateStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MedicalCertificateStatus[] | ListEnumMedicalCertificateStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMedicalCertificateStatusFilter<$PrismaModel> | $Enums.MedicalCertificateStatus
  }

  export type MedicalCertificateCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    nameOfThePatient?: SortOrder
    addressOfThePatient?: SortOrder
    fitForDuty?: SortOrder
    dateOfSickness?: SortOrder
    recommendedLeaveDays?: SortOrder
    natureOfTheDisease?: SortOrder
    ageOfThePatient?: SortOrder
    reccomendations?: SortOrder
    time?: SortOrder
  }

  export type MedicalCertificateAvgOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    recommendedLeaveDays?: SortOrder
    ageOfThePatient?: SortOrder
  }

  export type MedicalCertificateMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    nameOfThePatient?: SortOrder
    addressOfThePatient?: SortOrder
    fitForDuty?: SortOrder
    dateOfSickness?: SortOrder
    recommendedLeaveDays?: SortOrder
    natureOfTheDisease?: SortOrder
    ageOfThePatient?: SortOrder
    reccomendations?: SortOrder
    time?: SortOrder
  }

  export type MedicalCertificateMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    nameOfThePatient?: SortOrder
    addressOfThePatient?: SortOrder
    fitForDuty?: SortOrder
    dateOfSickness?: SortOrder
    recommendedLeaveDays?: SortOrder
    natureOfTheDisease?: SortOrder
    ageOfThePatient?: SortOrder
    reccomendations?: SortOrder
    time?: SortOrder
  }

  export type MedicalCertificateSumOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    recommendedLeaveDays?: SortOrder
    ageOfThePatient?: SortOrder
  }

  export type EnumMedicalCertificateStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MedicalCertificateStatus | EnumMedicalCertificateStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MedicalCertificateStatus[] | ListEnumMedicalCertificateStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MedicalCertificateStatus[] | ListEnumMedicalCertificateStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMedicalCertificateStatusWithAggregatesFilter<$PrismaModel> | $Enums.MedicalCertificateStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMedicalCertificateStatusFilter<$PrismaModel>
    _max?: NestedEnumMedicalCertificateStatusFilter<$PrismaModel>
  }

  export type USSReferralCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    nameOfThePatient?: SortOrder
    presentingComplaint?: SortOrder
    duration?: SortOrder
    onExamination?: SortOrder
    pshx_pmhx?: SortOrder
    ageOfThePatient?: SortOrder
    reportDate?: SortOrder
    USS_type?: SortOrder
    radiologist?: SortOrder
    radiologist_title?: SortOrder
    time?: SortOrder
  }

  export type USSReferralAvgOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    ageOfThePatient?: SortOrder
  }

  export type USSReferralMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    nameOfThePatient?: SortOrder
    presentingComplaint?: SortOrder
    duration?: SortOrder
    onExamination?: SortOrder
    pshx_pmhx?: SortOrder
    ageOfThePatient?: SortOrder
    reportDate?: SortOrder
    USS_type?: SortOrder
    radiologist?: SortOrder
    radiologist_title?: SortOrder
    time?: SortOrder
  }

  export type USSReferralMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    nameOfThePatient?: SortOrder
    presentingComplaint?: SortOrder
    duration?: SortOrder
    onExamination?: SortOrder
    pshx_pmhx?: SortOrder
    ageOfThePatient?: SortOrder
    reportDate?: SortOrder
    USS_type?: SortOrder
    radiologist?: SortOrder
    radiologist_title?: SortOrder
    time?: SortOrder
  }

  export type USSReferralSumOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    ageOfThePatient?: SortOrder
  }

  export type ReferralLetterCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    nameOfThePatient?: SortOrder
    consultant_speciality?: SortOrder
    consultant_name?: SortOrder
    condition1?: SortOrder
    condition2?: SortOrder
    condition3?: SortOrder
    investigations?: SortOrder
    ageOfThePatient?: SortOrder
    reportDate?: SortOrder
    time?: SortOrder
  }

  export type ReferralLetterAvgOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    ageOfThePatient?: SortOrder
  }

  export type ReferralLetterMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    nameOfThePatient?: SortOrder
    consultant_speciality?: SortOrder
    consultant_name?: SortOrder
    condition1?: SortOrder
    condition2?: SortOrder
    condition3?: SortOrder
    investigations?: SortOrder
    ageOfThePatient?: SortOrder
    reportDate?: SortOrder
    time?: SortOrder
  }

  export type ReferralLetterMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    nameOfThePatient?: SortOrder
    consultant_speciality?: SortOrder
    consultant_name?: SortOrder
    condition1?: SortOrder
    condition2?: SortOrder
    condition3?: SortOrder
    investigations?: SortOrder
    ageOfThePatient?: SortOrder
    reportDate?: SortOrder
    time?: SortOrder
  }

  export type ReferralLetterSumOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    ageOfThePatient?: SortOrder
  }

  export type OffRecordMedsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    prescriptionId?: SortOrder
  }

  export type OffRecordMedsAvgOrderByAggregateInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
  }

  export type OffRecordMedsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    prescriptionId?: SortOrder
  }

  export type OffRecordMedsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    prescriptionId?: SortOrder
  }

  export type OffRecordMedsSumOrderByAggregateInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumIssuingStrategyFilter<$PrismaModel = never> = {
    equals?: $Enums.IssuingStrategy | EnumIssuingStrategyFieldRefInput<$PrismaModel>
    in?: $Enums.IssuingStrategy[] | ListEnumIssuingStrategyFieldRefInput<$PrismaModel>
    notIn?: $Enums.IssuingStrategy[] | ListEnumIssuingStrategyFieldRefInput<$PrismaModel>
    not?: NestedEnumIssuingStrategyFilter<$PrismaModel> | $Enums.IssuingStrategy
  }

  export type EnumMEALNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.MEAL | EnumMEALFieldRefInput<$PrismaModel> | null
    in?: $Enums.MEAL[] | ListEnumMEALFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MEAL[] | ListEnumMEALFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMEALNullableFilter<$PrismaModel> | $Enums.MEAL | null
  }

  export type BatchNullableScalarRelationFilter = {
    is?: BatchWhereInput | null
    isNot?: BatchWhereInput | null
  }

  export type StratergyHistoryListRelationFilter = {
    every?: StratergyHistoryWhereInput
    some?: StratergyHistoryWhereInput
    none?: StratergyHistoryWhereInput
  }

  export type StratergyHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IssueCountOrderByAggregateInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    batchId?: SortOrder
    drugId?: SortOrder
    brandId?: SortOrder
    strategy?: SortOrder
    quantity?: SortOrder
    dose?: SortOrder
    details?: SortOrder
    meal?: SortOrder
    type?: SortOrder
    unitConcentrationId?: SortOrder
  }

  export type IssueAvgOrderByAggregateInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    batchId?: SortOrder
    drugId?: SortOrder
    brandId?: SortOrder
    quantity?: SortOrder
    dose?: SortOrder
    unitConcentrationId?: SortOrder
  }

  export type IssueMaxOrderByAggregateInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    batchId?: SortOrder
    drugId?: SortOrder
    brandId?: SortOrder
    strategy?: SortOrder
    quantity?: SortOrder
    dose?: SortOrder
    details?: SortOrder
    meal?: SortOrder
    type?: SortOrder
    unitConcentrationId?: SortOrder
  }

  export type IssueMinOrderByAggregateInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    batchId?: SortOrder
    drugId?: SortOrder
    brandId?: SortOrder
    strategy?: SortOrder
    quantity?: SortOrder
    dose?: SortOrder
    details?: SortOrder
    meal?: SortOrder
    type?: SortOrder
    unitConcentrationId?: SortOrder
  }

  export type IssueSumOrderByAggregateInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    batchId?: SortOrder
    drugId?: SortOrder
    brandId?: SortOrder
    quantity?: SortOrder
    dose?: SortOrder
    unitConcentrationId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumIssuingStrategyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IssuingStrategy | EnumIssuingStrategyFieldRefInput<$PrismaModel>
    in?: $Enums.IssuingStrategy[] | ListEnumIssuingStrategyFieldRefInput<$PrismaModel>
    notIn?: $Enums.IssuingStrategy[] | ListEnumIssuingStrategyFieldRefInput<$PrismaModel>
    not?: NestedEnumIssuingStrategyWithAggregatesFilter<$PrismaModel> | $Enums.IssuingStrategy
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIssuingStrategyFilter<$PrismaModel>
    _max?: NestedEnumIssuingStrategyFilter<$PrismaModel>
  }

  export type EnumMEALNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MEAL | EnumMEALFieldRefInput<$PrismaModel> | null
    in?: $Enums.MEAL[] | ListEnumMEALFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MEAL[] | ListEnumMEALFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMEALNullableWithAggregatesFilter<$PrismaModel> | $Enums.MEAL | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumMEALNullableFilter<$PrismaModel>
    _max?: NestedEnumMEALNullableFilter<$PrismaModel>
  }

  export type ReportTypeNullableScalarRelationFilter = {
    is?: ReportTypeWhereInput | null
    isNot?: ReportTypeWhereInput | null
  }

  export type ReportValueListRelationFilter = {
    every?: ReportValueWhereInput
    some?: ReportValueWhereInput
    none?: ReportValueWhereInput
  }

  export type ReportValueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReportParameterCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    units?: SortOrder
    reportTypeId?: SortOrder
  }

  export type ReportParameterAvgOrderByAggregateInput = {
    id?: SortOrder
    reportTypeId?: SortOrder
  }

  export type ReportParameterMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    units?: SortOrder
    reportTypeId?: SortOrder
  }

  export type ReportParameterMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    units?: SortOrder
    reportTypeId?: SortOrder
  }

  export type ReportParameterSumOrderByAggregateInput = {
    id?: SortOrder
    reportTypeId?: SortOrder
  }

  export type ReportParameterListRelationFilter = {
    every?: ReportParameterWhereInput
    some?: ReportParameterWhereInput
    none?: ReportParameterWhereInput
  }

  export type ReportParameterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReportTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type ReportTypeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ReportTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type ReportTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type ReportTypeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ReportTypeScalarRelationFilter = {
    is?: ReportTypeWhereInput
    isNot?: ReportTypeWhereInput
  }

  export type PatientReportCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    reportTypeId?: SortOrder
    time?: SortOrder
  }

  export type PatientReportAvgOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    reportTypeId?: SortOrder
  }

  export type PatientReportMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    reportTypeId?: SortOrder
    time?: SortOrder
  }

  export type PatientReportMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    reportTypeId?: SortOrder
    time?: SortOrder
  }

  export type PatientReportSumOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    reportTypeId?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type PatientReportNullableScalarRelationFilter = {
    is?: PatientReportWhereInput | null
    isNot?: PatientReportWhereInput | null
  }

  export type ReportParameterScalarRelationFilter = {
    is?: ReportParameterWhereInput
    isNot?: ReportParameterWhereInput
  }

  export type ReportValueCountOrderByAggregateInput = {
    id?: SortOrder
    reportParameterId?: SortOrder
    attention?: SortOrder
    value?: SortOrder
    patientReportId?: SortOrder
  }

  export type ReportValueAvgOrderByAggregateInput = {
    id?: SortOrder
    reportParameterId?: SortOrder
    patientReportId?: SortOrder
  }

  export type ReportValueMaxOrderByAggregateInput = {
    id?: SortOrder
    reportParameterId?: SortOrder
    attention?: SortOrder
    value?: SortOrder
    patientReportId?: SortOrder
  }

  export type ReportValueMinOrderByAggregateInput = {
    id?: SortOrder
    reportParameterId?: SortOrder
    attention?: SortOrder
    value?: SortOrder
    patientReportId?: SortOrder
  }

  export type ReportValueSumOrderByAggregateInput = {
    id?: SortOrder
    reportParameterId?: SortOrder
    patientReportId?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IssueScalarRelationFilter = {
    is?: IssueWhereInput
    isNot?: IssueWhereInput
  }

  export type StratergyHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    drugId?: SortOrder
    issueId?: SortOrder
  }

  export type StratergyHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    drugId?: SortOrder
    issueId?: SortOrder
  }

  export type StratergyHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    drugId?: SortOrder
    issueId?: SortOrder
  }

  export type StratergyHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    drugId?: SortOrder
    issueId?: SortOrder
  }

  export type StratergyHistorySumOrderByAggregateInput = {
    id?: SortOrder
    drugId?: SortOrder
    issueId?: SortOrder
  }

  export type BatchScalarRelationFilter = {
    is?: BatchWhereInput
    isNot?: BatchWhereInput
  }

  export type BatchHistoryDrugIdDrugBrandIdTypeUnitConcentrationIdCompoundUniqueInput = {
    drugId: number
    drugBrandId: number
    type: $Enums.DrugType
    unitConcentrationId: number
  }

  export type BatchHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    drugId?: SortOrder
    type?: SortOrder
    unitConcentrationId?: SortOrder
    drugBrandId?: SortOrder
    batchId?: SortOrder
  }

  export type BatchHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    drugId?: SortOrder
    unitConcentrationId?: SortOrder
    drugBrandId?: SortOrder
    batchId?: SortOrder
  }

  export type BatchHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    drugId?: SortOrder
    type?: SortOrder
    unitConcentrationId?: SortOrder
    drugBrandId?: SortOrder
    batchId?: SortOrder
  }

  export type BatchHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    drugId?: SortOrder
    type?: SortOrder
    unitConcentrationId?: SortOrder
    drugBrandId?: SortOrder
    batchId?: SortOrder
  }

  export type BatchHistorySumOrderByAggregateInput = {
    id?: SortOrder
    drugId?: SortOrder
    unitConcentrationId?: SortOrder
    drugBrandId?: SortOrder
    batchId?: SortOrder
  }

  export type ChargeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    value?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChargeAvgOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
  }

  export type ChargeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    value?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChargeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    value?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChargeSumOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
  }

  export type MedicalCertificateCreateNestedManyWithoutPatientInput = {
    create?: XOR<MedicalCertificateCreateWithoutPatientInput, MedicalCertificateUncheckedCreateWithoutPatientInput> | MedicalCertificateCreateWithoutPatientInput[] | MedicalCertificateUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: MedicalCertificateCreateOrConnectWithoutPatientInput | MedicalCertificateCreateOrConnectWithoutPatientInput[]
    createMany?: MedicalCertificateCreateManyPatientInputEnvelope
    connect?: MedicalCertificateWhereUniqueInput | MedicalCertificateWhereUniqueInput[]
  }

  export type PatientHistoryCreateNestedManyWithoutPatientInput = {
    create?: XOR<PatientHistoryCreateWithoutPatientInput, PatientHistoryUncheckedCreateWithoutPatientInput> | PatientHistoryCreateWithoutPatientInput[] | PatientHistoryUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PatientHistoryCreateOrConnectWithoutPatientInput | PatientHistoryCreateOrConnectWithoutPatientInput[]
    createMany?: PatientHistoryCreateManyPatientInputEnvelope
    connect?: PatientHistoryWhereUniqueInput | PatientHistoryWhereUniqueInput[]
  }

  export type PatientReportCreateNestedManyWithoutPatientInput = {
    create?: XOR<PatientReportCreateWithoutPatientInput, PatientReportUncheckedCreateWithoutPatientInput> | PatientReportCreateWithoutPatientInput[] | PatientReportUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PatientReportCreateOrConnectWithoutPatientInput | PatientReportCreateOrConnectWithoutPatientInput[]
    createMany?: PatientReportCreateManyPatientInputEnvelope
    connect?: PatientReportWhereUniqueInput | PatientReportWhereUniqueInput[]
  }

  export type PrescriptionCreateNestedManyWithoutPatientInput = {
    create?: XOR<PrescriptionCreateWithoutPatientInput, PrescriptionUncheckedCreateWithoutPatientInput> | PrescriptionCreateWithoutPatientInput[] | PrescriptionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutPatientInput | PrescriptionCreateOrConnectWithoutPatientInput[]
    createMany?: PrescriptionCreateManyPatientInputEnvelope
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
  }

  export type QueueEntryCreateNestedManyWithoutPatientInput = {
    create?: XOR<QueueEntryCreateWithoutPatientInput, QueueEntryUncheckedCreateWithoutPatientInput> | QueueEntryCreateWithoutPatientInput[] | QueueEntryUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: QueueEntryCreateOrConnectWithoutPatientInput | QueueEntryCreateOrConnectWithoutPatientInput[]
    createMany?: QueueEntryCreateManyPatientInputEnvelope
    connect?: QueueEntryWhereUniqueInput | QueueEntryWhereUniqueInput[]
  }

  export type USSReferralCreateNestedManyWithoutPatientInput = {
    create?: XOR<USSReferralCreateWithoutPatientInput, USSReferralUncheckedCreateWithoutPatientInput> | USSReferralCreateWithoutPatientInput[] | USSReferralUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: USSReferralCreateOrConnectWithoutPatientInput | USSReferralCreateOrConnectWithoutPatientInput[]
    createMany?: USSReferralCreateManyPatientInputEnvelope
    connect?: USSReferralWhereUniqueInput | USSReferralWhereUniqueInput[]
  }

  export type ReferralLetterCreateNestedManyWithoutPatientInput = {
    create?: XOR<ReferralLetterCreateWithoutPatientInput, ReferralLetterUncheckedCreateWithoutPatientInput> | ReferralLetterCreateWithoutPatientInput[] | ReferralLetterUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ReferralLetterCreateOrConnectWithoutPatientInput | ReferralLetterCreateOrConnectWithoutPatientInput[]
    createMany?: ReferralLetterCreateManyPatientInputEnvelope
    connect?: ReferralLetterWhereUniqueInput | ReferralLetterWhereUniqueInput[]
  }

  export type MedicalCertificateUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<MedicalCertificateCreateWithoutPatientInput, MedicalCertificateUncheckedCreateWithoutPatientInput> | MedicalCertificateCreateWithoutPatientInput[] | MedicalCertificateUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: MedicalCertificateCreateOrConnectWithoutPatientInput | MedicalCertificateCreateOrConnectWithoutPatientInput[]
    createMany?: MedicalCertificateCreateManyPatientInputEnvelope
    connect?: MedicalCertificateWhereUniqueInput | MedicalCertificateWhereUniqueInput[]
  }

  export type PatientHistoryUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<PatientHistoryCreateWithoutPatientInput, PatientHistoryUncheckedCreateWithoutPatientInput> | PatientHistoryCreateWithoutPatientInput[] | PatientHistoryUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PatientHistoryCreateOrConnectWithoutPatientInput | PatientHistoryCreateOrConnectWithoutPatientInput[]
    createMany?: PatientHistoryCreateManyPatientInputEnvelope
    connect?: PatientHistoryWhereUniqueInput | PatientHistoryWhereUniqueInput[]
  }

  export type PatientReportUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<PatientReportCreateWithoutPatientInput, PatientReportUncheckedCreateWithoutPatientInput> | PatientReportCreateWithoutPatientInput[] | PatientReportUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PatientReportCreateOrConnectWithoutPatientInput | PatientReportCreateOrConnectWithoutPatientInput[]
    createMany?: PatientReportCreateManyPatientInputEnvelope
    connect?: PatientReportWhereUniqueInput | PatientReportWhereUniqueInput[]
  }

  export type PrescriptionUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<PrescriptionCreateWithoutPatientInput, PrescriptionUncheckedCreateWithoutPatientInput> | PrescriptionCreateWithoutPatientInput[] | PrescriptionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutPatientInput | PrescriptionCreateOrConnectWithoutPatientInput[]
    createMany?: PrescriptionCreateManyPatientInputEnvelope
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
  }

  export type QueueEntryUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<QueueEntryCreateWithoutPatientInput, QueueEntryUncheckedCreateWithoutPatientInput> | QueueEntryCreateWithoutPatientInput[] | QueueEntryUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: QueueEntryCreateOrConnectWithoutPatientInput | QueueEntryCreateOrConnectWithoutPatientInput[]
    createMany?: QueueEntryCreateManyPatientInputEnvelope
    connect?: QueueEntryWhereUniqueInput | QueueEntryWhereUniqueInput[]
  }

  export type USSReferralUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<USSReferralCreateWithoutPatientInput, USSReferralUncheckedCreateWithoutPatientInput> | USSReferralCreateWithoutPatientInput[] | USSReferralUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: USSReferralCreateOrConnectWithoutPatientInput | USSReferralCreateOrConnectWithoutPatientInput[]
    createMany?: USSReferralCreateManyPatientInputEnvelope
    connect?: USSReferralWhereUniqueInput | USSReferralWhereUniqueInput[]
  }

  export type ReferralLetterUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<ReferralLetterCreateWithoutPatientInput, ReferralLetterUncheckedCreateWithoutPatientInput> | ReferralLetterCreateWithoutPatientInput[] | ReferralLetterUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ReferralLetterCreateOrConnectWithoutPatientInput | ReferralLetterCreateOrConnectWithoutPatientInput[]
    createMany?: ReferralLetterCreateManyPatientInputEnvelope
    connect?: ReferralLetterWhereUniqueInput | ReferralLetterWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender
  }

  export type MedicalCertificateUpdateManyWithoutPatientNestedInput = {
    create?: XOR<MedicalCertificateCreateWithoutPatientInput, MedicalCertificateUncheckedCreateWithoutPatientInput> | MedicalCertificateCreateWithoutPatientInput[] | MedicalCertificateUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: MedicalCertificateCreateOrConnectWithoutPatientInput | MedicalCertificateCreateOrConnectWithoutPatientInput[]
    upsert?: MedicalCertificateUpsertWithWhereUniqueWithoutPatientInput | MedicalCertificateUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: MedicalCertificateCreateManyPatientInputEnvelope
    set?: MedicalCertificateWhereUniqueInput | MedicalCertificateWhereUniqueInput[]
    disconnect?: MedicalCertificateWhereUniqueInput | MedicalCertificateWhereUniqueInput[]
    delete?: MedicalCertificateWhereUniqueInput | MedicalCertificateWhereUniqueInput[]
    connect?: MedicalCertificateWhereUniqueInput | MedicalCertificateWhereUniqueInput[]
    update?: MedicalCertificateUpdateWithWhereUniqueWithoutPatientInput | MedicalCertificateUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: MedicalCertificateUpdateManyWithWhereWithoutPatientInput | MedicalCertificateUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: MedicalCertificateScalarWhereInput | MedicalCertificateScalarWhereInput[]
  }

  export type PatientHistoryUpdateManyWithoutPatientNestedInput = {
    create?: XOR<PatientHistoryCreateWithoutPatientInput, PatientHistoryUncheckedCreateWithoutPatientInput> | PatientHistoryCreateWithoutPatientInput[] | PatientHistoryUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PatientHistoryCreateOrConnectWithoutPatientInput | PatientHistoryCreateOrConnectWithoutPatientInput[]
    upsert?: PatientHistoryUpsertWithWhereUniqueWithoutPatientInput | PatientHistoryUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: PatientHistoryCreateManyPatientInputEnvelope
    set?: PatientHistoryWhereUniqueInput | PatientHistoryWhereUniqueInput[]
    disconnect?: PatientHistoryWhereUniqueInput | PatientHistoryWhereUniqueInput[]
    delete?: PatientHistoryWhereUniqueInput | PatientHistoryWhereUniqueInput[]
    connect?: PatientHistoryWhereUniqueInput | PatientHistoryWhereUniqueInput[]
    update?: PatientHistoryUpdateWithWhereUniqueWithoutPatientInput | PatientHistoryUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: PatientHistoryUpdateManyWithWhereWithoutPatientInput | PatientHistoryUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: PatientHistoryScalarWhereInput | PatientHistoryScalarWhereInput[]
  }

  export type PatientReportUpdateManyWithoutPatientNestedInput = {
    create?: XOR<PatientReportCreateWithoutPatientInput, PatientReportUncheckedCreateWithoutPatientInput> | PatientReportCreateWithoutPatientInput[] | PatientReportUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PatientReportCreateOrConnectWithoutPatientInput | PatientReportCreateOrConnectWithoutPatientInput[]
    upsert?: PatientReportUpsertWithWhereUniqueWithoutPatientInput | PatientReportUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: PatientReportCreateManyPatientInputEnvelope
    set?: PatientReportWhereUniqueInput | PatientReportWhereUniqueInput[]
    disconnect?: PatientReportWhereUniqueInput | PatientReportWhereUniqueInput[]
    delete?: PatientReportWhereUniqueInput | PatientReportWhereUniqueInput[]
    connect?: PatientReportWhereUniqueInput | PatientReportWhereUniqueInput[]
    update?: PatientReportUpdateWithWhereUniqueWithoutPatientInput | PatientReportUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: PatientReportUpdateManyWithWhereWithoutPatientInput | PatientReportUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: PatientReportScalarWhereInput | PatientReportScalarWhereInput[]
  }

  export type PrescriptionUpdateManyWithoutPatientNestedInput = {
    create?: XOR<PrescriptionCreateWithoutPatientInput, PrescriptionUncheckedCreateWithoutPatientInput> | PrescriptionCreateWithoutPatientInput[] | PrescriptionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutPatientInput | PrescriptionCreateOrConnectWithoutPatientInput[]
    upsert?: PrescriptionUpsertWithWhereUniqueWithoutPatientInput | PrescriptionUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: PrescriptionCreateManyPatientInputEnvelope
    set?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    disconnect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    delete?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    update?: PrescriptionUpdateWithWhereUniqueWithoutPatientInput | PrescriptionUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: PrescriptionUpdateManyWithWhereWithoutPatientInput | PrescriptionUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
  }

  export type QueueEntryUpdateManyWithoutPatientNestedInput = {
    create?: XOR<QueueEntryCreateWithoutPatientInput, QueueEntryUncheckedCreateWithoutPatientInput> | QueueEntryCreateWithoutPatientInput[] | QueueEntryUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: QueueEntryCreateOrConnectWithoutPatientInput | QueueEntryCreateOrConnectWithoutPatientInput[]
    upsert?: QueueEntryUpsertWithWhereUniqueWithoutPatientInput | QueueEntryUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: QueueEntryCreateManyPatientInputEnvelope
    set?: QueueEntryWhereUniqueInput | QueueEntryWhereUniqueInput[]
    disconnect?: QueueEntryWhereUniqueInput | QueueEntryWhereUniqueInput[]
    delete?: QueueEntryWhereUniqueInput | QueueEntryWhereUniqueInput[]
    connect?: QueueEntryWhereUniqueInput | QueueEntryWhereUniqueInput[]
    update?: QueueEntryUpdateWithWhereUniqueWithoutPatientInput | QueueEntryUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: QueueEntryUpdateManyWithWhereWithoutPatientInput | QueueEntryUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: QueueEntryScalarWhereInput | QueueEntryScalarWhereInput[]
  }

  export type USSReferralUpdateManyWithoutPatientNestedInput = {
    create?: XOR<USSReferralCreateWithoutPatientInput, USSReferralUncheckedCreateWithoutPatientInput> | USSReferralCreateWithoutPatientInput[] | USSReferralUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: USSReferralCreateOrConnectWithoutPatientInput | USSReferralCreateOrConnectWithoutPatientInput[]
    upsert?: USSReferralUpsertWithWhereUniqueWithoutPatientInput | USSReferralUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: USSReferralCreateManyPatientInputEnvelope
    set?: USSReferralWhereUniqueInput | USSReferralWhereUniqueInput[]
    disconnect?: USSReferralWhereUniqueInput | USSReferralWhereUniqueInput[]
    delete?: USSReferralWhereUniqueInput | USSReferralWhereUniqueInput[]
    connect?: USSReferralWhereUniqueInput | USSReferralWhereUniqueInput[]
    update?: USSReferralUpdateWithWhereUniqueWithoutPatientInput | USSReferralUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: USSReferralUpdateManyWithWhereWithoutPatientInput | USSReferralUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: USSReferralScalarWhereInput | USSReferralScalarWhereInput[]
  }

  export type ReferralLetterUpdateManyWithoutPatientNestedInput = {
    create?: XOR<ReferralLetterCreateWithoutPatientInput, ReferralLetterUncheckedCreateWithoutPatientInput> | ReferralLetterCreateWithoutPatientInput[] | ReferralLetterUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ReferralLetterCreateOrConnectWithoutPatientInput | ReferralLetterCreateOrConnectWithoutPatientInput[]
    upsert?: ReferralLetterUpsertWithWhereUniqueWithoutPatientInput | ReferralLetterUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: ReferralLetterCreateManyPatientInputEnvelope
    set?: ReferralLetterWhereUniqueInput | ReferralLetterWhereUniqueInput[]
    disconnect?: ReferralLetterWhereUniqueInput | ReferralLetterWhereUniqueInput[]
    delete?: ReferralLetterWhereUniqueInput | ReferralLetterWhereUniqueInput[]
    connect?: ReferralLetterWhereUniqueInput | ReferralLetterWhereUniqueInput[]
    update?: ReferralLetterUpdateWithWhereUniqueWithoutPatientInput | ReferralLetterUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: ReferralLetterUpdateManyWithWhereWithoutPatientInput | ReferralLetterUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: ReferralLetterScalarWhereInput | ReferralLetterScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type MedicalCertificateUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<MedicalCertificateCreateWithoutPatientInput, MedicalCertificateUncheckedCreateWithoutPatientInput> | MedicalCertificateCreateWithoutPatientInput[] | MedicalCertificateUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: MedicalCertificateCreateOrConnectWithoutPatientInput | MedicalCertificateCreateOrConnectWithoutPatientInput[]
    upsert?: MedicalCertificateUpsertWithWhereUniqueWithoutPatientInput | MedicalCertificateUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: MedicalCertificateCreateManyPatientInputEnvelope
    set?: MedicalCertificateWhereUniqueInput | MedicalCertificateWhereUniqueInput[]
    disconnect?: MedicalCertificateWhereUniqueInput | MedicalCertificateWhereUniqueInput[]
    delete?: MedicalCertificateWhereUniqueInput | MedicalCertificateWhereUniqueInput[]
    connect?: MedicalCertificateWhereUniqueInput | MedicalCertificateWhereUniqueInput[]
    update?: MedicalCertificateUpdateWithWhereUniqueWithoutPatientInput | MedicalCertificateUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: MedicalCertificateUpdateManyWithWhereWithoutPatientInput | MedicalCertificateUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: MedicalCertificateScalarWhereInput | MedicalCertificateScalarWhereInput[]
  }

  export type PatientHistoryUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<PatientHistoryCreateWithoutPatientInput, PatientHistoryUncheckedCreateWithoutPatientInput> | PatientHistoryCreateWithoutPatientInput[] | PatientHistoryUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PatientHistoryCreateOrConnectWithoutPatientInput | PatientHistoryCreateOrConnectWithoutPatientInput[]
    upsert?: PatientHistoryUpsertWithWhereUniqueWithoutPatientInput | PatientHistoryUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: PatientHistoryCreateManyPatientInputEnvelope
    set?: PatientHistoryWhereUniqueInput | PatientHistoryWhereUniqueInput[]
    disconnect?: PatientHistoryWhereUniqueInput | PatientHistoryWhereUniqueInput[]
    delete?: PatientHistoryWhereUniqueInput | PatientHistoryWhereUniqueInput[]
    connect?: PatientHistoryWhereUniqueInput | PatientHistoryWhereUniqueInput[]
    update?: PatientHistoryUpdateWithWhereUniqueWithoutPatientInput | PatientHistoryUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: PatientHistoryUpdateManyWithWhereWithoutPatientInput | PatientHistoryUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: PatientHistoryScalarWhereInput | PatientHistoryScalarWhereInput[]
  }

  export type PatientReportUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<PatientReportCreateWithoutPatientInput, PatientReportUncheckedCreateWithoutPatientInput> | PatientReportCreateWithoutPatientInput[] | PatientReportUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PatientReportCreateOrConnectWithoutPatientInput | PatientReportCreateOrConnectWithoutPatientInput[]
    upsert?: PatientReportUpsertWithWhereUniqueWithoutPatientInput | PatientReportUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: PatientReportCreateManyPatientInputEnvelope
    set?: PatientReportWhereUniqueInput | PatientReportWhereUniqueInput[]
    disconnect?: PatientReportWhereUniqueInput | PatientReportWhereUniqueInput[]
    delete?: PatientReportWhereUniqueInput | PatientReportWhereUniqueInput[]
    connect?: PatientReportWhereUniqueInput | PatientReportWhereUniqueInput[]
    update?: PatientReportUpdateWithWhereUniqueWithoutPatientInput | PatientReportUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: PatientReportUpdateManyWithWhereWithoutPatientInput | PatientReportUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: PatientReportScalarWhereInput | PatientReportScalarWhereInput[]
  }

  export type PrescriptionUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<PrescriptionCreateWithoutPatientInput, PrescriptionUncheckedCreateWithoutPatientInput> | PrescriptionCreateWithoutPatientInput[] | PrescriptionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutPatientInput | PrescriptionCreateOrConnectWithoutPatientInput[]
    upsert?: PrescriptionUpsertWithWhereUniqueWithoutPatientInput | PrescriptionUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: PrescriptionCreateManyPatientInputEnvelope
    set?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    disconnect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    delete?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    update?: PrescriptionUpdateWithWhereUniqueWithoutPatientInput | PrescriptionUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: PrescriptionUpdateManyWithWhereWithoutPatientInput | PrescriptionUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
  }

  export type QueueEntryUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<QueueEntryCreateWithoutPatientInput, QueueEntryUncheckedCreateWithoutPatientInput> | QueueEntryCreateWithoutPatientInput[] | QueueEntryUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: QueueEntryCreateOrConnectWithoutPatientInput | QueueEntryCreateOrConnectWithoutPatientInput[]
    upsert?: QueueEntryUpsertWithWhereUniqueWithoutPatientInput | QueueEntryUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: QueueEntryCreateManyPatientInputEnvelope
    set?: QueueEntryWhereUniqueInput | QueueEntryWhereUniqueInput[]
    disconnect?: QueueEntryWhereUniqueInput | QueueEntryWhereUniqueInput[]
    delete?: QueueEntryWhereUniqueInput | QueueEntryWhereUniqueInput[]
    connect?: QueueEntryWhereUniqueInput | QueueEntryWhereUniqueInput[]
    update?: QueueEntryUpdateWithWhereUniqueWithoutPatientInput | QueueEntryUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: QueueEntryUpdateManyWithWhereWithoutPatientInput | QueueEntryUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: QueueEntryScalarWhereInput | QueueEntryScalarWhereInput[]
  }

  export type USSReferralUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<USSReferralCreateWithoutPatientInput, USSReferralUncheckedCreateWithoutPatientInput> | USSReferralCreateWithoutPatientInput[] | USSReferralUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: USSReferralCreateOrConnectWithoutPatientInput | USSReferralCreateOrConnectWithoutPatientInput[]
    upsert?: USSReferralUpsertWithWhereUniqueWithoutPatientInput | USSReferralUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: USSReferralCreateManyPatientInputEnvelope
    set?: USSReferralWhereUniqueInput | USSReferralWhereUniqueInput[]
    disconnect?: USSReferralWhereUniqueInput | USSReferralWhereUniqueInput[]
    delete?: USSReferralWhereUniqueInput | USSReferralWhereUniqueInput[]
    connect?: USSReferralWhereUniqueInput | USSReferralWhereUniqueInput[]
    update?: USSReferralUpdateWithWhereUniqueWithoutPatientInput | USSReferralUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: USSReferralUpdateManyWithWhereWithoutPatientInput | USSReferralUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: USSReferralScalarWhereInput | USSReferralScalarWhereInput[]
  }

  export type ReferralLetterUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<ReferralLetterCreateWithoutPatientInput, ReferralLetterUncheckedCreateWithoutPatientInput> | ReferralLetterCreateWithoutPatientInput[] | ReferralLetterUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ReferralLetterCreateOrConnectWithoutPatientInput | ReferralLetterCreateOrConnectWithoutPatientInput[]
    upsert?: ReferralLetterUpsertWithWhereUniqueWithoutPatientInput | ReferralLetterUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: ReferralLetterCreateManyPatientInputEnvelope
    set?: ReferralLetterWhereUniqueInput | ReferralLetterWhereUniqueInput[]
    disconnect?: ReferralLetterWhereUniqueInput | ReferralLetterWhereUniqueInput[]
    delete?: ReferralLetterWhereUniqueInput | ReferralLetterWhereUniqueInput[]
    connect?: ReferralLetterWhereUniqueInput | ReferralLetterWhereUniqueInput[]
    update?: ReferralLetterUpdateWithWhereUniqueWithoutPatientInput | ReferralLetterUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: ReferralLetterUpdateManyWithWhereWithoutPatientInput | ReferralLetterUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: ReferralLetterScalarWhereInput | ReferralLetterScalarWhereInput[]
  }

  export type PatientCreateNestedOneWithoutPatientHistoryInput = {
    create?: XOR<PatientCreateWithoutPatientHistoryInput, PatientUncheckedCreateWithoutPatientHistoryInput>
    connectOrCreate?: PatientCreateOrConnectWithoutPatientHistoryInput
    connect?: PatientWhereUniqueInput
  }

  export type EnumPatientHistoryTypeFieldUpdateOperationsInput = {
    set?: $Enums.PatientHistoryType
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type PatientUpdateOneRequiredWithoutPatientHistoryNestedInput = {
    create?: XOR<PatientCreateWithoutPatientHistoryInput, PatientUncheckedCreateWithoutPatientHistoryInput>
    connectOrCreate?: PatientCreateOrConnectWithoutPatientHistoryInput
    upsert?: PatientUpsertWithoutPatientHistoryInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutPatientHistoryInput, PatientUpdateWithoutPatientHistoryInput>, PatientUncheckedUpdateWithoutPatientHistoryInput>
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type QueueEntryCreateNestedManyWithoutQueueInput = {
    create?: XOR<QueueEntryCreateWithoutQueueInput, QueueEntryUncheckedCreateWithoutQueueInput> | QueueEntryCreateWithoutQueueInput[] | QueueEntryUncheckedCreateWithoutQueueInput[]
    connectOrCreate?: QueueEntryCreateOrConnectWithoutQueueInput | QueueEntryCreateOrConnectWithoutQueueInput[]
    createMany?: QueueEntryCreateManyQueueInputEnvelope
    connect?: QueueEntryWhereUniqueInput | QueueEntryWhereUniqueInput[]
  }

  export type QueueEntryUncheckedCreateNestedManyWithoutQueueInput = {
    create?: XOR<QueueEntryCreateWithoutQueueInput, QueueEntryUncheckedCreateWithoutQueueInput> | QueueEntryCreateWithoutQueueInput[] | QueueEntryUncheckedCreateWithoutQueueInput[]
    connectOrCreate?: QueueEntryCreateOrConnectWithoutQueueInput | QueueEntryCreateOrConnectWithoutQueueInput[]
    createMany?: QueueEntryCreateManyQueueInputEnvelope
    connect?: QueueEntryWhereUniqueInput | QueueEntryWhereUniqueInput[]
  }

  export type EnumQueueStatusFieldUpdateOperationsInput = {
    set?: $Enums.QueueStatus
  }

  export type QueueEntryUpdateManyWithoutQueueNestedInput = {
    create?: XOR<QueueEntryCreateWithoutQueueInput, QueueEntryUncheckedCreateWithoutQueueInput> | QueueEntryCreateWithoutQueueInput[] | QueueEntryUncheckedCreateWithoutQueueInput[]
    connectOrCreate?: QueueEntryCreateOrConnectWithoutQueueInput | QueueEntryCreateOrConnectWithoutQueueInput[]
    upsert?: QueueEntryUpsertWithWhereUniqueWithoutQueueInput | QueueEntryUpsertWithWhereUniqueWithoutQueueInput[]
    createMany?: QueueEntryCreateManyQueueInputEnvelope
    set?: QueueEntryWhereUniqueInput | QueueEntryWhereUniqueInput[]
    disconnect?: QueueEntryWhereUniqueInput | QueueEntryWhereUniqueInput[]
    delete?: QueueEntryWhereUniqueInput | QueueEntryWhereUniqueInput[]
    connect?: QueueEntryWhereUniqueInput | QueueEntryWhereUniqueInput[]
    update?: QueueEntryUpdateWithWhereUniqueWithoutQueueInput | QueueEntryUpdateWithWhereUniqueWithoutQueueInput[]
    updateMany?: QueueEntryUpdateManyWithWhereWithoutQueueInput | QueueEntryUpdateManyWithWhereWithoutQueueInput[]
    deleteMany?: QueueEntryScalarWhereInput | QueueEntryScalarWhereInput[]
  }

  export type QueueEntryUncheckedUpdateManyWithoutQueueNestedInput = {
    create?: XOR<QueueEntryCreateWithoutQueueInput, QueueEntryUncheckedCreateWithoutQueueInput> | QueueEntryCreateWithoutQueueInput[] | QueueEntryUncheckedCreateWithoutQueueInput[]
    connectOrCreate?: QueueEntryCreateOrConnectWithoutQueueInput | QueueEntryCreateOrConnectWithoutQueueInput[]
    upsert?: QueueEntryUpsertWithWhereUniqueWithoutQueueInput | QueueEntryUpsertWithWhereUniqueWithoutQueueInput[]
    createMany?: QueueEntryCreateManyQueueInputEnvelope
    set?: QueueEntryWhereUniqueInput | QueueEntryWhereUniqueInput[]
    disconnect?: QueueEntryWhereUniqueInput | QueueEntryWhereUniqueInput[]
    delete?: QueueEntryWhereUniqueInput | QueueEntryWhereUniqueInput[]
    connect?: QueueEntryWhereUniqueInput | QueueEntryWhereUniqueInput[]
    update?: QueueEntryUpdateWithWhereUniqueWithoutQueueInput | QueueEntryUpdateWithWhereUniqueWithoutQueueInput[]
    updateMany?: QueueEntryUpdateManyWithWhereWithoutQueueInput | QueueEntryUpdateManyWithWhereWithoutQueueInput[]
    deleteMany?: QueueEntryScalarWhereInput | QueueEntryScalarWhereInput[]
  }

  export type PatientCreateNestedOneWithoutQueueEntryInput = {
    create?: XOR<PatientCreateWithoutQueueEntryInput, PatientUncheckedCreateWithoutQueueEntryInput>
    connectOrCreate?: PatientCreateOrConnectWithoutQueueEntryInput
    connect?: PatientWhereUniqueInput
  }

  export type QueueCreateNestedOneWithoutEntriesInput = {
    create?: XOR<QueueCreateWithoutEntriesInput, QueueUncheckedCreateWithoutEntriesInput>
    connectOrCreate?: QueueCreateOrConnectWithoutEntriesInput
    connect?: QueueWhereUniqueInput
  }

  export type EnumVisitStatusFieldUpdateOperationsInput = {
    set?: $Enums.VisitStatus
  }

  export type PatientUpdateOneRequiredWithoutQueueEntryNestedInput = {
    create?: XOR<PatientCreateWithoutQueueEntryInput, PatientUncheckedCreateWithoutQueueEntryInput>
    connectOrCreate?: PatientCreateOrConnectWithoutQueueEntryInput
    upsert?: PatientUpsertWithoutQueueEntryInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutQueueEntryInput, PatientUpdateWithoutQueueEntryInput>, PatientUncheckedUpdateWithoutQueueEntryInput>
  }

  export type QueueUpdateOneRequiredWithoutEntriesNestedInput = {
    create?: XOR<QueueCreateWithoutEntriesInput, QueueUncheckedCreateWithoutEntriesInput>
    connectOrCreate?: QueueCreateOrConnectWithoutEntriesInput
    upsert?: QueueUpsertWithoutEntriesInput
    connect?: QueueWhereUniqueInput
    update?: XOR<XOR<QueueUpdateToOneWithWhereWithoutEntriesInput, QueueUpdateWithoutEntriesInput>, QueueUncheckedUpdateWithoutEntriesInput>
  }

  export type BatchCreateNestedManyWithoutDrugBrandInput = {
    create?: XOR<BatchCreateWithoutDrugBrandInput, BatchUncheckedCreateWithoutDrugBrandInput> | BatchCreateWithoutDrugBrandInput[] | BatchUncheckedCreateWithoutDrugBrandInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutDrugBrandInput | BatchCreateOrConnectWithoutDrugBrandInput[]
    createMany?: BatchCreateManyDrugBrandInputEnvelope
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
  }

  export type BatchHistoryCreateNestedManyWithoutBrandInput = {
    create?: XOR<BatchHistoryCreateWithoutBrandInput, BatchHistoryUncheckedCreateWithoutBrandInput> | BatchHistoryCreateWithoutBrandInput[] | BatchHistoryUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: BatchHistoryCreateOrConnectWithoutBrandInput | BatchHistoryCreateOrConnectWithoutBrandInput[]
    createMany?: BatchHistoryCreateManyBrandInputEnvelope
    connect?: BatchHistoryWhereUniqueInput | BatchHistoryWhereUniqueInput[]
  }

  export type IssueCreateNestedManyWithoutBrandInput = {
    create?: XOR<IssueCreateWithoutBrandInput, IssueUncheckedCreateWithoutBrandInput> | IssueCreateWithoutBrandInput[] | IssueUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: IssueCreateOrConnectWithoutBrandInput | IssueCreateOrConnectWithoutBrandInput[]
    createMany?: IssueCreateManyBrandInputEnvelope
    connect?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
  }

  export type BatchUncheckedCreateNestedManyWithoutDrugBrandInput = {
    create?: XOR<BatchCreateWithoutDrugBrandInput, BatchUncheckedCreateWithoutDrugBrandInput> | BatchCreateWithoutDrugBrandInput[] | BatchUncheckedCreateWithoutDrugBrandInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutDrugBrandInput | BatchCreateOrConnectWithoutDrugBrandInput[]
    createMany?: BatchCreateManyDrugBrandInputEnvelope
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
  }

  export type BatchHistoryUncheckedCreateNestedManyWithoutBrandInput = {
    create?: XOR<BatchHistoryCreateWithoutBrandInput, BatchHistoryUncheckedCreateWithoutBrandInput> | BatchHistoryCreateWithoutBrandInput[] | BatchHistoryUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: BatchHistoryCreateOrConnectWithoutBrandInput | BatchHistoryCreateOrConnectWithoutBrandInput[]
    createMany?: BatchHistoryCreateManyBrandInputEnvelope
    connect?: BatchHistoryWhereUniqueInput | BatchHistoryWhereUniqueInput[]
  }

  export type IssueUncheckedCreateNestedManyWithoutBrandInput = {
    create?: XOR<IssueCreateWithoutBrandInput, IssueUncheckedCreateWithoutBrandInput> | IssueCreateWithoutBrandInput[] | IssueUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: IssueCreateOrConnectWithoutBrandInput | IssueCreateOrConnectWithoutBrandInput[]
    createMany?: IssueCreateManyBrandInputEnvelope
    connect?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
  }

  export type BatchUpdateManyWithoutDrugBrandNestedInput = {
    create?: XOR<BatchCreateWithoutDrugBrandInput, BatchUncheckedCreateWithoutDrugBrandInput> | BatchCreateWithoutDrugBrandInput[] | BatchUncheckedCreateWithoutDrugBrandInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutDrugBrandInput | BatchCreateOrConnectWithoutDrugBrandInput[]
    upsert?: BatchUpsertWithWhereUniqueWithoutDrugBrandInput | BatchUpsertWithWhereUniqueWithoutDrugBrandInput[]
    createMany?: BatchCreateManyDrugBrandInputEnvelope
    set?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    disconnect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    delete?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    update?: BatchUpdateWithWhereUniqueWithoutDrugBrandInput | BatchUpdateWithWhereUniqueWithoutDrugBrandInput[]
    updateMany?: BatchUpdateManyWithWhereWithoutDrugBrandInput | BatchUpdateManyWithWhereWithoutDrugBrandInput[]
    deleteMany?: BatchScalarWhereInput | BatchScalarWhereInput[]
  }

  export type BatchHistoryUpdateManyWithoutBrandNestedInput = {
    create?: XOR<BatchHistoryCreateWithoutBrandInput, BatchHistoryUncheckedCreateWithoutBrandInput> | BatchHistoryCreateWithoutBrandInput[] | BatchHistoryUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: BatchHistoryCreateOrConnectWithoutBrandInput | BatchHistoryCreateOrConnectWithoutBrandInput[]
    upsert?: BatchHistoryUpsertWithWhereUniqueWithoutBrandInput | BatchHistoryUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: BatchHistoryCreateManyBrandInputEnvelope
    set?: BatchHistoryWhereUniqueInput | BatchHistoryWhereUniqueInput[]
    disconnect?: BatchHistoryWhereUniqueInput | BatchHistoryWhereUniqueInput[]
    delete?: BatchHistoryWhereUniqueInput | BatchHistoryWhereUniqueInput[]
    connect?: BatchHistoryWhereUniqueInput | BatchHistoryWhereUniqueInput[]
    update?: BatchHistoryUpdateWithWhereUniqueWithoutBrandInput | BatchHistoryUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: BatchHistoryUpdateManyWithWhereWithoutBrandInput | BatchHistoryUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: BatchHistoryScalarWhereInput | BatchHistoryScalarWhereInput[]
  }

  export type IssueUpdateManyWithoutBrandNestedInput = {
    create?: XOR<IssueCreateWithoutBrandInput, IssueUncheckedCreateWithoutBrandInput> | IssueCreateWithoutBrandInput[] | IssueUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: IssueCreateOrConnectWithoutBrandInput | IssueCreateOrConnectWithoutBrandInput[]
    upsert?: IssueUpsertWithWhereUniqueWithoutBrandInput | IssueUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: IssueCreateManyBrandInputEnvelope
    set?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    disconnect?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    delete?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    connect?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    update?: IssueUpdateWithWhereUniqueWithoutBrandInput | IssueUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: IssueUpdateManyWithWhereWithoutBrandInput | IssueUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: IssueScalarWhereInput | IssueScalarWhereInput[]
  }

  export type BatchUncheckedUpdateManyWithoutDrugBrandNestedInput = {
    create?: XOR<BatchCreateWithoutDrugBrandInput, BatchUncheckedCreateWithoutDrugBrandInput> | BatchCreateWithoutDrugBrandInput[] | BatchUncheckedCreateWithoutDrugBrandInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutDrugBrandInput | BatchCreateOrConnectWithoutDrugBrandInput[]
    upsert?: BatchUpsertWithWhereUniqueWithoutDrugBrandInput | BatchUpsertWithWhereUniqueWithoutDrugBrandInput[]
    createMany?: BatchCreateManyDrugBrandInputEnvelope
    set?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    disconnect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    delete?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    update?: BatchUpdateWithWhereUniqueWithoutDrugBrandInput | BatchUpdateWithWhereUniqueWithoutDrugBrandInput[]
    updateMany?: BatchUpdateManyWithWhereWithoutDrugBrandInput | BatchUpdateManyWithWhereWithoutDrugBrandInput[]
    deleteMany?: BatchScalarWhereInput | BatchScalarWhereInput[]
  }

  export type BatchHistoryUncheckedUpdateManyWithoutBrandNestedInput = {
    create?: XOR<BatchHistoryCreateWithoutBrandInput, BatchHistoryUncheckedCreateWithoutBrandInput> | BatchHistoryCreateWithoutBrandInput[] | BatchHistoryUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: BatchHistoryCreateOrConnectWithoutBrandInput | BatchHistoryCreateOrConnectWithoutBrandInput[]
    upsert?: BatchHistoryUpsertWithWhereUniqueWithoutBrandInput | BatchHistoryUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: BatchHistoryCreateManyBrandInputEnvelope
    set?: BatchHistoryWhereUniqueInput | BatchHistoryWhereUniqueInput[]
    disconnect?: BatchHistoryWhereUniqueInput | BatchHistoryWhereUniqueInput[]
    delete?: BatchHistoryWhereUniqueInput | BatchHistoryWhereUniqueInput[]
    connect?: BatchHistoryWhereUniqueInput | BatchHistoryWhereUniqueInput[]
    update?: BatchHistoryUpdateWithWhereUniqueWithoutBrandInput | BatchHistoryUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: BatchHistoryUpdateManyWithWhereWithoutBrandInput | BatchHistoryUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: BatchHistoryScalarWhereInput | BatchHistoryScalarWhereInput[]
  }

  export type IssueUncheckedUpdateManyWithoutBrandNestedInput = {
    create?: XOR<IssueCreateWithoutBrandInput, IssueUncheckedCreateWithoutBrandInput> | IssueCreateWithoutBrandInput[] | IssueUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: IssueCreateOrConnectWithoutBrandInput | IssueCreateOrConnectWithoutBrandInput[]
    upsert?: IssueUpsertWithWhereUniqueWithoutBrandInput | IssueUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: IssueCreateManyBrandInputEnvelope
    set?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    disconnect?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    delete?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    connect?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    update?: IssueUpdateWithWhereUniqueWithoutBrandInput | IssueUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: IssueUpdateManyWithWhereWithoutBrandInput | IssueUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: IssueScalarWhereInput | IssueScalarWhereInput[]
  }

  export type BatchCreateNestedManyWithoutDrugInput = {
    create?: XOR<BatchCreateWithoutDrugInput, BatchUncheckedCreateWithoutDrugInput> | BatchCreateWithoutDrugInput[] | BatchUncheckedCreateWithoutDrugInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutDrugInput | BatchCreateOrConnectWithoutDrugInput[]
    createMany?: BatchCreateManyDrugInputEnvelope
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
  }

  export type BatchHistoryCreateNestedManyWithoutDrugInput = {
    create?: XOR<BatchHistoryCreateWithoutDrugInput, BatchHistoryUncheckedCreateWithoutDrugInput> | BatchHistoryCreateWithoutDrugInput[] | BatchHistoryUncheckedCreateWithoutDrugInput[]
    connectOrCreate?: BatchHistoryCreateOrConnectWithoutDrugInput | BatchHistoryCreateOrConnectWithoutDrugInput[]
    createMany?: BatchHistoryCreateManyDrugInputEnvelope
    connect?: BatchHistoryWhereUniqueInput | BatchHistoryWhereUniqueInput[]
  }

  export type IssueCreateNestedManyWithoutDrugInput = {
    create?: XOR<IssueCreateWithoutDrugInput, IssueUncheckedCreateWithoutDrugInput> | IssueCreateWithoutDrugInput[] | IssueUncheckedCreateWithoutDrugInput[]
    connectOrCreate?: IssueCreateOrConnectWithoutDrugInput | IssueCreateOrConnectWithoutDrugInput[]
    createMany?: IssueCreateManyDrugInputEnvelope
    connect?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
  }

  export type StratergyHistoryCreateNestedOneWithoutDrugInput = {
    create?: XOR<StratergyHistoryCreateWithoutDrugInput, StratergyHistoryUncheckedCreateWithoutDrugInput>
    connectOrCreate?: StratergyHistoryCreateOrConnectWithoutDrugInput
    connect?: StratergyHistoryWhereUniqueInput
  }

  export type BufferLevelCreateNestedManyWithoutDrugInput = {
    create?: XOR<BufferLevelCreateWithoutDrugInput, BufferLevelUncheckedCreateWithoutDrugInput> | BufferLevelCreateWithoutDrugInput[] | BufferLevelUncheckedCreateWithoutDrugInput[]
    connectOrCreate?: BufferLevelCreateOrConnectWithoutDrugInput | BufferLevelCreateOrConnectWithoutDrugInput[]
    createMany?: BufferLevelCreateManyDrugInputEnvelope
    connect?: BufferLevelWhereUniqueInput | BufferLevelWhereUniqueInput[]
  }

  export type BatchUncheckedCreateNestedManyWithoutDrugInput = {
    create?: XOR<BatchCreateWithoutDrugInput, BatchUncheckedCreateWithoutDrugInput> | BatchCreateWithoutDrugInput[] | BatchUncheckedCreateWithoutDrugInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutDrugInput | BatchCreateOrConnectWithoutDrugInput[]
    createMany?: BatchCreateManyDrugInputEnvelope
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
  }

  export type BatchHistoryUncheckedCreateNestedManyWithoutDrugInput = {
    create?: XOR<BatchHistoryCreateWithoutDrugInput, BatchHistoryUncheckedCreateWithoutDrugInput> | BatchHistoryCreateWithoutDrugInput[] | BatchHistoryUncheckedCreateWithoutDrugInput[]
    connectOrCreate?: BatchHistoryCreateOrConnectWithoutDrugInput | BatchHistoryCreateOrConnectWithoutDrugInput[]
    createMany?: BatchHistoryCreateManyDrugInputEnvelope
    connect?: BatchHistoryWhereUniqueInput | BatchHistoryWhereUniqueInput[]
  }

  export type IssueUncheckedCreateNestedManyWithoutDrugInput = {
    create?: XOR<IssueCreateWithoutDrugInput, IssueUncheckedCreateWithoutDrugInput> | IssueCreateWithoutDrugInput[] | IssueUncheckedCreateWithoutDrugInput[]
    connectOrCreate?: IssueCreateOrConnectWithoutDrugInput | IssueCreateOrConnectWithoutDrugInput[]
    createMany?: IssueCreateManyDrugInputEnvelope
    connect?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
  }

  export type StratergyHistoryUncheckedCreateNestedOneWithoutDrugInput = {
    create?: XOR<StratergyHistoryCreateWithoutDrugInput, StratergyHistoryUncheckedCreateWithoutDrugInput>
    connectOrCreate?: StratergyHistoryCreateOrConnectWithoutDrugInput
    connect?: StratergyHistoryWhereUniqueInput
  }

  export type BufferLevelUncheckedCreateNestedManyWithoutDrugInput = {
    create?: XOR<BufferLevelCreateWithoutDrugInput, BufferLevelUncheckedCreateWithoutDrugInput> | BufferLevelCreateWithoutDrugInput[] | BufferLevelUncheckedCreateWithoutDrugInput[]
    connectOrCreate?: BufferLevelCreateOrConnectWithoutDrugInput | BufferLevelCreateOrConnectWithoutDrugInput[]
    createMany?: BufferLevelCreateManyDrugInputEnvelope
    connect?: BufferLevelWhereUniqueInput | BufferLevelWhereUniqueInput[]
  }

  export type BatchUpdateManyWithoutDrugNestedInput = {
    create?: XOR<BatchCreateWithoutDrugInput, BatchUncheckedCreateWithoutDrugInput> | BatchCreateWithoutDrugInput[] | BatchUncheckedCreateWithoutDrugInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutDrugInput | BatchCreateOrConnectWithoutDrugInput[]
    upsert?: BatchUpsertWithWhereUniqueWithoutDrugInput | BatchUpsertWithWhereUniqueWithoutDrugInput[]
    createMany?: BatchCreateManyDrugInputEnvelope
    set?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    disconnect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    delete?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    update?: BatchUpdateWithWhereUniqueWithoutDrugInput | BatchUpdateWithWhereUniqueWithoutDrugInput[]
    updateMany?: BatchUpdateManyWithWhereWithoutDrugInput | BatchUpdateManyWithWhereWithoutDrugInput[]
    deleteMany?: BatchScalarWhereInput | BatchScalarWhereInput[]
  }

  export type BatchHistoryUpdateManyWithoutDrugNestedInput = {
    create?: XOR<BatchHistoryCreateWithoutDrugInput, BatchHistoryUncheckedCreateWithoutDrugInput> | BatchHistoryCreateWithoutDrugInput[] | BatchHistoryUncheckedCreateWithoutDrugInput[]
    connectOrCreate?: BatchHistoryCreateOrConnectWithoutDrugInput | BatchHistoryCreateOrConnectWithoutDrugInput[]
    upsert?: BatchHistoryUpsertWithWhereUniqueWithoutDrugInput | BatchHistoryUpsertWithWhereUniqueWithoutDrugInput[]
    createMany?: BatchHistoryCreateManyDrugInputEnvelope
    set?: BatchHistoryWhereUniqueInput | BatchHistoryWhereUniqueInput[]
    disconnect?: BatchHistoryWhereUniqueInput | BatchHistoryWhereUniqueInput[]
    delete?: BatchHistoryWhereUniqueInput | BatchHistoryWhereUniqueInput[]
    connect?: BatchHistoryWhereUniqueInput | BatchHistoryWhereUniqueInput[]
    update?: BatchHistoryUpdateWithWhereUniqueWithoutDrugInput | BatchHistoryUpdateWithWhereUniqueWithoutDrugInput[]
    updateMany?: BatchHistoryUpdateManyWithWhereWithoutDrugInput | BatchHistoryUpdateManyWithWhereWithoutDrugInput[]
    deleteMany?: BatchHistoryScalarWhereInput | BatchHistoryScalarWhereInput[]
  }

  export type IssueUpdateManyWithoutDrugNestedInput = {
    create?: XOR<IssueCreateWithoutDrugInput, IssueUncheckedCreateWithoutDrugInput> | IssueCreateWithoutDrugInput[] | IssueUncheckedCreateWithoutDrugInput[]
    connectOrCreate?: IssueCreateOrConnectWithoutDrugInput | IssueCreateOrConnectWithoutDrugInput[]
    upsert?: IssueUpsertWithWhereUniqueWithoutDrugInput | IssueUpsertWithWhereUniqueWithoutDrugInput[]
    createMany?: IssueCreateManyDrugInputEnvelope
    set?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    disconnect?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    delete?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    connect?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    update?: IssueUpdateWithWhereUniqueWithoutDrugInput | IssueUpdateWithWhereUniqueWithoutDrugInput[]
    updateMany?: IssueUpdateManyWithWhereWithoutDrugInput | IssueUpdateManyWithWhereWithoutDrugInput[]
    deleteMany?: IssueScalarWhereInput | IssueScalarWhereInput[]
  }

  export type StratergyHistoryUpdateOneWithoutDrugNestedInput = {
    create?: XOR<StratergyHistoryCreateWithoutDrugInput, StratergyHistoryUncheckedCreateWithoutDrugInput>
    connectOrCreate?: StratergyHistoryCreateOrConnectWithoutDrugInput
    upsert?: StratergyHistoryUpsertWithoutDrugInput
    disconnect?: StratergyHistoryWhereInput | boolean
    delete?: StratergyHistoryWhereInput | boolean
    connect?: StratergyHistoryWhereUniqueInput
    update?: XOR<XOR<StratergyHistoryUpdateToOneWithWhereWithoutDrugInput, StratergyHistoryUpdateWithoutDrugInput>, StratergyHistoryUncheckedUpdateWithoutDrugInput>
  }

  export type BufferLevelUpdateManyWithoutDrugNestedInput = {
    create?: XOR<BufferLevelCreateWithoutDrugInput, BufferLevelUncheckedCreateWithoutDrugInput> | BufferLevelCreateWithoutDrugInput[] | BufferLevelUncheckedCreateWithoutDrugInput[]
    connectOrCreate?: BufferLevelCreateOrConnectWithoutDrugInput | BufferLevelCreateOrConnectWithoutDrugInput[]
    upsert?: BufferLevelUpsertWithWhereUniqueWithoutDrugInput | BufferLevelUpsertWithWhereUniqueWithoutDrugInput[]
    createMany?: BufferLevelCreateManyDrugInputEnvelope
    set?: BufferLevelWhereUniqueInput | BufferLevelWhereUniqueInput[]
    disconnect?: BufferLevelWhereUniqueInput | BufferLevelWhereUniqueInput[]
    delete?: BufferLevelWhereUniqueInput | BufferLevelWhereUniqueInput[]
    connect?: BufferLevelWhereUniqueInput | BufferLevelWhereUniqueInput[]
    update?: BufferLevelUpdateWithWhereUniqueWithoutDrugInput | BufferLevelUpdateWithWhereUniqueWithoutDrugInput[]
    updateMany?: BufferLevelUpdateManyWithWhereWithoutDrugInput | BufferLevelUpdateManyWithWhereWithoutDrugInput[]
    deleteMany?: BufferLevelScalarWhereInput | BufferLevelScalarWhereInput[]
  }

  export type BatchUncheckedUpdateManyWithoutDrugNestedInput = {
    create?: XOR<BatchCreateWithoutDrugInput, BatchUncheckedCreateWithoutDrugInput> | BatchCreateWithoutDrugInput[] | BatchUncheckedCreateWithoutDrugInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutDrugInput | BatchCreateOrConnectWithoutDrugInput[]
    upsert?: BatchUpsertWithWhereUniqueWithoutDrugInput | BatchUpsertWithWhereUniqueWithoutDrugInput[]
    createMany?: BatchCreateManyDrugInputEnvelope
    set?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    disconnect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    delete?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    update?: BatchUpdateWithWhereUniqueWithoutDrugInput | BatchUpdateWithWhereUniqueWithoutDrugInput[]
    updateMany?: BatchUpdateManyWithWhereWithoutDrugInput | BatchUpdateManyWithWhereWithoutDrugInput[]
    deleteMany?: BatchScalarWhereInput | BatchScalarWhereInput[]
  }

  export type BatchHistoryUncheckedUpdateManyWithoutDrugNestedInput = {
    create?: XOR<BatchHistoryCreateWithoutDrugInput, BatchHistoryUncheckedCreateWithoutDrugInput> | BatchHistoryCreateWithoutDrugInput[] | BatchHistoryUncheckedCreateWithoutDrugInput[]
    connectOrCreate?: BatchHistoryCreateOrConnectWithoutDrugInput | BatchHistoryCreateOrConnectWithoutDrugInput[]
    upsert?: BatchHistoryUpsertWithWhereUniqueWithoutDrugInput | BatchHistoryUpsertWithWhereUniqueWithoutDrugInput[]
    createMany?: BatchHistoryCreateManyDrugInputEnvelope
    set?: BatchHistoryWhereUniqueInput | BatchHistoryWhereUniqueInput[]
    disconnect?: BatchHistoryWhereUniqueInput | BatchHistoryWhereUniqueInput[]
    delete?: BatchHistoryWhereUniqueInput | BatchHistoryWhereUniqueInput[]
    connect?: BatchHistoryWhereUniqueInput | BatchHistoryWhereUniqueInput[]
    update?: BatchHistoryUpdateWithWhereUniqueWithoutDrugInput | BatchHistoryUpdateWithWhereUniqueWithoutDrugInput[]
    updateMany?: BatchHistoryUpdateManyWithWhereWithoutDrugInput | BatchHistoryUpdateManyWithWhereWithoutDrugInput[]
    deleteMany?: BatchHistoryScalarWhereInput | BatchHistoryScalarWhereInput[]
  }

  export type IssueUncheckedUpdateManyWithoutDrugNestedInput = {
    create?: XOR<IssueCreateWithoutDrugInput, IssueUncheckedCreateWithoutDrugInput> | IssueCreateWithoutDrugInput[] | IssueUncheckedCreateWithoutDrugInput[]
    connectOrCreate?: IssueCreateOrConnectWithoutDrugInput | IssueCreateOrConnectWithoutDrugInput[]
    upsert?: IssueUpsertWithWhereUniqueWithoutDrugInput | IssueUpsertWithWhereUniqueWithoutDrugInput[]
    createMany?: IssueCreateManyDrugInputEnvelope
    set?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    disconnect?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    delete?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    connect?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    update?: IssueUpdateWithWhereUniqueWithoutDrugInput | IssueUpdateWithWhereUniqueWithoutDrugInput[]
    updateMany?: IssueUpdateManyWithWhereWithoutDrugInput | IssueUpdateManyWithWhereWithoutDrugInput[]
    deleteMany?: IssueScalarWhereInput | IssueScalarWhereInput[]
  }

  export type StratergyHistoryUncheckedUpdateOneWithoutDrugNestedInput = {
    create?: XOR<StratergyHistoryCreateWithoutDrugInput, StratergyHistoryUncheckedCreateWithoutDrugInput>
    connectOrCreate?: StratergyHistoryCreateOrConnectWithoutDrugInput
    upsert?: StratergyHistoryUpsertWithoutDrugInput
    disconnect?: StratergyHistoryWhereInput | boolean
    delete?: StratergyHistoryWhereInput | boolean
    connect?: StratergyHistoryWhereUniqueInput
    update?: XOR<XOR<StratergyHistoryUpdateToOneWithWhereWithoutDrugInput, StratergyHistoryUpdateWithoutDrugInput>, StratergyHistoryUncheckedUpdateWithoutDrugInput>
  }

  export type BufferLevelUncheckedUpdateManyWithoutDrugNestedInput = {
    create?: XOR<BufferLevelCreateWithoutDrugInput, BufferLevelUncheckedCreateWithoutDrugInput> | BufferLevelCreateWithoutDrugInput[] | BufferLevelUncheckedCreateWithoutDrugInput[]
    connectOrCreate?: BufferLevelCreateOrConnectWithoutDrugInput | BufferLevelCreateOrConnectWithoutDrugInput[]
    upsert?: BufferLevelUpsertWithWhereUniqueWithoutDrugInput | BufferLevelUpsertWithWhereUniqueWithoutDrugInput[]
    createMany?: BufferLevelCreateManyDrugInputEnvelope
    set?: BufferLevelWhereUniqueInput | BufferLevelWhereUniqueInput[]
    disconnect?: BufferLevelWhereUniqueInput | BufferLevelWhereUniqueInput[]
    delete?: BufferLevelWhereUniqueInput | BufferLevelWhereUniqueInput[]
    connect?: BufferLevelWhereUniqueInput | BufferLevelWhereUniqueInput[]
    update?: BufferLevelUpdateWithWhereUniqueWithoutDrugInput | BufferLevelUpdateWithWhereUniqueWithoutDrugInput[]
    updateMany?: BufferLevelUpdateManyWithWhereWithoutDrugInput | BufferLevelUpdateManyWithWhereWithoutDrugInput[]
    deleteMany?: BufferLevelScalarWhereInput | BufferLevelScalarWhereInput[]
  }

  export type DrugCreateNestedOneWithoutBufferLevelsInput = {
    create?: XOR<DrugCreateWithoutBufferLevelsInput, DrugUncheckedCreateWithoutBufferLevelsInput>
    connectOrCreate?: DrugCreateOrConnectWithoutBufferLevelsInput
    connect?: DrugWhereUniqueInput
  }

  export type UnitConcentrationCreateNestedOneWithoutBufferLevelInput = {
    create?: XOR<UnitConcentrationCreateWithoutBufferLevelInput, UnitConcentrationUncheckedCreateWithoutBufferLevelInput>
    connectOrCreate?: UnitConcentrationCreateOrConnectWithoutBufferLevelInput
    connect?: UnitConcentrationWhereUniqueInput
  }

  export type EnumDrugTypeFieldUpdateOperationsInput = {
    set?: $Enums.DrugType
  }

  export type DrugUpdateOneRequiredWithoutBufferLevelsNestedInput = {
    create?: XOR<DrugCreateWithoutBufferLevelsInput, DrugUncheckedCreateWithoutBufferLevelsInput>
    connectOrCreate?: DrugCreateOrConnectWithoutBufferLevelsInput
    upsert?: DrugUpsertWithoutBufferLevelsInput
    connect?: DrugWhereUniqueInput
    update?: XOR<XOR<DrugUpdateToOneWithWhereWithoutBufferLevelsInput, DrugUpdateWithoutBufferLevelsInput>, DrugUncheckedUpdateWithoutBufferLevelsInput>
  }

  export type UnitConcentrationUpdateOneRequiredWithoutBufferLevelNestedInput = {
    create?: XOR<UnitConcentrationCreateWithoutBufferLevelInput, UnitConcentrationUncheckedCreateWithoutBufferLevelInput>
    connectOrCreate?: UnitConcentrationCreateOrConnectWithoutBufferLevelInput
    upsert?: UnitConcentrationUpsertWithoutBufferLevelInput
    connect?: UnitConcentrationWhereUniqueInput
    update?: XOR<XOR<UnitConcentrationUpdateToOneWithWhereWithoutBufferLevelInput, UnitConcentrationUpdateWithoutBufferLevelInput>, UnitConcentrationUncheckedUpdateWithoutBufferLevelInput>
  }

  export type BatchCreateNestedManyWithoutSupplierInput = {
    create?: XOR<BatchCreateWithoutSupplierInput, BatchUncheckedCreateWithoutSupplierInput> | BatchCreateWithoutSupplierInput[] | BatchUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutSupplierInput | BatchCreateOrConnectWithoutSupplierInput[]
    createMany?: BatchCreateManySupplierInputEnvelope
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
  }

  export type BatchUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<BatchCreateWithoutSupplierInput, BatchUncheckedCreateWithoutSupplierInput> | BatchCreateWithoutSupplierInput[] | BatchUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutSupplierInput | BatchCreateOrConnectWithoutSupplierInput[]
    createMany?: BatchCreateManySupplierInputEnvelope
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
  }

  export type BatchUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<BatchCreateWithoutSupplierInput, BatchUncheckedCreateWithoutSupplierInput> | BatchCreateWithoutSupplierInput[] | BatchUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutSupplierInput | BatchCreateOrConnectWithoutSupplierInput[]
    upsert?: BatchUpsertWithWhereUniqueWithoutSupplierInput | BatchUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: BatchCreateManySupplierInputEnvelope
    set?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    disconnect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    delete?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    update?: BatchUpdateWithWhereUniqueWithoutSupplierInput | BatchUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: BatchUpdateManyWithWhereWithoutSupplierInput | BatchUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: BatchScalarWhereInput | BatchScalarWhereInput[]
  }

  export type BatchUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<BatchCreateWithoutSupplierInput, BatchUncheckedCreateWithoutSupplierInput> | BatchCreateWithoutSupplierInput[] | BatchUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutSupplierInput | BatchCreateOrConnectWithoutSupplierInput[]
    upsert?: BatchUpsertWithWhereUniqueWithoutSupplierInput | BatchUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: BatchCreateManySupplierInputEnvelope
    set?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    disconnect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    delete?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    update?: BatchUpdateWithWhereUniqueWithoutSupplierInput | BatchUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: BatchUpdateManyWithWhereWithoutSupplierInput | BatchUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: BatchScalarWhereInput | BatchScalarWhereInput[]
  }

  export type DrugBrandCreateNestedOneWithoutBatchInput = {
    create?: XOR<DrugBrandCreateWithoutBatchInput, DrugBrandUncheckedCreateWithoutBatchInput>
    connectOrCreate?: DrugBrandCreateOrConnectWithoutBatchInput
    connect?: DrugBrandWhereUniqueInput
  }

  export type DrugCreateNestedOneWithoutBatchInput = {
    create?: XOR<DrugCreateWithoutBatchInput, DrugUncheckedCreateWithoutBatchInput>
    connectOrCreate?: DrugCreateOrConnectWithoutBatchInput
    connect?: DrugWhereUniqueInput
  }

  export type SupplierCreateNestedOneWithoutBatchesInput = {
    create?: XOR<SupplierCreateWithoutBatchesInput, SupplierUncheckedCreateWithoutBatchesInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutBatchesInput
    connect?: SupplierWhereUniqueInput
  }

  export type UnitConcentrationCreateNestedOneWithoutBatchInput = {
    create?: XOR<UnitConcentrationCreateWithoutBatchInput, UnitConcentrationUncheckedCreateWithoutBatchInput>
    connectOrCreate?: UnitConcentrationCreateOrConnectWithoutBatchInput
    connect?: UnitConcentrationWhereUniqueInput
  }

  export type BatchHistoryCreateNestedManyWithoutBatchInput = {
    create?: XOR<BatchHistoryCreateWithoutBatchInput, BatchHistoryUncheckedCreateWithoutBatchInput> | BatchHistoryCreateWithoutBatchInput[] | BatchHistoryUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: BatchHistoryCreateOrConnectWithoutBatchInput | BatchHistoryCreateOrConnectWithoutBatchInput[]
    createMany?: BatchHistoryCreateManyBatchInputEnvelope
    connect?: BatchHistoryWhereUniqueInput | BatchHistoryWhereUniqueInput[]
  }

  export type IssueCreateNestedManyWithoutBatchInput = {
    create?: XOR<IssueCreateWithoutBatchInput, IssueUncheckedCreateWithoutBatchInput> | IssueCreateWithoutBatchInput[] | IssueUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: IssueCreateOrConnectWithoutBatchInput | IssueCreateOrConnectWithoutBatchInput[]
    createMany?: IssueCreateManyBatchInputEnvelope
    connect?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
  }

  export type BatchHistoryUncheckedCreateNestedManyWithoutBatchInput = {
    create?: XOR<BatchHistoryCreateWithoutBatchInput, BatchHistoryUncheckedCreateWithoutBatchInput> | BatchHistoryCreateWithoutBatchInput[] | BatchHistoryUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: BatchHistoryCreateOrConnectWithoutBatchInput | BatchHistoryCreateOrConnectWithoutBatchInput[]
    createMany?: BatchHistoryCreateManyBatchInputEnvelope
    connect?: BatchHistoryWhereUniqueInput | BatchHistoryWhereUniqueInput[]
  }

  export type IssueUncheckedCreateNestedManyWithoutBatchInput = {
    create?: XOR<IssueCreateWithoutBatchInput, IssueUncheckedCreateWithoutBatchInput> | IssueCreateWithoutBatchInput[] | IssueUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: IssueCreateOrConnectWithoutBatchInput | IssueCreateOrConnectWithoutBatchInput[]
    createMany?: IssueCreateManyBatchInputEnvelope
    connect?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumBatchStatusFieldUpdateOperationsInput = {
    set?: $Enums.BatchStatus
  }

  export type DrugBrandUpdateOneRequiredWithoutBatchNestedInput = {
    create?: XOR<DrugBrandCreateWithoutBatchInput, DrugBrandUncheckedCreateWithoutBatchInput>
    connectOrCreate?: DrugBrandCreateOrConnectWithoutBatchInput
    upsert?: DrugBrandUpsertWithoutBatchInput
    connect?: DrugBrandWhereUniqueInput
    update?: XOR<XOR<DrugBrandUpdateToOneWithWhereWithoutBatchInput, DrugBrandUpdateWithoutBatchInput>, DrugBrandUncheckedUpdateWithoutBatchInput>
  }

  export type DrugUpdateOneRequiredWithoutBatchNestedInput = {
    create?: XOR<DrugCreateWithoutBatchInput, DrugUncheckedCreateWithoutBatchInput>
    connectOrCreate?: DrugCreateOrConnectWithoutBatchInput
    upsert?: DrugUpsertWithoutBatchInput
    connect?: DrugWhereUniqueInput
    update?: XOR<XOR<DrugUpdateToOneWithWhereWithoutBatchInput, DrugUpdateWithoutBatchInput>, DrugUncheckedUpdateWithoutBatchInput>
  }

  export type SupplierUpdateOneRequiredWithoutBatchesNestedInput = {
    create?: XOR<SupplierCreateWithoutBatchesInput, SupplierUncheckedCreateWithoutBatchesInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutBatchesInput
    upsert?: SupplierUpsertWithoutBatchesInput
    connect?: SupplierWhereUniqueInput
    update?: XOR<XOR<SupplierUpdateToOneWithWhereWithoutBatchesInput, SupplierUpdateWithoutBatchesInput>, SupplierUncheckedUpdateWithoutBatchesInput>
  }

  export type UnitConcentrationUpdateOneRequiredWithoutBatchNestedInput = {
    create?: XOR<UnitConcentrationCreateWithoutBatchInput, UnitConcentrationUncheckedCreateWithoutBatchInput>
    connectOrCreate?: UnitConcentrationCreateOrConnectWithoutBatchInput
    upsert?: UnitConcentrationUpsertWithoutBatchInput
    connect?: UnitConcentrationWhereUniqueInput
    update?: XOR<XOR<UnitConcentrationUpdateToOneWithWhereWithoutBatchInput, UnitConcentrationUpdateWithoutBatchInput>, UnitConcentrationUncheckedUpdateWithoutBatchInput>
  }

  export type BatchHistoryUpdateManyWithoutBatchNestedInput = {
    create?: XOR<BatchHistoryCreateWithoutBatchInput, BatchHistoryUncheckedCreateWithoutBatchInput> | BatchHistoryCreateWithoutBatchInput[] | BatchHistoryUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: BatchHistoryCreateOrConnectWithoutBatchInput | BatchHistoryCreateOrConnectWithoutBatchInput[]
    upsert?: BatchHistoryUpsertWithWhereUniqueWithoutBatchInput | BatchHistoryUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: BatchHistoryCreateManyBatchInputEnvelope
    set?: BatchHistoryWhereUniqueInput | BatchHistoryWhereUniqueInput[]
    disconnect?: BatchHistoryWhereUniqueInput | BatchHistoryWhereUniqueInput[]
    delete?: BatchHistoryWhereUniqueInput | BatchHistoryWhereUniqueInput[]
    connect?: BatchHistoryWhereUniqueInput | BatchHistoryWhereUniqueInput[]
    update?: BatchHistoryUpdateWithWhereUniqueWithoutBatchInput | BatchHistoryUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: BatchHistoryUpdateManyWithWhereWithoutBatchInput | BatchHistoryUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: BatchHistoryScalarWhereInput | BatchHistoryScalarWhereInput[]
  }

  export type IssueUpdateManyWithoutBatchNestedInput = {
    create?: XOR<IssueCreateWithoutBatchInput, IssueUncheckedCreateWithoutBatchInput> | IssueCreateWithoutBatchInput[] | IssueUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: IssueCreateOrConnectWithoutBatchInput | IssueCreateOrConnectWithoutBatchInput[]
    upsert?: IssueUpsertWithWhereUniqueWithoutBatchInput | IssueUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: IssueCreateManyBatchInputEnvelope
    set?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    disconnect?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    delete?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    connect?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    update?: IssueUpdateWithWhereUniqueWithoutBatchInput | IssueUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: IssueUpdateManyWithWhereWithoutBatchInput | IssueUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: IssueScalarWhereInput | IssueScalarWhereInput[]
  }

  export type BatchHistoryUncheckedUpdateManyWithoutBatchNestedInput = {
    create?: XOR<BatchHistoryCreateWithoutBatchInput, BatchHistoryUncheckedCreateWithoutBatchInput> | BatchHistoryCreateWithoutBatchInput[] | BatchHistoryUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: BatchHistoryCreateOrConnectWithoutBatchInput | BatchHistoryCreateOrConnectWithoutBatchInput[]
    upsert?: BatchHistoryUpsertWithWhereUniqueWithoutBatchInput | BatchHistoryUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: BatchHistoryCreateManyBatchInputEnvelope
    set?: BatchHistoryWhereUniqueInput | BatchHistoryWhereUniqueInput[]
    disconnect?: BatchHistoryWhereUniqueInput | BatchHistoryWhereUniqueInput[]
    delete?: BatchHistoryWhereUniqueInput | BatchHistoryWhereUniqueInput[]
    connect?: BatchHistoryWhereUniqueInput | BatchHistoryWhereUniqueInput[]
    update?: BatchHistoryUpdateWithWhereUniqueWithoutBatchInput | BatchHistoryUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: BatchHistoryUpdateManyWithWhereWithoutBatchInput | BatchHistoryUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: BatchHistoryScalarWhereInput | BatchHistoryScalarWhereInput[]
  }

  export type IssueUncheckedUpdateManyWithoutBatchNestedInput = {
    create?: XOR<IssueCreateWithoutBatchInput, IssueUncheckedCreateWithoutBatchInput> | IssueCreateWithoutBatchInput[] | IssueUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: IssueCreateOrConnectWithoutBatchInput | IssueCreateOrConnectWithoutBatchInput[]
    upsert?: IssueUpsertWithWhereUniqueWithoutBatchInput | IssueUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: IssueCreateManyBatchInputEnvelope
    set?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    disconnect?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    delete?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    connect?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    update?: IssueUpdateWithWhereUniqueWithoutBatchInput | IssueUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: IssueUpdateManyWithWhereWithoutBatchInput | IssueUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: IssueScalarWhereInput | IssueScalarWhereInput[]
  }

  export type BatchCreateNestedManyWithoutUnitConcentrationInput = {
    create?: XOR<BatchCreateWithoutUnitConcentrationInput, BatchUncheckedCreateWithoutUnitConcentrationInput> | BatchCreateWithoutUnitConcentrationInput[] | BatchUncheckedCreateWithoutUnitConcentrationInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutUnitConcentrationInput | BatchCreateOrConnectWithoutUnitConcentrationInput[]
    createMany?: BatchCreateManyUnitConcentrationInputEnvelope
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
  }

  export type BatchHistoryCreateNestedManyWithoutUnitConcentrationInput = {
    create?: XOR<BatchHistoryCreateWithoutUnitConcentrationInput, BatchHistoryUncheckedCreateWithoutUnitConcentrationInput> | BatchHistoryCreateWithoutUnitConcentrationInput[] | BatchHistoryUncheckedCreateWithoutUnitConcentrationInput[]
    connectOrCreate?: BatchHistoryCreateOrConnectWithoutUnitConcentrationInput | BatchHistoryCreateOrConnectWithoutUnitConcentrationInput[]
    createMany?: BatchHistoryCreateManyUnitConcentrationInputEnvelope
    connect?: BatchHistoryWhereUniqueInput | BatchHistoryWhereUniqueInput[]
  }

  export type IssueCreateNestedManyWithoutUnitConcentrationInput = {
    create?: XOR<IssueCreateWithoutUnitConcentrationInput, IssueUncheckedCreateWithoutUnitConcentrationInput> | IssueCreateWithoutUnitConcentrationInput[] | IssueUncheckedCreateWithoutUnitConcentrationInput[]
    connectOrCreate?: IssueCreateOrConnectWithoutUnitConcentrationInput | IssueCreateOrConnectWithoutUnitConcentrationInput[]
    createMany?: IssueCreateManyUnitConcentrationInputEnvelope
    connect?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
  }

  export type BufferLevelCreateNestedManyWithoutUnitConcentrationInput = {
    create?: XOR<BufferLevelCreateWithoutUnitConcentrationInput, BufferLevelUncheckedCreateWithoutUnitConcentrationInput> | BufferLevelCreateWithoutUnitConcentrationInput[] | BufferLevelUncheckedCreateWithoutUnitConcentrationInput[]
    connectOrCreate?: BufferLevelCreateOrConnectWithoutUnitConcentrationInput | BufferLevelCreateOrConnectWithoutUnitConcentrationInput[]
    createMany?: BufferLevelCreateManyUnitConcentrationInputEnvelope
    connect?: BufferLevelWhereUniqueInput | BufferLevelWhereUniqueInput[]
  }

  export type BatchUncheckedCreateNestedManyWithoutUnitConcentrationInput = {
    create?: XOR<BatchCreateWithoutUnitConcentrationInput, BatchUncheckedCreateWithoutUnitConcentrationInput> | BatchCreateWithoutUnitConcentrationInput[] | BatchUncheckedCreateWithoutUnitConcentrationInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutUnitConcentrationInput | BatchCreateOrConnectWithoutUnitConcentrationInput[]
    createMany?: BatchCreateManyUnitConcentrationInputEnvelope
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
  }

  export type BatchHistoryUncheckedCreateNestedManyWithoutUnitConcentrationInput = {
    create?: XOR<BatchHistoryCreateWithoutUnitConcentrationInput, BatchHistoryUncheckedCreateWithoutUnitConcentrationInput> | BatchHistoryCreateWithoutUnitConcentrationInput[] | BatchHistoryUncheckedCreateWithoutUnitConcentrationInput[]
    connectOrCreate?: BatchHistoryCreateOrConnectWithoutUnitConcentrationInput | BatchHistoryCreateOrConnectWithoutUnitConcentrationInput[]
    createMany?: BatchHistoryCreateManyUnitConcentrationInputEnvelope
    connect?: BatchHistoryWhereUniqueInput | BatchHistoryWhereUniqueInput[]
  }

  export type IssueUncheckedCreateNestedManyWithoutUnitConcentrationInput = {
    create?: XOR<IssueCreateWithoutUnitConcentrationInput, IssueUncheckedCreateWithoutUnitConcentrationInput> | IssueCreateWithoutUnitConcentrationInput[] | IssueUncheckedCreateWithoutUnitConcentrationInput[]
    connectOrCreate?: IssueCreateOrConnectWithoutUnitConcentrationInput | IssueCreateOrConnectWithoutUnitConcentrationInput[]
    createMany?: IssueCreateManyUnitConcentrationInputEnvelope
    connect?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
  }

  export type BufferLevelUncheckedCreateNestedManyWithoutUnitConcentrationInput = {
    create?: XOR<BufferLevelCreateWithoutUnitConcentrationInput, BufferLevelUncheckedCreateWithoutUnitConcentrationInput> | BufferLevelCreateWithoutUnitConcentrationInput[] | BufferLevelUncheckedCreateWithoutUnitConcentrationInput[]
    connectOrCreate?: BufferLevelCreateOrConnectWithoutUnitConcentrationInput | BufferLevelCreateOrConnectWithoutUnitConcentrationInput[]
    createMany?: BufferLevelCreateManyUnitConcentrationInputEnvelope
    connect?: BufferLevelWhereUniqueInput | BufferLevelWhereUniqueInput[]
  }

  export type BatchUpdateManyWithoutUnitConcentrationNestedInput = {
    create?: XOR<BatchCreateWithoutUnitConcentrationInput, BatchUncheckedCreateWithoutUnitConcentrationInput> | BatchCreateWithoutUnitConcentrationInput[] | BatchUncheckedCreateWithoutUnitConcentrationInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutUnitConcentrationInput | BatchCreateOrConnectWithoutUnitConcentrationInput[]
    upsert?: BatchUpsertWithWhereUniqueWithoutUnitConcentrationInput | BatchUpsertWithWhereUniqueWithoutUnitConcentrationInput[]
    createMany?: BatchCreateManyUnitConcentrationInputEnvelope
    set?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    disconnect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    delete?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    update?: BatchUpdateWithWhereUniqueWithoutUnitConcentrationInput | BatchUpdateWithWhereUniqueWithoutUnitConcentrationInput[]
    updateMany?: BatchUpdateManyWithWhereWithoutUnitConcentrationInput | BatchUpdateManyWithWhereWithoutUnitConcentrationInput[]
    deleteMany?: BatchScalarWhereInput | BatchScalarWhereInput[]
  }

  export type BatchHistoryUpdateManyWithoutUnitConcentrationNestedInput = {
    create?: XOR<BatchHistoryCreateWithoutUnitConcentrationInput, BatchHistoryUncheckedCreateWithoutUnitConcentrationInput> | BatchHistoryCreateWithoutUnitConcentrationInput[] | BatchHistoryUncheckedCreateWithoutUnitConcentrationInput[]
    connectOrCreate?: BatchHistoryCreateOrConnectWithoutUnitConcentrationInput | BatchHistoryCreateOrConnectWithoutUnitConcentrationInput[]
    upsert?: BatchHistoryUpsertWithWhereUniqueWithoutUnitConcentrationInput | BatchHistoryUpsertWithWhereUniqueWithoutUnitConcentrationInput[]
    createMany?: BatchHistoryCreateManyUnitConcentrationInputEnvelope
    set?: BatchHistoryWhereUniqueInput | BatchHistoryWhereUniqueInput[]
    disconnect?: BatchHistoryWhereUniqueInput | BatchHistoryWhereUniqueInput[]
    delete?: BatchHistoryWhereUniqueInput | BatchHistoryWhereUniqueInput[]
    connect?: BatchHistoryWhereUniqueInput | BatchHistoryWhereUniqueInput[]
    update?: BatchHistoryUpdateWithWhereUniqueWithoutUnitConcentrationInput | BatchHistoryUpdateWithWhereUniqueWithoutUnitConcentrationInput[]
    updateMany?: BatchHistoryUpdateManyWithWhereWithoutUnitConcentrationInput | BatchHistoryUpdateManyWithWhereWithoutUnitConcentrationInput[]
    deleteMany?: BatchHistoryScalarWhereInput | BatchHistoryScalarWhereInput[]
  }

  export type IssueUpdateManyWithoutUnitConcentrationNestedInput = {
    create?: XOR<IssueCreateWithoutUnitConcentrationInput, IssueUncheckedCreateWithoutUnitConcentrationInput> | IssueCreateWithoutUnitConcentrationInput[] | IssueUncheckedCreateWithoutUnitConcentrationInput[]
    connectOrCreate?: IssueCreateOrConnectWithoutUnitConcentrationInput | IssueCreateOrConnectWithoutUnitConcentrationInput[]
    upsert?: IssueUpsertWithWhereUniqueWithoutUnitConcentrationInput | IssueUpsertWithWhereUniqueWithoutUnitConcentrationInput[]
    createMany?: IssueCreateManyUnitConcentrationInputEnvelope
    set?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    disconnect?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    delete?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    connect?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    update?: IssueUpdateWithWhereUniqueWithoutUnitConcentrationInput | IssueUpdateWithWhereUniqueWithoutUnitConcentrationInput[]
    updateMany?: IssueUpdateManyWithWhereWithoutUnitConcentrationInput | IssueUpdateManyWithWhereWithoutUnitConcentrationInput[]
    deleteMany?: IssueScalarWhereInput | IssueScalarWhereInput[]
  }

  export type BufferLevelUpdateManyWithoutUnitConcentrationNestedInput = {
    create?: XOR<BufferLevelCreateWithoutUnitConcentrationInput, BufferLevelUncheckedCreateWithoutUnitConcentrationInput> | BufferLevelCreateWithoutUnitConcentrationInput[] | BufferLevelUncheckedCreateWithoutUnitConcentrationInput[]
    connectOrCreate?: BufferLevelCreateOrConnectWithoutUnitConcentrationInput | BufferLevelCreateOrConnectWithoutUnitConcentrationInput[]
    upsert?: BufferLevelUpsertWithWhereUniqueWithoutUnitConcentrationInput | BufferLevelUpsertWithWhereUniqueWithoutUnitConcentrationInput[]
    createMany?: BufferLevelCreateManyUnitConcentrationInputEnvelope
    set?: BufferLevelWhereUniqueInput | BufferLevelWhereUniqueInput[]
    disconnect?: BufferLevelWhereUniqueInput | BufferLevelWhereUniqueInput[]
    delete?: BufferLevelWhereUniqueInput | BufferLevelWhereUniqueInput[]
    connect?: BufferLevelWhereUniqueInput | BufferLevelWhereUniqueInput[]
    update?: BufferLevelUpdateWithWhereUniqueWithoutUnitConcentrationInput | BufferLevelUpdateWithWhereUniqueWithoutUnitConcentrationInput[]
    updateMany?: BufferLevelUpdateManyWithWhereWithoutUnitConcentrationInput | BufferLevelUpdateManyWithWhereWithoutUnitConcentrationInput[]
    deleteMany?: BufferLevelScalarWhereInput | BufferLevelScalarWhereInput[]
  }

  export type BatchUncheckedUpdateManyWithoutUnitConcentrationNestedInput = {
    create?: XOR<BatchCreateWithoutUnitConcentrationInput, BatchUncheckedCreateWithoutUnitConcentrationInput> | BatchCreateWithoutUnitConcentrationInput[] | BatchUncheckedCreateWithoutUnitConcentrationInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutUnitConcentrationInput | BatchCreateOrConnectWithoutUnitConcentrationInput[]
    upsert?: BatchUpsertWithWhereUniqueWithoutUnitConcentrationInput | BatchUpsertWithWhereUniqueWithoutUnitConcentrationInput[]
    createMany?: BatchCreateManyUnitConcentrationInputEnvelope
    set?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    disconnect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    delete?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    update?: BatchUpdateWithWhereUniqueWithoutUnitConcentrationInput | BatchUpdateWithWhereUniqueWithoutUnitConcentrationInput[]
    updateMany?: BatchUpdateManyWithWhereWithoutUnitConcentrationInput | BatchUpdateManyWithWhereWithoutUnitConcentrationInput[]
    deleteMany?: BatchScalarWhereInput | BatchScalarWhereInput[]
  }

  export type BatchHistoryUncheckedUpdateManyWithoutUnitConcentrationNestedInput = {
    create?: XOR<BatchHistoryCreateWithoutUnitConcentrationInput, BatchHistoryUncheckedCreateWithoutUnitConcentrationInput> | BatchHistoryCreateWithoutUnitConcentrationInput[] | BatchHistoryUncheckedCreateWithoutUnitConcentrationInput[]
    connectOrCreate?: BatchHistoryCreateOrConnectWithoutUnitConcentrationInput | BatchHistoryCreateOrConnectWithoutUnitConcentrationInput[]
    upsert?: BatchHistoryUpsertWithWhereUniqueWithoutUnitConcentrationInput | BatchHistoryUpsertWithWhereUniqueWithoutUnitConcentrationInput[]
    createMany?: BatchHistoryCreateManyUnitConcentrationInputEnvelope
    set?: BatchHistoryWhereUniqueInput | BatchHistoryWhereUniqueInput[]
    disconnect?: BatchHistoryWhereUniqueInput | BatchHistoryWhereUniqueInput[]
    delete?: BatchHistoryWhereUniqueInput | BatchHistoryWhereUniqueInput[]
    connect?: BatchHistoryWhereUniqueInput | BatchHistoryWhereUniqueInput[]
    update?: BatchHistoryUpdateWithWhereUniqueWithoutUnitConcentrationInput | BatchHistoryUpdateWithWhereUniqueWithoutUnitConcentrationInput[]
    updateMany?: BatchHistoryUpdateManyWithWhereWithoutUnitConcentrationInput | BatchHistoryUpdateManyWithWhereWithoutUnitConcentrationInput[]
    deleteMany?: BatchHistoryScalarWhereInput | BatchHistoryScalarWhereInput[]
  }

  export type IssueUncheckedUpdateManyWithoutUnitConcentrationNestedInput = {
    create?: XOR<IssueCreateWithoutUnitConcentrationInput, IssueUncheckedCreateWithoutUnitConcentrationInput> | IssueCreateWithoutUnitConcentrationInput[] | IssueUncheckedCreateWithoutUnitConcentrationInput[]
    connectOrCreate?: IssueCreateOrConnectWithoutUnitConcentrationInput | IssueCreateOrConnectWithoutUnitConcentrationInput[]
    upsert?: IssueUpsertWithWhereUniqueWithoutUnitConcentrationInput | IssueUpsertWithWhereUniqueWithoutUnitConcentrationInput[]
    createMany?: IssueCreateManyUnitConcentrationInputEnvelope
    set?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    disconnect?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    delete?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    connect?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    update?: IssueUpdateWithWhereUniqueWithoutUnitConcentrationInput | IssueUpdateWithWhereUniqueWithoutUnitConcentrationInput[]
    updateMany?: IssueUpdateManyWithWhereWithoutUnitConcentrationInput | IssueUpdateManyWithWhereWithoutUnitConcentrationInput[]
    deleteMany?: IssueScalarWhereInput | IssueScalarWhereInput[]
  }

  export type BufferLevelUncheckedUpdateManyWithoutUnitConcentrationNestedInput = {
    create?: XOR<BufferLevelCreateWithoutUnitConcentrationInput, BufferLevelUncheckedCreateWithoutUnitConcentrationInput> | BufferLevelCreateWithoutUnitConcentrationInput[] | BufferLevelUncheckedCreateWithoutUnitConcentrationInput[]
    connectOrCreate?: BufferLevelCreateOrConnectWithoutUnitConcentrationInput | BufferLevelCreateOrConnectWithoutUnitConcentrationInput[]
    upsert?: BufferLevelUpsertWithWhereUniqueWithoutUnitConcentrationInput | BufferLevelUpsertWithWhereUniqueWithoutUnitConcentrationInput[]
    createMany?: BufferLevelCreateManyUnitConcentrationInputEnvelope
    set?: BufferLevelWhereUniqueInput | BufferLevelWhereUniqueInput[]
    disconnect?: BufferLevelWhereUniqueInput | BufferLevelWhereUniqueInput[]
    delete?: BufferLevelWhereUniqueInput | BufferLevelWhereUniqueInput[]
    connect?: BufferLevelWhereUniqueInput | BufferLevelWhereUniqueInput[]
    update?: BufferLevelUpdateWithWhereUniqueWithoutUnitConcentrationInput | BufferLevelUpdateWithWhereUniqueWithoutUnitConcentrationInput[]
    updateMany?: BufferLevelUpdateManyWithWhereWithoutUnitConcentrationInput | BufferLevelUpdateManyWithWhereWithoutUnitConcentrationInput[]
    deleteMany?: BufferLevelScalarWhereInput | BufferLevelScalarWhereInput[]
  }

  export type IssueCreateNestedManyWithoutPrescriptionInput = {
    create?: XOR<IssueCreateWithoutPrescriptionInput, IssueUncheckedCreateWithoutPrescriptionInput> | IssueCreateWithoutPrescriptionInput[] | IssueUncheckedCreateWithoutPrescriptionInput[]
    connectOrCreate?: IssueCreateOrConnectWithoutPrescriptionInput | IssueCreateOrConnectWithoutPrescriptionInput[]
    createMany?: IssueCreateManyPrescriptionInputEnvelope
    connect?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
  }

  export type OffRecordMedsCreateNestedManyWithoutPrescriptionInput = {
    create?: XOR<OffRecordMedsCreateWithoutPrescriptionInput, OffRecordMedsUncheckedCreateWithoutPrescriptionInput> | OffRecordMedsCreateWithoutPrescriptionInput[] | OffRecordMedsUncheckedCreateWithoutPrescriptionInput[]
    connectOrCreate?: OffRecordMedsCreateOrConnectWithoutPrescriptionInput | OffRecordMedsCreateOrConnectWithoutPrescriptionInput[]
    createMany?: OffRecordMedsCreateManyPrescriptionInputEnvelope
    connect?: OffRecordMedsWhereUniqueInput | OffRecordMedsWhereUniqueInput[]
  }

  export type PatientCreateNestedOneWithoutPrescriptionInput = {
    create?: XOR<PatientCreateWithoutPrescriptionInput, PatientUncheckedCreateWithoutPrescriptionInput>
    connectOrCreate?: PatientCreateOrConnectWithoutPrescriptionInput
    connect?: PatientWhereUniqueInput
  }

  export type PrescriptionVitalsCreateNestedManyWithoutPrescriptionInput = {
    create?: XOR<PrescriptionVitalsCreateWithoutPrescriptionInput, PrescriptionVitalsUncheckedCreateWithoutPrescriptionInput> | PrescriptionVitalsCreateWithoutPrescriptionInput[] | PrescriptionVitalsUncheckedCreateWithoutPrescriptionInput[]
    connectOrCreate?: PrescriptionVitalsCreateOrConnectWithoutPrescriptionInput | PrescriptionVitalsCreateOrConnectWithoutPrescriptionInput[]
    createMany?: PrescriptionVitalsCreateManyPrescriptionInputEnvelope
    connect?: PrescriptionVitalsWhereUniqueInput | PrescriptionVitalsWhereUniqueInput[]
  }

  export type PrescriptionChargesCreateNestedManyWithoutPrescriptionInput = {
    create?: XOR<PrescriptionChargesCreateWithoutPrescriptionInput, PrescriptionChargesUncheckedCreateWithoutPrescriptionInput> | PrescriptionChargesCreateWithoutPrescriptionInput[] | PrescriptionChargesUncheckedCreateWithoutPrescriptionInput[]
    connectOrCreate?: PrescriptionChargesCreateOrConnectWithoutPrescriptionInput | PrescriptionChargesCreateOrConnectWithoutPrescriptionInput[]
    createMany?: PrescriptionChargesCreateManyPrescriptionInputEnvelope
    connect?: PrescriptionChargesWhereUniqueInput | PrescriptionChargesWhereUniqueInput[]
  }

  export type IssueUncheckedCreateNestedManyWithoutPrescriptionInput = {
    create?: XOR<IssueCreateWithoutPrescriptionInput, IssueUncheckedCreateWithoutPrescriptionInput> | IssueCreateWithoutPrescriptionInput[] | IssueUncheckedCreateWithoutPrescriptionInput[]
    connectOrCreate?: IssueCreateOrConnectWithoutPrescriptionInput | IssueCreateOrConnectWithoutPrescriptionInput[]
    createMany?: IssueCreateManyPrescriptionInputEnvelope
    connect?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
  }

  export type OffRecordMedsUncheckedCreateNestedManyWithoutPrescriptionInput = {
    create?: XOR<OffRecordMedsCreateWithoutPrescriptionInput, OffRecordMedsUncheckedCreateWithoutPrescriptionInput> | OffRecordMedsCreateWithoutPrescriptionInput[] | OffRecordMedsUncheckedCreateWithoutPrescriptionInput[]
    connectOrCreate?: OffRecordMedsCreateOrConnectWithoutPrescriptionInput | OffRecordMedsCreateOrConnectWithoutPrescriptionInput[]
    createMany?: OffRecordMedsCreateManyPrescriptionInputEnvelope
    connect?: OffRecordMedsWhereUniqueInput | OffRecordMedsWhereUniqueInput[]
  }

  export type PrescriptionVitalsUncheckedCreateNestedManyWithoutPrescriptionInput = {
    create?: XOR<PrescriptionVitalsCreateWithoutPrescriptionInput, PrescriptionVitalsUncheckedCreateWithoutPrescriptionInput> | PrescriptionVitalsCreateWithoutPrescriptionInput[] | PrescriptionVitalsUncheckedCreateWithoutPrescriptionInput[]
    connectOrCreate?: PrescriptionVitalsCreateOrConnectWithoutPrescriptionInput | PrescriptionVitalsCreateOrConnectWithoutPrescriptionInput[]
    createMany?: PrescriptionVitalsCreateManyPrescriptionInputEnvelope
    connect?: PrescriptionVitalsWhereUniqueInput | PrescriptionVitalsWhereUniqueInput[]
  }

  export type PrescriptionChargesUncheckedCreateNestedManyWithoutPrescriptionInput = {
    create?: XOR<PrescriptionChargesCreateWithoutPrescriptionInput, PrescriptionChargesUncheckedCreateWithoutPrescriptionInput> | PrescriptionChargesCreateWithoutPrescriptionInput[] | PrescriptionChargesUncheckedCreateWithoutPrescriptionInput[]
    connectOrCreate?: PrescriptionChargesCreateOrConnectWithoutPrescriptionInput | PrescriptionChargesCreateOrConnectWithoutPrescriptionInput[]
    createMany?: PrescriptionChargesCreateManyPrescriptionInputEnvelope
    connect?: PrescriptionChargesWhereUniqueInput | PrescriptionChargesWhereUniqueInput[]
  }

  export type EnumPrescriptionStatusFieldUpdateOperationsInput = {
    set?: $Enums.PrescriptionStatus
  }

  export type IssueUpdateManyWithoutPrescriptionNestedInput = {
    create?: XOR<IssueCreateWithoutPrescriptionInput, IssueUncheckedCreateWithoutPrescriptionInput> | IssueCreateWithoutPrescriptionInput[] | IssueUncheckedCreateWithoutPrescriptionInput[]
    connectOrCreate?: IssueCreateOrConnectWithoutPrescriptionInput | IssueCreateOrConnectWithoutPrescriptionInput[]
    upsert?: IssueUpsertWithWhereUniqueWithoutPrescriptionInput | IssueUpsertWithWhereUniqueWithoutPrescriptionInput[]
    createMany?: IssueCreateManyPrescriptionInputEnvelope
    set?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    disconnect?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    delete?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    connect?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    update?: IssueUpdateWithWhereUniqueWithoutPrescriptionInput | IssueUpdateWithWhereUniqueWithoutPrescriptionInput[]
    updateMany?: IssueUpdateManyWithWhereWithoutPrescriptionInput | IssueUpdateManyWithWhereWithoutPrescriptionInput[]
    deleteMany?: IssueScalarWhereInput | IssueScalarWhereInput[]
  }

  export type OffRecordMedsUpdateManyWithoutPrescriptionNestedInput = {
    create?: XOR<OffRecordMedsCreateWithoutPrescriptionInput, OffRecordMedsUncheckedCreateWithoutPrescriptionInput> | OffRecordMedsCreateWithoutPrescriptionInput[] | OffRecordMedsUncheckedCreateWithoutPrescriptionInput[]
    connectOrCreate?: OffRecordMedsCreateOrConnectWithoutPrescriptionInput | OffRecordMedsCreateOrConnectWithoutPrescriptionInput[]
    upsert?: OffRecordMedsUpsertWithWhereUniqueWithoutPrescriptionInput | OffRecordMedsUpsertWithWhereUniqueWithoutPrescriptionInput[]
    createMany?: OffRecordMedsCreateManyPrescriptionInputEnvelope
    set?: OffRecordMedsWhereUniqueInput | OffRecordMedsWhereUniqueInput[]
    disconnect?: OffRecordMedsWhereUniqueInput | OffRecordMedsWhereUniqueInput[]
    delete?: OffRecordMedsWhereUniqueInput | OffRecordMedsWhereUniqueInput[]
    connect?: OffRecordMedsWhereUniqueInput | OffRecordMedsWhereUniqueInput[]
    update?: OffRecordMedsUpdateWithWhereUniqueWithoutPrescriptionInput | OffRecordMedsUpdateWithWhereUniqueWithoutPrescriptionInput[]
    updateMany?: OffRecordMedsUpdateManyWithWhereWithoutPrescriptionInput | OffRecordMedsUpdateManyWithWhereWithoutPrescriptionInput[]
    deleteMany?: OffRecordMedsScalarWhereInput | OffRecordMedsScalarWhereInput[]
  }

  export type PatientUpdateOneRequiredWithoutPrescriptionNestedInput = {
    create?: XOR<PatientCreateWithoutPrescriptionInput, PatientUncheckedCreateWithoutPrescriptionInput>
    connectOrCreate?: PatientCreateOrConnectWithoutPrescriptionInput
    upsert?: PatientUpsertWithoutPrescriptionInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutPrescriptionInput, PatientUpdateWithoutPrescriptionInput>, PatientUncheckedUpdateWithoutPrescriptionInput>
  }

  export type PrescriptionVitalsUpdateManyWithoutPrescriptionNestedInput = {
    create?: XOR<PrescriptionVitalsCreateWithoutPrescriptionInput, PrescriptionVitalsUncheckedCreateWithoutPrescriptionInput> | PrescriptionVitalsCreateWithoutPrescriptionInput[] | PrescriptionVitalsUncheckedCreateWithoutPrescriptionInput[]
    connectOrCreate?: PrescriptionVitalsCreateOrConnectWithoutPrescriptionInput | PrescriptionVitalsCreateOrConnectWithoutPrescriptionInput[]
    upsert?: PrescriptionVitalsUpsertWithWhereUniqueWithoutPrescriptionInput | PrescriptionVitalsUpsertWithWhereUniqueWithoutPrescriptionInput[]
    createMany?: PrescriptionVitalsCreateManyPrescriptionInputEnvelope
    set?: PrescriptionVitalsWhereUniqueInput | PrescriptionVitalsWhereUniqueInput[]
    disconnect?: PrescriptionVitalsWhereUniqueInput | PrescriptionVitalsWhereUniqueInput[]
    delete?: PrescriptionVitalsWhereUniqueInput | PrescriptionVitalsWhereUniqueInput[]
    connect?: PrescriptionVitalsWhereUniqueInput | PrescriptionVitalsWhereUniqueInput[]
    update?: PrescriptionVitalsUpdateWithWhereUniqueWithoutPrescriptionInput | PrescriptionVitalsUpdateWithWhereUniqueWithoutPrescriptionInput[]
    updateMany?: PrescriptionVitalsUpdateManyWithWhereWithoutPrescriptionInput | PrescriptionVitalsUpdateManyWithWhereWithoutPrescriptionInput[]
    deleteMany?: PrescriptionVitalsScalarWhereInput | PrescriptionVitalsScalarWhereInput[]
  }

  export type PrescriptionChargesUpdateManyWithoutPrescriptionNestedInput = {
    create?: XOR<PrescriptionChargesCreateWithoutPrescriptionInput, PrescriptionChargesUncheckedCreateWithoutPrescriptionInput> | PrescriptionChargesCreateWithoutPrescriptionInput[] | PrescriptionChargesUncheckedCreateWithoutPrescriptionInput[]
    connectOrCreate?: PrescriptionChargesCreateOrConnectWithoutPrescriptionInput | PrescriptionChargesCreateOrConnectWithoutPrescriptionInput[]
    upsert?: PrescriptionChargesUpsertWithWhereUniqueWithoutPrescriptionInput | PrescriptionChargesUpsertWithWhereUniqueWithoutPrescriptionInput[]
    createMany?: PrescriptionChargesCreateManyPrescriptionInputEnvelope
    set?: PrescriptionChargesWhereUniqueInput | PrescriptionChargesWhereUniqueInput[]
    disconnect?: PrescriptionChargesWhereUniqueInput | PrescriptionChargesWhereUniqueInput[]
    delete?: PrescriptionChargesWhereUniqueInput | PrescriptionChargesWhereUniqueInput[]
    connect?: PrescriptionChargesWhereUniqueInput | PrescriptionChargesWhereUniqueInput[]
    update?: PrescriptionChargesUpdateWithWhereUniqueWithoutPrescriptionInput | PrescriptionChargesUpdateWithWhereUniqueWithoutPrescriptionInput[]
    updateMany?: PrescriptionChargesUpdateManyWithWhereWithoutPrescriptionInput | PrescriptionChargesUpdateManyWithWhereWithoutPrescriptionInput[]
    deleteMany?: PrescriptionChargesScalarWhereInput | PrescriptionChargesScalarWhereInput[]
  }

  export type IssueUncheckedUpdateManyWithoutPrescriptionNestedInput = {
    create?: XOR<IssueCreateWithoutPrescriptionInput, IssueUncheckedCreateWithoutPrescriptionInput> | IssueCreateWithoutPrescriptionInput[] | IssueUncheckedCreateWithoutPrescriptionInput[]
    connectOrCreate?: IssueCreateOrConnectWithoutPrescriptionInput | IssueCreateOrConnectWithoutPrescriptionInput[]
    upsert?: IssueUpsertWithWhereUniqueWithoutPrescriptionInput | IssueUpsertWithWhereUniqueWithoutPrescriptionInput[]
    createMany?: IssueCreateManyPrescriptionInputEnvelope
    set?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    disconnect?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    delete?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    connect?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    update?: IssueUpdateWithWhereUniqueWithoutPrescriptionInput | IssueUpdateWithWhereUniqueWithoutPrescriptionInput[]
    updateMany?: IssueUpdateManyWithWhereWithoutPrescriptionInput | IssueUpdateManyWithWhereWithoutPrescriptionInput[]
    deleteMany?: IssueScalarWhereInput | IssueScalarWhereInput[]
  }

  export type OffRecordMedsUncheckedUpdateManyWithoutPrescriptionNestedInput = {
    create?: XOR<OffRecordMedsCreateWithoutPrescriptionInput, OffRecordMedsUncheckedCreateWithoutPrescriptionInput> | OffRecordMedsCreateWithoutPrescriptionInput[] | OffRecordMedsUncheckedCreateWithoutPrescriptionInput[]
    connectOrCreate?: OffRecordMedsCreateOrConnectWithoutPrescriptionInput | OffRecordMedsCreateOrConnectWithoutPrescriptionInput[]
    upsert?: OffRecordMedsUpsertWithWhereUniqueWithoutPrescriptionInput | OffRecordMedsUpsertWithWhereUniqueWithoutPrescriptionInput[]
    createMany?: OffRecordMedsCreateManyPrescriptionInputEnvelope
    set?: OffRecordMedsWhereUniqueInput | OffRecordMedsWhereUniqueInput[]
    disconnect?: OffRecordMedsWhereUniqueInput | OffRecordMedsWhereUniqueInput[]
    delete?: OffRecordMedsWhereUniqueInput | OffRecordMedsWhereUniqueInput[]
    connect?: OffRecordMedsWhereUniqueInput | OffRecordMedsWhereUniqueInput[]
    update?: OffRecordMedsUpdateWithWhereUniqueWithoutPrescriptionInput | OffRecordMedsUpdateWithWhereUniqueWithoutPrescriptionInput[]
    updateMany?: OffRecordMedsUpdateManyWithWhereWithoutPrescriptionInput | OffRecordMedsUpdateManyWithWhereWithoutPrescriptionInput[]
    deleteMany?: OffRecordMedsScalarWhereInput | OffRecordMedsScalarWhereInput[]
  }

  export type PrescriptionVitalsUncheckedUpdateManyWithoutPrescriptionNestedInput = {
    create?: XOR<PrescriptionVitalsCreateWithoutPrescriptionInput, PrescriptionVitalsUncheckedCreateWithoutPrescriptionInput> | PrescriptionVitalsCreateWithoutPrescriptionInput[] | PrescriptionVitalsUncheckedCreateWithoutPrescriptionInput[]
    connectOrCreate?: PrescriptionVitalsCreateOrConnectWithoutPrescriptionInput | PrescriptionVitalsCreateOrConnectWithoutPrescriptionInput[]
    upsert?: PrescriptionVitalsUpsertWithWhereUniqueWithoutPrescriptionInput | PrescriptionVitalsUpsertWithWhereUniqueWithoutPrescriptionInput[]
    createMany?: PrescriptionVitalsCreateManyPrescriptionInputEnvelope
    set?: PrescriptionVitalsWhereUniqueInput | PrescriptionVitalsWhereUniqueInput[]
    disconnect?: PrescriptionVitalsWhereUniqueInput | PrescriptionVitalsWhereUniqueInput[]
    delete?: PrescriptionVitalsWhereUniqueInput | PrescriptionVitalsWhereUniqueInput[]
    connect?: PrescriptionVitalsWhereUniqueInput | PrescriptionVitalsWhereUniqueInput[]
    update?: PrescriptionVitalsUpdateWithWhereUniqueWithoutPrescriptionInput | PrescriptionVitalsUpdateWithWhereUniqueWithoutPrescriptionInput[]
    updateMany?: PrescriptionVitalsUpdateManyWithWhereWithoutPrescriptionInput | PrescriptionVitalsUpdateManyWithWhereWithoutPrescriptionInput[]
    deleteMany?: PrescriptionVitalsScalarWhereInput | PrescriptionVitalsScalarWhereInput[]
  }

  export type PrescriptionChargesUncheckedUpdateManyWithoutPrescriptionNestedInput = {
    create?: XOR<PrescriptionChargesCreateWithoutPrescriptionInput, PrescriptionChargesUncheckedCreateWithoutPrescriptionInput> | PrescriptionChargesCreateWithoutPrescriptionInput[] | PrescriptionChargesUncheckedCreateWithoutPrescriptionInput[]
    connectOrCreate?: PrescriptionChargesCreateOrConnectWithoutPrescriptionInput | PrescriptionChargesCreateOrConnectWithoutPrescriptionInput[]
    upsert?: PrescriptionChargesUpsertWithWhereUniqueWithoutPrescriptionInput | PrescriptionChargesUpsertWithWhereUniqueWithoutPrescriptionInput[]
    createMany?: PrescriptionChargesCreateManyPrescriptionInputEnvelope
    set?: PrescriptionChargesWhereUniqueInput | PrescriptionChargesWhereUniqueInput[]
    disconnect?: PrescriptionChargesWhereUniqueInput | PrescriptionChargesWhereUniqueInput[]
    delete?: PrescriptionChargesWhereUniqueInput | PrescriptionChargesWhereUniqueInput[]
    connect?: PrescriptionChargesWhereUniqueInput | PrescriptionChargesWhereUniqueInput[]
    update?: PrescriptionChargesUpdateWithWhereUniqueWithoutPrescriptionInput | PrescriptionChargesUpdateWithWhereUniqueWithoutPrescriptionInput[]
    updateMany?: PrescriptionChargesUpdateManyWithWhereWithoutPrescriptionInput | PrescriptionChargesUpdateManyWithWhereWithoutPrescriptionInput[]
    deleteMany?: PrescriptionChargesScalarWhereInput | PrescriptionChargesScalarWhereInput[]
  }

  export type PrescriptionCreateNestedOneWithoutChargesInput = {
    create?: XOR<PrescriptionCreateWithoutChargesInput, PrescriptionUncheckedCreateWithoutChargesInput>
    connectOrCreate?: PrescriptionCreateOrConnectWithoutChargesInput
    connect?: PrescriptionWhereUniqueInput
  }

  export type EnumChargeTypeFieldUpdateOperationsInput = {
    set?: $Enums.ChargeType
  }

  export type PrescriptionUpdateOneRequiredWithoutChargesNestedInput = {
    create?: XOR<PrescriptionCreateWithoutChargesInput, PrescriptionUncheckedCreateWithoutChargesInput>
    connectOrCreate?: PrescriptionCreateOrConnectWithoutChargesInput
    upsert?: PrescriptionUpsertWithoutChargesInput
    connect?: PrescriptionWhereUniqueInput
    update?: XOR<XOR<PrescriptionUpdateToOneWithWhereWithoutChargesInput, PrescriptionUpdateWithoutChargesInput>, PrescriptionUncheckedUpdateWithoutChargesInput>
  }

  export type PrescriptionVitalsCreateNestedManyWithoutVitalInput = {
    create?: XOR<PrescriptionVitalsCreateWithoutVitalInput, PrescriptionVitalsUncheckedCreateWithoutVitalInput> | PrescriptionVitalsCreateWithoutVitalInput[] | PrescriptionVitalsUncheckedCreateWithoutVitalInput[]
    connectOrCreate?: PrescriptionVitalsCreateOrConnectWithoutVitalInput | PrescriptionVitalsCreateOrConnectWithoutVitalInput[]
    createMany?: PrescriptionVitalsCreateManyVitalInputEnvelope
    connect?: PrescriptionVitalsWhereUniqueInput | PrescriptionVitalsWhereUniqueInput[]
  }

  export type PrescriptionVitalsUncheckedCreateNestedManyWithoutVitalInput = {
    create?: XOR<PrescriptionVitalsCreateWithoutVitalInput, PrescriptionVitalsUncheckedCreateWithoutVitalInput> | PrescriptionVitalsCreateWithoutVitalInput[] | PrescriptionVitalsUncheckedCreateWithoutVitalInput[]
    connectOrCreate?: PrescriptionVitalsCreateOrConnectWithoutVitalInput | PrescriptionVitalsCreateOrConnectWithoutVitalInput[]
    createMany?: PrescriptionVitalsCreateManyVitalInputEnvelope
    connect?: PrescriptionVitalsWhereUniqueInput | PrescriptionVitalsWhereUniqueInput[]
  }

  export type NullableEnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender | null
  }

  export type EnumVitalTypeFieldUpdateOperationsInput = {
    set?: $Enums.VitalType
  }

  export type PrescriptionVitalsUpdateManyWithoutVitalNestedInput = {
    create?: XOR<PrescriptionVitalsCreateWithoutVitalInput, PrescriptionVitalsUncheckedCreateWithoutVitalInput> | PrescriptionVitalsCreateWithoutVitalInput[] | PrescriptionVitalsUncheckedCreateWithoutVitalInput[]
    connectOrCreate?: PrescriptionVitalsCreateOrConnectWithoutVitalInput | PrescriptionVitalsCreateOrConnectWithoutVitalInput[]
    upsert?: PrescriptionVitalsUpsertWithWhereUniqueWithoutVitalInput | PrescriptionVitalsUpsertWithWhereUniqueWithoutVitalInput[]
    createMany?: PrescriptionVitalsCreateManyVitalInputEnvelope
    set?: PrescriptionVitalsWhereUniqueInput | PrescriptionVitalsWhereUniqueInput[]
    disconnect?: PrescriptionVitalsWhereUniqueInput | PrescriptionVitalsWhereUniqueInput[]
    delete?: PrescriptionVitalsWhereUniqueInput | PrescriptionVitalsWhereUniqueInput[]
    connect?: PrescriptionVitalsWhereUniqueInput | PrescriptionVitalsWhereUniqueInput[]
    update?: PrescriptionVitalsUpdateWithWhereUniqueWithoutVitalInput | PrescriptionVitalsUpdateWithWhereUniqueWithoutVitalInput[]
    updateMany?: PrescriptionVitalsUpdateManyWithWhereWithoutVitalInput | PrescriptionVitalsUpdateManyWithWhereWithoutVitalInput[]
    deleteMany?: PrescriptionVitalsScalarWhereInput | PrescriptionVitalsScalarWhereInput[]
  }

  export type PrescriptionVitalsUncheckedUpdateManyWithoutVitalNestedInput = {
    create?: XOR<PrescriptionVitalsCreateWithoutVitalInput, PrescriptionVitalsUncheckedCreateWithoutVitalInput> | PrescriptionVitalsCreateWithoutVitalInput[] | PrescriptionVitalsUncheckedCreateWithoutVitalInput[]
    connectOrCreate?: PrescriptionVitalsCreateOrConnectWithoutVitalInput | PrescriptionVitalsCreateOrConnectWithoutVitalInput[]
    upsert?: PrescriptionVitalsUpsertWithWhereUniqueWithoutVitalInput | PrescriptionVitalsUpsertWithWhereUniqueWithoutVitalInput[]
    createMany?: PrescriptionVitalsCreateManyVitalInputEnvelope
    set?: PrescriptionVitalsWhereUniqueInput | PrescriptionVitalsWhereUniqueInput[]
    disconnect?: PrescriptionVitalsWhereUniqueInput | PrescriptionVitalsWhereUniqueInput[]
    delete?: PrescriptionVitalsWhereUniqueInput | PrescriptionVitalsWhereUniqueInput[]
    connect?: PrescriptionVitalsWhereUniqueInput | PrescriptionVitalsWhereUniqueInput[]
    update?: PrescriptionVitalsUpdateWithWhereUniqueWithoutVitalInput | PrescriptionVitalsUpdateWithWhereUniqueWithoutVitalInput[]
    updateMany?: PrescriptionVitalsUpdateManyWithWhereWithoutVitalInput | PrescriptionVitalsUpdateManyWithWhereWithoutVitalInput[]
    deleteMany?: PrescriptionVitalsScalarWhereInput | PrescriptionVitalsScalarWhereInput[]
  }

  export type PrescriptionCreateNestedOneWithoutPrescriptionVitalsInput = {
    create?: XOR<PrescriptionCreateWithoutPrescriptionVitalsInput, PrescriptionUncheckedCreateWithoutPrescriptionVitalsInput>
    connectOrCreate?: PrescriptionCreateOrConnectWithoutPrescriptionVitalsInput
    connect?: PrescriptionWhereUniqueInput
  }

  export type VitalsCreateNestedOneWithoutPrescriptionVitalsInput = {
    create?: XOR<VitalsCreateWithoutPrescriptionVitalsInput, VitalsUncheckedCreateWithoutPrescriptionVitalsInput>
    connectOrCreate?: VitalsCreateOrConnectWithoutPrescriptionVitalsInput
    connect?: VitalsWhereUniqueInput
  }

  export type PrescriptionUpdateOneRequiredWithoutPrescriptionVitalsNestedInput = {
    create?: XOR<PrescriptionCreateWithoutPrescriptionVitalsInput, PrescriptionUncheckedCreateWithoutPrescriptionVitalsInput>
    connectOrCreate?: PrescriptionCreateOrConnectWithoutPrescriptionVitalsInput
    upsert?: PrescriptionUpsertWithoutPrescriptionVitalsInput
    connect?: PrescriptionWhereUniqueInput
    update?: XOR<XOR<PrescriptionUpdateToOneWithWhereWithoutPrescriptionVitalsInput, PrescriptionUpdateWithoutPrescriptionVitalsInput>, PrescriptionUncheckedUpdateWithoutPrescriptionVitalsInput>
  }

  export type VitalsUpdateOneRequiredWithoutPrescriptionVitalsNestedInput = {
    create?: XOR<VitalsCreateWithoutPrescriptionVitalsInput, VitalsUncheckedCreateWithoutPrescriptionVitalsInput>
    connectOrCreate?: VitalsCreateOrConnectWithoutPrescriptionVitalsInput
    upsert?: VitalsUpsertWithoutPrescriptionVitalsInput
    connect?: VitalsWhereUniqueInput
    update?: XOR<XOR<VitalsUpdateToOneWithWhereWithoutPrescriptionVitalsInput, VitalsUpdateWithoutPrescriptionVitalsInput>, VitalsUncheckedUpdateWithoutPrescriptionVitalsInput>
  }

  export type PatientCreateNestedOneWithoutMedicalCertInput = {
    create?: XOR<PatientCreateWithoutMedicalCertInput, PatientUncheckedCreateWithoutMedicalCertInput>
    connectOrCreate?: PatientCreateOrConnectWithoutMedicalCertInput
    connect?: PatientWhereUniqueInput
  }

  export type EnumMedicalCertificateStatusFieldUpdateOperationsInput = {
    set?: $Enums.MedicalCertificateStatus
  }

  export type PatientUpdateOneRequiredWithoutMedicalCertNestedInput = {
    create?: XOR<PatientCreateWithoutMedicalCertInput, PatientUncheckedCreateWithoutMedicalCertInput>
    connectOrCreate?: PatientCreateOrConnectWithoutMedicalCertInput
    upsert?: PatientUpsertWithoutMedicalCertInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutMedicalCertInput, PatientUpdateWithoutMedicalCertInput>, PatientUncheckedUpdateWithoutMedicalCertInput>
  }

  export type PatientCreateNestedOneWithoutUSSReferralInput = {
    create?: XOR<PatientCreateWithoutUSSReferralInput, PatientUncheckedCreateWithoutUSSReferralInput>
    connectOrCreate?: PatientCreateOrConnectWithoutUSSReferralInput
    connect?: PatientWhereUniqueInput
  }

  export type PatientUpdateOneRequiredWithoutUSSReferralNestedInput = {
    create?: XOR<PatientCreateWithoutUSSReferralInput, PatientUncheckedCreateWithoutUSSReferralInput>
    connectOrCreate?: PatientCreateOrConnectWithoutUSSReferralInput
    upsert?: PatientUpsertWithoutUSSReferralInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutUSSReferralInput, PatientUpdateWithoutUSSReferralInput>, PatientUncheckedUpdateWithoutUSSReferralInput>
  }

  export type PatientCreateNestedOneWithoutReferralLettersInput = {
    create?: XOR<PatientCreateWithoutReferralLettersInput, PatientUncheckedCreateWithoutReferralLettersInput>
    connectOrCreate?: PatientCreateOrConnectWithoutReferralLettersInput
    connect?: PatientWhereUniqueInput
  }

  export type PatientUpdateOneRequiredWithoutReferralLettersNestedInput = {
    create?: XOR<PatientCreateWithoutReferralLettersInput, PatientUncheckedCreateWithoutReferralLettersInput>
    connectOrCreate?: PatientCreateOrConnectWithoutReferralLettersInput
    upsert?: PatientUpsertWithoutReferralLettersInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutReferralLettersInput, PatientUpdateWithoutReferralLettersInput>, PatientUncheckedUpdateWithoutReferralLettersInput>
  }

  export type PrescriptionCreateNestedOneWithoutOffRecordMedsInput = {
    create?: XOR<PrescriptionCreateWithoutOffRecordMedsInput, PrescriptionUncheckedCreateWithoutOffRecordMedsInput>
    connectOrCreate?: PrescriptionCreateOrConnectWithoutOffRecordMedsInput
    connect?: PrescriptionWhereUniqueInput
  }

  export type PrescriptionUpdateOneRequiredWithoutOffRecordMedsNestedInput = {
    create?: XOR<PrescriptionCreateWithoutOffRecordMedsInput, PrescriptionUncheckedCreateWithoutOffRecordMedsInput>
    connectOrCreate?: PrescriptionCreateOrConnectWithoutOffRecordMedsInput
    upsert?: PrescriptionUpsertWithoutOffRecordMedsInput
    connect?: PrescriptionWhereUniqueInput
    update?: XOR<XOR<PrescriptionUpdateToOneWithWhereWithoutOffRecordMedsInput, PrescriptionUpdateWithoutOffRecordMedsInput>, PrescriptionUncheckedUpdateWithoutOffRecordMedsInput>
  }

  export type BatchCreateNestedOneWithoutIssueInput = {
    create?: XOR<BatchCreateWithoutIssueInput, BatchUncheckedCreateWithoutIssueInput>
    connectOrCreate?: BatchCreateOrConnectWithoutIssueInput
    connect?: BatchWhereUniqueInput
  }

  export type DrugBrandCreateNestedOneWithoutIssueInput = {
    create?: XOR<DrugBrandCreateWithoutIssueInput, DrugBrandUncheckedCreateWithoutIssueInput>
    connectOrCreate?: DrugBrandCreateOrConnectWithoutIssueInput
    connect?: DrugBrandWhereUniqueInput
  }

  export type DrugCreateNestedOneWithoutIssueInput = {
    create?: XOR<DrugCreateWithoutIssueInput, DrugUncheckedCreateWithoutIssueInput>
    connectOrCreate?: DrugCreateOrConnectWithoutIssueInput
    connect?: DrugWhereUniqueInput
  }

  export type PrescriptionCreateNestedOneWithoutIssuesInput = {
    create?: XOR<PrescriptionCreateWithoutIssuesInput, PrescriptionUncheckedCreateWithoutIssuesInput>
    connectOrCreate?: PrescriptionCreateOrConnectWithoutIssuesInput
    connect?: PrescriptionWhereUniqueInput
  }

  export type UnitConcentrationCreateNestedOneWithoutIssueInput = {
    create?: XOR<UnitConcentrationCreateWithoutIssueInput, UnitConcentrationUncheckedCreateWithoutIssueInput>
    connectOrCreate?: UnitConcentrationCreateOrConnectWithoutIssueInput
    connect?: UnitConcentrationWhereUniqueInput
  }

  export type StratergyHistoryCreateNestedManyWithoutIssueInput = {
    create?: XOR<StratergyHistoryCreateWithoutIssueInput, StratergyHistoryUncheckedCreateWithoutIssueInput> | StratergyHistoryCreateWithoutIssueInput[] | StratergyHistoryUncheckedCreateWithoutIssueInput[]
    connectOrCreate?: StratergyHistoryCreateOrConnectWithoutIssueInput | StratergyHistoryCreateOrConnectWithoutIssueInput[]
    createMany?: StratergyHistoryCreateManyIssueInputEnvelope
    connect?: StratergyHistoryWhereUniqueInput | StratergyHistoryWhereUniqueInput[]
  }

  export type StratergyHistoryUncheckedCreateNestedManyWithoutIssueInput = {
    create?: XOR<StratergyHistoryCreateWithoutIssueInput, StratergyHistoryUncheckedCreateWithoutIssueInput> | StratergyHistoryCreateWithoutIssueInput[] | StratergyHistoryUncheckedCreateWithoutIssueInput[]
    connectOrCreate?: StratergyHistoryCreateOrConnectWithoutIssueInput | StratergyHistoryCreateOrConnectWithoutIssueInput[]
    createMany?: StratergyHistoryCreateManyIssueInputEnvelope
    connect?: StratergyHistoryWhereUniqueInput | StratergyHistoryWhereUniqueInput[]
  }

  export type EnumIssuingStrategyFieldUpdateOperationsInput = {
    set?: $Enums.IssuingStrategy
  }

  export type NullableEnumMEALFieldUpdateOperationsInput = {
    set?: $Enums.MEAL | null
  }

  export type BatchUpdateOneWithoutIssueNestedInput = {
    create?: XOR<BatchCreateWithoutIssueInput, BatchUncheckedCreateWithoutIssueInput>
    connectOrCreate?: BatchCreateOrConnectWithoutIssueInput
    upsert?: BatchUpsertWithoutIssueInput
    disconnect?: BatchWhereInput | boolean
    delete?: BatchWhereInput | boolean
    connect?: BatchWhereUniqueInput
    update?: XOR<XOR<BatchUpdateToOneWithWhereWithoutIssueInput, BatchUpdateWithoutIssueInput>, BatchUncheckedUpdateWithoutIssueInput>
  }

  export type DrugBrandUpdateOneRequiredWithoutIssueNestedInput = {
    create?: XOR<DrugBrandCreateWithoutIssueInput, DrugBrandUncheckedCreateWithoutIssueInput>
    connectOrCreate?: DrugBrandCreateOrConnectWithoutIssueInput
    upsert?: DrugBrandUpsertWithoutIssueInput
    connect?: DrugBrandWhereUniqueInput
    update?: XOR<XOR<DrugBrandUpdateToOneWithWhereWithoutIssueInput, DrugBrandUpdateWithoutIssueInput>, DrugBrandUncheckedUpdateWithoutIssueInput>
  }

  export type DrugUpdateOneRequiredWithoutIssueNestedInput = {
    create?: XOR<DrugCreateWithoutIssueInput, DrugUncheckedCreateWithoutIssueInput>
    connectOrCreate?: DrugCreateOrConnectWithoutIssueInput
    upsert?: DrugUpsertWithoutIssueInput
    connect?: DrugWhereUniqueInput
    update?: XOR<XOR<DrugUpdateToOneWithWhereWithoutIssueInput, DrugUpdateWithoutIssueInput>, DrugUncheckedUpdateWithoutIssueInput>
  }

  export type PrescriptionUpdateOneRequiredWithoutIssuesNestedInput = {
    create?: XOR<PrescriptionCreateWithoutIssuesInput, PrescriptionUncheckedCreateWithoutIssuesInput>
    connectOrCreate?: PrescriptionCreateOrConnectWithoutIssuesInput
    upsert?: PrescriptionUpsertWithoutIssuesInput
    connect?: PrescriptionWhereUniqueInput
    update?: XOR<XOR<PrescriptionUpdateToOneWithWhereWithoutIssuesInput, PrescriptionUpdateWithoutIssuesInput>, PrescriptionUncheckedUpdateWithoutIssuesInput>
  }

  export type UnitConcentrationUpdateOneRequiredWithoutIssueNestedInput = {
    create?: XOR<UnitConcentrationCreateWithoutIssueInput, UnitConcentrationUncheckedCreateWithoutIssueInput>
    connectOrCreate?: UnitConcentrationCreateOrConnectWithoutIssueInput
    upsert?: UnitConcentrationUpsertWithoutIssueInput
    connect?: UnitConcentrationWhereUniqueInput
    update?: XOR<XOR<UnitConcentrationUpdateToOneWithWhereWithoutIssueInput, UnitConcentrationUpdateWithoutIssueInput>, UnitConcentrationUncheckedUpdateWithoutIssueInput>
  }

  export type StratergyHistoryUpdateManyWithoutIssueNestedInput = {
    create?: XOR<StratergyHistoryCreateWithoutIssueInput, StratergyHistoryUncheckedCreateWithoutIssueInput> | StratergyHistoryCreateWithoutIssueInput[] | StratergyHistoryUncheckedCreateWithoutIssueInput[]
    connectOrCreate?: StratergyHistoryCreateOrConnectWithoutIssueInput | StratergyHistoryCreateOrConnectWithoutIssueInput[]
    upsert?: StratergyHistoryUpsertWithWhereUniqueWithoutIssueInput | StratergyHistoryUpsertWithWhereUniqueWithoutIssueInput[]
    createMany?: StratergyHistoryCreateManyIssueInputEnvelope
    set?: StratergyHistoryWhereUniqueInput | StratergyHistoryWhereUniqueInput[]
    disconnect?: StratergyHistoryWhereUniqueInput | StratergyHistoryWhereUniqueInput[]
    delete?: StratergyHistoryWhereUniqueInput | StratergyHistoryWhereUniqueInput[]
    connect?: StratergyHistoryWhereUniqueInput | StratergyHistoryWhereUniqueInput[]
    update?: StratergyHistoryUpdateWithWhereUniqueWithoutIssueInput | StratergyHistoryUpdateWithWhereUniqueWithoutIssueInput[]
    updateMany?: StratergyHistoryUpdateManyWithWhereWithoutIssueInput | StratergyHistoryUpdateManyWithWhereWithoutIssueInput[]
    deleteMany?: StratergyHistoryScalarWhereInput | StratergyHistoryScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StratergyHistoryUncheckedUpdateManyWithoutIssueNestedInput = {
    create?: XOR<StratergyHistoryCreateWithoutIssueInput, StratergyHistoryUncheckedCreateWithoutIssueInput> | StratergyHistoryCreateWithoutIssueInput[] | StratergyHistoryUncheckedCreateWithoutIssueInput[]
    connectOrCreate?: StratergyHistoryCreateOrConnectWithoutIssueInput | StratergyHistoryCreateOrConnectWithoutIssueInput[]
    upsert?: StratergyHistoryUpsertWithWhereUniqueWithoutIssueInput | StratergyHistoryUpsertWithWhereUniqueWithoutIssueInput[]
    createMany?: StratergyHistoryCreateManyIssueInputEnvelope
    set?: StratergyHistoryWhereUniqueInput | StratergyHistoryWhereUniqueInput[]
    disconnect?: StratergyHistoryWhereUniqueInput | StratergyHistoryWhereUniqueInput[]
    delete?: StratergyHistoryWhereUniqueInput | StratergyHistoryWhereUniqueInput[]
    connect?: StratergyHistoryWhereUniqueInput | StratergyHistoryWhereUniqueInput[]
    update?: StratergyHistoryUpdateWithWhereUniqueWithoutIssueInput | StratergyHistoryUpdateWithWhereUniqueWithoutIssueInput[]
    updateMany?: StratergyHistoryUpdateManyWithWhereWithoutIssueInput | StratergyHistoryUpdateManyWithWhereWithoutIssueInput[]
    deleteMany?: StratergyHistoryScalarWhereInput | StratergyHistoryScalarWhereInput[]
  }

  export type ReportTypeCreateNestedOneWithoutParametersInput = {
    create?: XOR<ReportTypeCreateWithoutParametersInput, ReportTypeUncheckedCreateWithoutParametersInput>
    connectOrCreate?: ReportTypeCreateOrConnectWithoutParametersInput
    connect?: ReportTypeWhereUniqueInput
  }

  export type ReportValueCreateNestedManyWithoutReportParameterInput = {
    create?: XOR<ReportValueCreateWithoutReportParameterInput, ReportValueUncheckedCreateWithoutReportParameterInput> | ReportValueCreateWithoutReportParameterInput[] | ReportValueUncheckedCreateWithoutReportParameterInput[]
    connectOrCreate?: ReportValueCreateOrConnectWithoutReportParameterInput | ReportValueCreateOrConnectWithoutReportParameterInput[]
    createMany?: ReportValueCreateManyReportParameterInputEnvelope
    connect?: ReportValueWhereUniqueInput | ReportValueWhereUniqueInput[]
  }

  export type ReportValueUncheckedCreateNestedManyWithoutReportParameterInput = {
    create?: XOR<ReportValueCreateWithoutReportParameterInput, ReportValueUncheckedCreateWithoutReportParameterInput> | ReportValueCreateWithoutReportParameterInput[] | ReportValueUncheckedCreateWithoutReportParameterInput[]
    connectOrCreate?: ReportValueCreateOrConnectWithoutReportParameterInput | ReportValueCreateOrConnectWithoutReportParameterInput[]
    createMany?: ReportValueCreateManyReportParameterInputEnvelope
    connect?: ReportValueWhereUniqueInput | ReportValueWhereUniqueInput[]
  }

  export type ReportTypeUpdateOneWithoutParametersNestedInput = {
    create?: XOR<ReportTypeCreateWithoutParametersInput, ReportTypeUncheckedCreateWithoutParametersInput>
    connectOrCreate?: ReportTypeCreateOrConnectWithoutParametersInput
    upsert?: ReportTypeUpsertWithoutParametersInput
    disconnect?: ReportTypeWhereInput | boolean
    delete?: ReportTypeWhereInput | boolean
    connect?: ReportTypeWhereUniqueInput
    update?: XOR<XOR<ReportTypeUpdateToOneWithWhereWithoutParametersInput, ReportTypeUpdateWithoutParametersInput>, ReportTypeUncheckedUpdateWithoutParametersInput>
  }

  export type ReportValueUpdateManyWithoutReportParameterNestedInput = {
    create?: XOR<ReportValueCreateWithoutReportParameterInput, ReportValueUncheckedCreateWithoutReportParameterInput> | ReportValueCreateWithoutReportParameterInput[] | ReportValueUncheckedCreateWithoutReportParameterInput[]
    connectOrCreate?: ReportValueCreateOrConnectWithoutReportParameterInput | ReportValueCreateOrConnectWithoutReportParameterInput[]
    upsert?: ReportValueUpsertWithWhereUniqueWithoutReportParameterInput | ReportValueUpsertWithWhereUniqueWithoutReportParameterInput[]
    createMany?: ReportValueCreateManyReportParameterInputEnvelope
    set?: ReportValueWhereUniqueInput | ReportValueWhereUniqueInput[]
    disconnect?: ReportValueWhereUniqueInput | ReportValueWhereUniqueInput[]
    delete?: ReportValueWhereUniqueInput | ReportValueWhereUniqueInput[]
    connect?: ReportValueWhereUniqueInput | ReportValueWhereUniqueInput[]
    update?: ReportValueUpdateWithWhereUniqueWithoutReportParameterInput | ReportValueUpdateWithWhereUniqueWithoutReportParameterInput[]
    updateMany?: ReportValueUpdateManyWithWhereWithoutReportParameterInput | ReportValueUpdateManyWithWhereWithoutReportParameterInput[]
    deleteMany?: ReportValueScalarWhereInput | ReportValueScalarWhereInput[]
  }

  export type ReportValueUncheckedUpdateManyWithoutReportParameterNestedInput = {
    create?: XOR<ReportValueCreateWithoutReportParameterInput, ReportValueUncheckedCreateWithoutReportParameterInput> | ReportValueCreateWithoutReportParameterInput[] | ReportValueUncheckedCreateWithoutReportParameterInput[]
    connectOrCreate?: ReportValueCreateOrConnectWithoutReportParameterInput | ReportValueCreateOrConnectWithoutReportParameterInput[]
    upsert?: ReportValueUpsertWithWhereUniqueWithoutReportParameterInput | ReportValueUpsertWithWhereUniqueWithoutReportParameterInput[]
    createMany?: ReportValueCreateManyReportParameterInputEnvelope
    set?: ReportValueWhereUniqueInput | ReportValueWhereUniqueInput[]
    disconnect?: ReportValueWhereUniqueInput | ReportValueWhereUniqueInput[]
    delete?: ReportValueWhereUniqueInput | ReportValueWhereUniqueInput[]
    connect?: ReportValueWhereUniqueInput | ReportValueWhereUniqueInput[]
    update?: ReportValueUpdateWithWhereUniqueWithoutReportParameterInput | ReportValueUpdateWithWhereUniqueWithoutReportParameterInput[]
    updateMany?: ReportValueUpdateManyWithWhereWithoutReportParameterInput | ReportValueUpdateManyWithWhereWithoutReportParameterInput[]
    deleteMany?: ReportValueScalarWhereInput | ReportValueScalarWhereInput[]
  }

  export type PatientReportCreateNestedManyWithoutReportTypeInput = {
    create?: XOR<PatientReportCreateWithoutReportTypeInput, PatientReportUncheckedCreateWithoutReportTypeInput> | PatientReportCreateWithoutReportTypeInput[] | PatientReportUncheckedCreateWithoutReportTypeInput[]
    connectOrCreate?: PatientReportCreateOrConnectWithoutReportTypeInput | PatientReportCreateOrConnectWithoutReportTypeInput[]
    createMany?: PatientReportCreateManyReportTypeInputEnvelope
    connect?: PatientReportWhereUniqueInput | PatientReportWhereUniqueInput[]
  }

  export type ReportParameterCreateNestedManyWithoutReportTypeInput = {
    create?: XOR<ReportParameterCreateWithoutReportTypeInput, ReportParameterUncheckedCreateWithoutReportTypeInput> | ReportParameterCreateWithoutReportTypeInput[] | ReportParameterUncheckedCreateWithoutReportTypeInput[]
    connectOrCreate?: ReportParameterCreateOrConnectWithoutReportTypeInput | ReportParameterCreateOrConnectWithoutReportTypeInput[]
    createMany?: ReportParameterCreateManyReportTypeInputEnvelope
    connect?: ReportParameterWhereUniqueInput | ReportParameterWhereUniqueInput[]
  }

  export type PatientReportUncheckedCreateNestedManyWithoutReportTypeInput = {
    create?: XOR<PatientReportCreateWithoutReportTypeInput, PatientReportUncheckedCreateWithoutReportTypeInput> | PatientReportCreateWithoutReportTypeInput[] | PatientReportUncheckedCreateWithoutReportTypeInput[]
    connectOrCreate?: PatientReportCreateOrConnectWithoutReportTypeInput | PatientReportCreateOrConnectWithoutReportTypeInput[]
    createMany?: PatientReportCreateManyReportTypeInputEnvelope
    connect?: PatientReportWhereUniqueInput | PatientReportWhereUniqueInput[]
  }

  export type ReportParameterUncheckedCreateNestedManyWithoutReportTypeInput = {
    create?: XOR<ReportParameterCreateWithoutReportTypeInput, ReportParameterUncheckedCreateWithoutReportTypeInput> | ReportParameterCreateWithoutReportTypeInput[] | ReportParameterUncheckedCreateWithoutReportTypeInput[]
    connectOrCreate?: ReportParameterCreateOrConnectWithoutReportTypeInput | ReportParameterCreateOrConnectWithoutReportTypeInput[]
    createMany?: ReportParameterCreateManyReportTypeInputEnvelope
    connect?: ReportParameterWhereUniqueInput | ReportParameterWhereUniqueInput[]
  }

  export type PatientReportUpdateManyWithoutReportTypeNestedInput = {
    create?: XOR<PatientReportCreateWithoutReportTypeInput, PatientReportUncheckedCreateWithoutReportTypeInput> | PatientReportCreateWithoutReportTypeInput[] | PatientReportUncheckedCreateWithoutReportTypeInput[]
    connectOrCreate?: PatientReportCreateOrConnectWithoutReportTypeInput | PatientReportCreateOrConnectWithoutReportTypeInput[]
    upsert?: PatientReportUpsertWithWhereUniqueWithoutReportTypeInput | PatientReportUpsertWithWhereUniqueWithoutReportTypeInput[]
    createMany?: PatientReportCreateManyReportTypeInputEnvelope
    set?: PatientReportWhereUniqueInput | PatientReportWhereUniqueInput[]
    disconnect?: PatientReportWhereUniqueInput | PatientReportWhereUniqueInput[]
    delete?: PatientReportWhereUniqueInput | PatientReportWhereUniqueInput[]
    connect?: PatientReportWhereUniqueInput | PatientReportWhereUniqueInput[]
    update?: PatientReportUpdateWithWhereUniqueWithoutReportTypeInput | PatientReportUpdateWithWhereUniqueWithoutReportTypeInput[]
    updateMany?: PatientReportUpdateManyWithWhereWithoutReportTypeInput | PatientReportUpdateManyWithWhereWithoutReportTypeInput[]
    deleteMany?: PatientReportScalarWhereInput | PatientReportScalarWhereInput[]
  }

  export type ReportParameterUpdateManyWithoutReportTypeNestedInput = {
    create?: XOR<ReportParameterCreateWithoutReportTypeInput, ReportParameterUncheckedCreateWithoutReportTypeInput> | ReportParameterCreateWithoutReportTypeInput[] | ReportParameterUncheckedCreateWithoutReportTypeInput[]
    connectOrCreate?: ReportParameterCreateOrConnectWithoutReportTypeInput | ReportParameterCreateOrConnectWithoutReportTypeInput[]
    upsert?: ReportParameterUpsertWithWhereUniqueWithoutReportTypeInput | ReportParameterUpsertWithWhereUniqueWithoutReportTypeInput[]
    createMany?: ReportParameterCreateManyReportTypeInputEnvelope
    set?: ReportParameterWhereUniqueInput | ReportParameterWhereUniqueInput[]
    disconnect?: ReportParameterWhereUniqueInput | ReportParameterWhereUniqueInput[]
    delete?: ReportParameterWhereUniqueInput | ReportParameterWhereUniqueInput[]
    connect?: ReportParameterWhereUniqueInput | ReportParameterWhereUniqueInput[]
    update?: ReportParameterUpdateWithWhereUniqueWithoutReportTypeInput | ReportParameterUpdateWithWhereUniqueWithoutReportTypeInput[]
    updateMany?: ReportParameterUpdateManyWithWhereWithoutReportTypeInput | ReportParameterUpdateManyWithWhereWithoutReportTypeInput[]
    deleteMany?: ReportParameterScalarWhereInput | ReportParameterScalarWhereInput[]
  }

  export type PatientReportUncheckedUpdateManyWithoutReportTypeNestedInput = {
    create?: XOR<PatientReportCreateWithoutReportTypeInput, PatientReportUncheckedCreateWithoutReportTypeInput> | PatientReportCreateWithoutReportTypeInput[] | PatientReportUncheckedCreateWithoutReportTypeInput[]
    connectOrCreate?: PatientReportCreateOrConnectWithoutReportTypeInput | PatientReportCreateOrConnectWithoutReportTypeInput[]
    upsert?: PatientReportUpsertWithWhereUniqueWithoutReportTypeInput | PatientReportUpsertWithWhereUniqueWithoutReportTypeInput[]
    createMany?: PatientReportCreateManyReportTypeInputEnvelope
    set?: PatientReportWhereUniqueInput | PatientReportWhereUniqueInput[]
    disconnect?: PatientReportWhereUniqueInput | PatientReportWhereUniqueInput[]
    delete?: PatientReportWhereUniqueInput | PatientReportWhereUniqueInput[]
    connect?: PatientReportWhereUniqueInput | PatientReportWhereUniqueInput[]
    update?: PatientReportUpdateWithWhereUniqueWithoutReportTypeInput | PatientReportUpdateWithWhereUniqueWithoutReportTypeInput[]
    updateMany?: PatientReportUpdateManyWithWhereWithoutReportTypeInput | PatientReportUpdateManyWithWhereWithoutReportTypeInput[]
    deleteMany?: PatientReportScalarWhereInput | PatientReportScalarWhereInput[]
  }

  export type ReportParameterUncheckedUpdateManyWithoutReportTypeNestedInput = {
    create?: XOR<ReportParameterCreateWithoutReportTypeInput, ReportParameterUncheckedCreateWithoutReportTypeInput> | ReportParameterCreateWithoutReportTypeInput[] | ReportParameterUncheckedCreateWithoutReportTypeInput[]
    connectOrCreate?: ReportParameterCreateOrConnectWithoutReportTypeInput | ReportParameterCreateOrConnectWithoutReportTypeInput[]
    upsert?: ReportParameterUpsertWithWhereUniqueWithoutReportTypeInput | ReportParameterUpsertWithWhereUniqueWithoutReportTypeInput[]
    createMany?: ReportParameterCreateManyReportTypeInputEnvelope
    set?: ReportParameterWhereUniqueInput | ReportParameterWhereUniqueInput[]
    disconnect?: ReportParameterWhereUniqueInput | ReportParameterWhereUniqueInput[]
    delete?: ReportParameterWhereUniqueInput | ReportParameterWhereUniqueInput[]
    connect?: ReportParameterWhereUniqueInput | ReportParameterWhereUniqueInput[]
    update?: ReportParameterUpdateWithWhereUniqueWithoutReportTypeInput | ReportParameterUpdateWithWhereUniqueWithoutReportTypeInput[]
    updateMany?: ReportParameterUpdateManyWithWhereWithoutReportTypeInput | ReportParameterUpdateManyWithWhereWithoutReportTypeInput[]
    deleteMany?: ReportParameterScalarWhereInput | ReportParameterScalarWhereInput[]
  }

  export type PatientCreateNestedOneWithoutReportsInput = {
    create?: XOR<PatientCreateWithoutReportsInput, PatientUncheckedCreateWithoutReportsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutReportsInput
    connect?: PatientWhereUniqueInput
  }

  export type ReportTypeCreateNestedOneWithoutPatientReportInput = {
    create?: XOR<ReportTypeCreateWithoutPatientReportInput, ReportTypeUncheckedCreateWithoutPatientReportInput>
    connectOrCreate?: ReportTypeCreateOrConnectWithoutPatientReportInput
    connect?: ReportTypeWhereUniqueInput
  }

  export type ReportValueCreateNestedManyWithoutPatientReportInput = {
    create?: XOR<ReportValueCreateWithoutPatientReportInput, ReportValueUncheckedCreateWithoutPatientReportInput> | ReportValueCreateWithoutPatientReportInput[] | ReportValueUncheckedCreateWithoutPatientReportInput[]
    connectOrCreate?: ReportValueCreateOrConnectWithoutPatientReportInput | ReportValueCreateOrConnectWithoutPatientReportInput[]
    createMany?: ReportValueCreateManyPatientReportInputEnvelope
    connect?: ReportValueWhereUniqueInput | ReportValueWhereUniqueInput[]
  }

  export type ReportValueUncheckedCreateNestedManyWithoutPatientReportInput = {
    create?: XOR<ReportValueCreateWithoutPatientReportInput, ReportValueUncheckedCreateWithoutPatientReportInput> | ReportValueCreateWithoutPatientReportInput[] | ReportValueUncheckedCreateWithoutPatientReportInput[]
    connectOrCreate?: ReportValueCreateOrConnectWithoutPatientReportInput | ReportValueCreateOrConnectWithoutPatientReportInput[]
    createMany?: ReportValueCreateManyPatientReportInputEnvelope
    connect?: ReportValueWhereUniqueInput | ReportValueWhereUniqueInput[]
  }

  export type PatientUpdateOneRequiredWithoutReportsNestedInput = {
    create?: XOR<PatientCreateWithoutReportsInput, PatientUncheckedCreateWithoutReportsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutReportsInput
    upsert?: PatientUpsertWithoutReportsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutReportsInput, PatientUpdateWithoutReportsInput>, PatientUncheckedUpdateWithoutReportsInput>
  }

  export type ReportTypeUpdateOneRequiredWithoutPatientReportNestedInput = {
    create?: XOR<ReportTypeCreateWithoutPatientReportInput, ReportTypeUncheckedCreateWithoutPatientReportInput>
    connectOrCreate?: ReportTypeCreateOrConnectWithoutPatientReportInput
    upsert?: ReportTypeUpsertWithoutPatientReportInput
    connect?: ReportTypeWhereUniqueInput
    update?: XOR<XOR<ReportTypeUpdateToOneWithWhereWithoutPatientReportInput, ReportTypeUpdateWithoutPatientReportInput>, ReportTypeUncheckedUpdateWithoutPatientReportInput>
  }

  export type ReportValueUpdateManyWithoutPatientReportNestedInput = {
    create?: XOR<ReportValueCreateWithoutPatientReportInput, ReportValueUncheckedCreateWithoutPatientReportInput> | ReportValueCreateWithoutPatientReportInput[] | ReportValueUncheckedCreateWithoutPatientReportInput[]
    connectOrCreate?: ReportValueCreateOrConnectWithoutPatientReportInput | ReportValueCreateOrConnectWithoutPatientReportInput[]
    upsert?: ReportValueUpsertWithWhereUniqueWithoutPatientReportInput | ReportValueUpsertWithWhereUniqueWithoutPatientReportInput[]
    createMany?: ReportValueCreateManyPatientReportInputEnvelope
    set?: ReportValueWhereUniqueInput | ReportValueWhereUniqueInput[]
    disconnect?: ReportValueWhereUniqueInput | ReportValueWhereUniqueInput[]
    delete?: ReportValueWhereUniqueInput | ReportValueWhereUniqueInput[]
    connect?: ReportValueWhereUniqueInput | ReportValueWhereUniqueInput[]
    update?: ReportValueUpdateWithWhereUniqueWithoutPatientReportInput | ReportValueUpdateWithWhereUniqueWithoutPatientReportInput[]
    updateMany?: ReportValueUpdateManyWithWhereWithoutPatientReportInput | ReportValueUpdateManyWithWhereWithoutPatientReportInput[]
    deleteMany?: ReportValueScalarWhereInput | ReportValueScalarWhereInput[]
  }

  export type ReportValueUncheckedUpdateManyWithoutPatientReportNestedInput = {
    create?: XOR<ReportValueCreateWithoutPatientReportInput, ReportValueUncheckedCreateWithoutPatientReportInput> | ReportValueCreateWithoutPatientReportInput[] | ReportValueUncheckedCreateWithoutPatientReportInput[]
    connectOrCreate?: ReportValueCreateOrConnectWithoutPatientReportInput | ReportValueCreateOrConnectWithoutPatientReportInput[]
    upsert?: ReportValueUpsertWithWhereUniqueWithoutPatientReportInput | ReportValueUpsertWithWhereUniqueWithoutPatientReportInput[]
    createMany?: ReportValueCreateManyPatientReportInputEnvelope
    set?: ReportValueWhereUniqueInput | ReportValueWhereUniqueInput[]
    disconnect?: ReportValueWhereUniqueInput | ReportValueWhereUniqueInput[]
    delete?: ReportValueWhereUniqueInput | ReportValueWhereUniqueInput[]
    connect?: ReportValueWhereUniqueInput | ReportValueWhereUniqueInput[]
    update?: ReportValueUpdateWithWhereUniqueWithoutPatientReportInput | ReportValueUpdateWithWhereUniqueWithoutPatientReportInput[]
    updateMany?: ReportValueUpdateManyWithWhereWithoutPatientReportInput | ReportValueUpdateManyWithWhereWithoutPatientReportInput[]
    deleteMany?: ReportValueScalarWhereInput | ReportValueScalarWhereInput[]
  }

  export type PatientReportCreateNestedOneWithoutParametersInput = {
    create?: XOR<PatientReportCreateWithoutParametersInput, PatientReportUncheckedCreateWithoutParametersInput>
    connectOrCreate?: PatientReportCreateOrConnectWithoutParametersInput
    connect?: PatientReportWhereUniqueInput
  }

  export type ReportParameterCreateNestedOneWithoutReportValueInput = {
    create?: XOR<ReportParameterCreateWithoutReportValueInput, ReportParameterUncheckedCreateWithoutReportValueInput>
    connectOrCreate?: ReportParameterCreateOrConnectWithoutReportValueInput
    connect?: ReportParameterWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type PatientReportUpdateOneWithoutParametersNestedInput = {
    create?: XOR<PatientReportCreateWithoutParametersInput, PatientReportUncheckedCreateWithoutParametersInput>
    connectOrCreate?: PatientReportCreateOrConnectWithoutParametersInput
    upsert?: PatientReportUpsertWithoutParametersInput
    disconnect?: PatientReportWhereInput | boolean
    delete?: PatientReportWhereInput | boolean
    connect?: PatientReportWhereUniqueInput
    update?: XOR<XOR<PatientReportUpdateToOneWithWhereWithoutParametersInput, PatientReportUpdateWithoutParametersInput>, PatientReportUncheckedUpdateWithoutParametersInput>
  }

  export type ReportParameterUpdateOneRequiredWithoutReportValueNestedInput = {
    create?: XOR<ReportParameterCreateWithoutReportValueInput, ReportParameterUncheckedCreateWithoutReportValueInput>
    connectOrCreate?: ReportParameterCreateOrConnectWithoutReportValueInput
    upsert?: ReportParameterUpsertWithoutReportValueInput
    connect?: ReportParameterWhereUniqueInput
    update?: XOR<XOR<ReportParameterUpdateToOneWithWhereWithoutReportValueInput, ReportParameterUpdateWithoutReportValueInput>, ReportParameterUncheckedUpdateWithoutReportValueInput>
  }

  export type DrugCreateNestedOneWithoutStratergyHistoryInput = {
    create?: XOR<DrugCreateWithoutStratergyHistoryInput, DrugUncheckedCreateWithoutStratergyHistoryInput>
    connectOrCreate?: DrugCreateOrConnectWithoutStratergyHistoryInput
    connect?: DrugWhereUniqueInput
  }

  export type IssueCreateNestedOneWithoutStratergyHistoryInput = {
    create?: XOR<IssueCreateWithoutStratergyHistoryInput, IssueUncheckedCreateWithoutStratergyHistoryInput>
    connectOrCreate?: IssueCreateOrConnectWithoutStratergyHistoryInput
    connect?: IssueWhereUniqueInput
  }

  export type DrugUpdateOneRequiredWithoutStratergyHistoryNestedInput = {
    create?: XOR<DrugCreateWithoutStratergyHistoryInput, DrugUncheckedCreateWithoutStratergyHistoryInput>
    connectOrCreate?: DrugCreateOrConnectWithoutStratergyHistoryInput
    upsert?: DrugUpsertWithoutStratergyHistoryInput
    connect?: DrugWhereUniqueInput
    update?: XOR<XOR<DrugUpdateToOneWithWhereWithoutStratergyHistoryInput, DrugUpdateWithoutStratergyHistoryInput>, DrugUncheckedUpdateWithoutStratergyHistoryInput>
  }

  export type IssueUpdateOneRequiredWithoutStratergyHistoryNestedInput = {
    create?: XOR<IssueCreateWithoutStratergyHistoryInput, IssueUncheckedCreateWithoutStratergyHistoryInput>
    connectOrCreate?: IssueCreateOrConnectWithoutStratergyHistoryInput
    upsert?: IssueUpsertWithoutStratergyHistoryInput
    connect?: IssueWhereUniqueInput
    update?: XOR<XOR<IssueUpdateToOneWithWhereWithoutStratergyHistoryInput, IssueUpdateWithoutStratergyHistoryInput>, IssueUncheckedUpdateWithoutStratergyHistoryInput>
  }

  export type BatchCreateNestedOneWithoutBatchHistoryInput = {
    create?: XOR<BatchCreateWithoutBatchHistoryInput, BatchUncheckedCreateWithoutBatchHistoryInput>
    connectOrCreate?: BatchCreateOrConnectWithoutBatchHistoryInput
    connect?: BatchWhereUniqueInput
  }

  export type DrugBrandCreateNestedOneWithoutBatchHistoryInput = {
    create?: XOR<DrugBrandCreateWithoutBatchHistoryInput, DrugBrandUncheckedCreateWithoutBatchHistoryInput>
    connectOrCreate?: DrugBrandCreateOrConnectWithoutBatchHistoryInput
    connect?: DrugBrandWhereUniqueInput
  }

  export type DrugCreateNestedOneWithoutBatchHistoryInput = {
    create?: XOR<DrugCreateWithoutBatchHistoryInput, DrugUncheckedCreateWithoutBatchHistoryInput>
    connectOrCreate?: DrugCreateOrConnectWithoutBatchHistoryInput
    connect?: DrugWhereUniqueInput
  }

  export type UnitConcentrationCreateNestedOneWithoutBatchHistoryInput = {
    create?: XOR<UnitConcentrationCreateWithoutBatchHistoryInput, UnitConcentrationUncheckedCreateWithoutBatchHistoryInput>
    connectOrCreate?: UnitConcentrationCreateOrConnectWithoutBatchHistoryInput
    connect?: UnitConcentrationWhereUniqueInput
  }

  export type BatchUpdateOneRequiredWithoutBatchHistoryNestedInput = {
    create?: XOR<BatchCreateWithoutBatchHistoryInput, BatchUncheckedCreateWithoutBatchHistoryInput>
    connectOrCreate?: BatchCreateOrConnectWithoutBatchHistoryInput
    upsert?: BatchUpsertWithoutBatchHistoryInput
    connect?: BatchWhereUniqueInput
    update?: XOR<XOR<BatchUpdateToOneWithWhereWithoutBatchHistoryInput, BatchUpdateWithoutBatchHistoryInput>, BatchUncheckedUpdateWithoutBatchHistoryInput>
  }

  export type DrugBrandUpdateOneRequiredWithoutBatchHistoryNestedInput = {
    create?: XOR<DrugBrandCreateWithoutBatchHistoryInput, DrugBrandUncheckedCreateWithoutBatchHistoryInput>
    connectOrCreate?: DrugBrandCreateOrConnectWithoutBatchHistoryInput
    upsert?: DrugBrandUpsertWithoutBatchHistoryInput
    connect?: DrugBrandWhereUniqueInput
    update?: XOR<XOR<DrugBrandUpdateToOneWithWhereWithoutBatchHistoryInput, DrugBrandUpdateWithoutBatchHistoryInput>, DrugBrandUncheckedUpdateWithoutBatchHistoryInput>
  }

  export type DrugUpdateOneRequiredWithoutBatchHistoryNestedInput = {
    create?: XOR<DrugCreateWithoutBatchHistoryInput, DrugUncheckedCreateWithoutBatchHistoryInput>
    connectOrCreate?: DrugCreateOrConnectWithoutBatchHistoryInput
    upsert?: DrugUpsertWithoutBatchHistoryInput
    connect?: DrugWhereUniqueInput
    update?: XOR<XOR<DrugUpdateToOneWithWhereWithoutBatchHistoryInput, DrugUpdateWithoutBatchHistoryInput>, DrugUncheckedUpdateWithoutBatchHistoryInput>
  }

  export type UnitConcentrationUpdateOneRequiredWithoutBatchHistoryNestedInput = {
    create?: XOR<UnitConcentrationCreateWithoutBatchHistoryInput, UnitConcentrationUncheckedCreateWithoutBatchHistoryInput>
    connectOrCreate?: UnitConcentrationCreateOrConnectWithoutBatchHistoryInput
    upsert?: UnitConcentrationUpsertWithoutBatchHistoryInput
    connect?: UnitConcentrationWhereUniqueInput
    update?: XOR<XOR<UnitConcentrationUpdateToOneWithWhereWithoutBatchHistoryInput, UnitConcentrationUpdateWithoutBatchHistoryInput>, UnitConcentrationUncheckedUpdateWithoutBatchHistoryInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type NestedEnumPatientHistoryTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PatientHistoryType | EnumPatientHistoryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PatientHistoryType[] | ListEnumPatientHistoryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PatientHistoryType[] | ListEnumPatientHistoryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPatientHistoryTypeFilter<$PrismaModel> | $Enums.PatientHistoryType
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumPatientHistoryTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PatientHistoryType | EnumPatientHistoryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PatientHistoryType[] | ListEnumPatientHistoryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PatientHistoryType[] | ListEnumPatientHistoryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPatientHistoryTypeWithAggregatesFilter<$PrismaModel> | $Enums.PatientHistoryType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPatientHistoryTypeFilter<$PrismaModel>
    _max?: NestedEnumPatientHistoryTypeFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedEnumQueueStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QueueStatus | EnumQueueStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QueueStatus[] | ListEnumQueueStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QueueStatus[] | ListEnumQueueStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQueueStatusFilter<$PrismaModel> | $Enums.QueueStatus
  }

  export type NestedEnumQueueStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QueueStatus | EnumQueueStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QueueStatus[] | ListEnumQueueStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QueueStatus[] | ListEnumQueueStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQueueStatusWithAggregatesFilter<$PrismaModel> | $Enums.QueueStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQueueStatusFilter<$PrismaModel>
    _max?: NestedEnumQueueStatusFilter<$PrismaModel>
  }

  export type NestedEnumVisitStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitStatus | EnumVisitStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VisitStatus[] | ListEnumVisitStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VisitStatus[] | ListEnumVisitStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVisitStatusFilter<$PrismaModel> | $Enums.VisitStatus
  }

  export type NestedEnumVisitStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitStatus | EnumVisitStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VisitStatus[] | ListEnumVisitStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VisitStatus[] | ListEnumVisitStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVisitStatusWithAggregatesFilter<$PrismaModel> | $Enums.VisitStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVisitStatusFilter<$PrismaModel>
    _max?: NestedEnumVisitStatusFilter<$PrismaModel>
  }

  export type NestedEnumDrugTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DrugType | EnumDrugTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DrugType[] | ListEnumDrugTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DrugType[] | ListEnumDrugTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDrugTypeFilter<$PrismaModel> | $Enums.DrugType
  }

  export type NestedEnumDrugTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DrugType | EnumDrugTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DrugType[] | ListEnumDrugTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DrugType[] | ListEnumDrugTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDrugTypeWithAggregatesFilter<$PrismaModel> | $Enums.DrugType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDrugTypeFilter<$PrismaModel>
    _max?: NestedEnumDrugTypeFilter<$PrismaModel>
  }

  export type NestedEnumBatchStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BatchStatus | EnumBatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BatchStatus[] | ListEnumBatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BatchStatus[] | ListEnumBatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBatchStatusFilter<$PrismaModel> | $Enums.BatchStatus
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumBatchStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BatchStatus | EnumBatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BatchStatus[] | ListEnumBatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BatchStatus[] | ListEnumBatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBatchStatusWithAggregatesFilter<$PrismaModel> | $Enums.BatchStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBatchStatusFilter<$PrismaModel>
    _max?: NestedEnumBatchStatusFilter<$PrismaModel>
  }

  export type NestedEnumPrescriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PrescriptionStatus | EnumPrescriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PrescriptionStatus[] | ListEnumPrescriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PrescriptionStatus[] | ListEnumPrescriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPrescriptionStatusFilter<$PrismaModel> | $Enums.PrescriptionStatus
  }

  export type NestedEnumPrescriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PrescriptionStatus | EnumPrescriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PrescriptionStatus[] | ListEnumPrescriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PrescriptionStatus[] | ListEnumPrescriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPrescriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.PrescriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPrescriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumPrescriptionStatusFilter<$PrismaModel>
  }

  export type NestedEnumChargeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ChargeType | EnumChargeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChargeType[] | ListEnumChargeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChargeType[] | ListEnumChargeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChargeTypeFilter<$PrismaModel> | $Enums.ChargeType
  }

  export type NestedEnumChargeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChargeType | EnumChargeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChargeType[] | ListEnumChargeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChargeType[] | ListEnumChargeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChargeTypeWithAggregatesFilter<$PrismaModel> | $Enums.ChargeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChargeTypeFilter<$PrismaModel>
    _max?: NestedEnumChargeTypeFilter<$PrismaModel>
  }

  export type NestedEnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type NestedEnumVitalTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.VitalType | EnumVitalTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VitalType[] | ListEnumVitalTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VitalType[] | ListEnumVitalTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVitalTypeFilter<$PrismaModel> | $Enums.VitalType
  }

  export type NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type NestedEnumVitalTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VitalType | EnumVitalTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VitalType[] | ListEnumVitalTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VitalType[] | ListEnumVitalTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVitalTypeWithAggregatesFilter<$PrismaModel> | $Enums.VitalType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVitalTypeFilter<$PrismaModel>
    _max?: NestedEnumVitalTypeFilter<$PrismaModel>
  }

  export type NestedEnumMedicalCertificateStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MedicalCertificateStatus | EnumMedicalCertificateStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MedicalCertificateStatus[] | ListEnumMedicalCertificateStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MedicalCertificateStatus[] | ListEnumMedicalCertificateStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMedicalCertificateStatusFilter<$PrismaModel> | $Enums.MedicalCertificateStatus
  }

  export type NestedEnumMedicalCertificateStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MedicalCertificateStatus | EnumMedicalCertificateStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MedicalCertificateStatus[] | ListEnumMedicalCertificateStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MedicalCertificateStatus[] | ListEnumMedicalCertificateStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMedicalCertificateStatusWithAggregatesFilter<$PrismaModel> | $Enums.MedicalCertificateStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMedicalCertificateStatusFilter<$PrismaModel>
    _max?: NestedEnumMedicalCertificateStatusFilter<$PrismaModel>
  }

  export type NestedEnumIssuingStrategyFilter<$PrismaModel = never> = {
    equals?: $Enums.IssuingStrategy | EnumIssuingStrategyFieldRefInput<$PrismaModel>
    in?: $Enums.IssuingStrategy[] | ListEnumIssuingStrategyFieldRefInput<$PrismaModel>
    notIn?: $Enums.IssuingStrategy[] | ListEnumIssuingStrategyFieldRefInput<$PrismaModel>
    not?: NestedEnumIssuingStrategyFilter<$PrismaModel> | $Enums.IssuingStrategy
  }

  export type NestedEnumMEALNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.MEAL | EnumMEALFieldRefInput<$PrismaModel> | null
    in?: $Enums.MEAL[] | ListEnumMEALFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MEAL[] | ListEnumMEALFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMEALNullableFilter<$PrismaModel> | $Enums.MEAL | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumIssuingStrategyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IssuingStrategy | EnumIssuingStrategyFieldRefInput<$PrismaModel>
    in?: $Enums.IssuingStrategy[] | ListEnumIssuingStrategyFieldRefInput<$PrismaModel>
    notIn?: $Enums.IssuingStrategy[] | ListEnumIssuingStrategyFieldRefInput<$PrismaModel>
    not?: NestedEnumIssuingStrategyWithAggregatesFilter<$PrismaModel> | $Enums.IssuingStrategy
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIssuingStrategyFilter<$PrismaModel>
    _max?: NestedEnumIssuingStrategyFilter<$PrismaModel>
  }

  export type NestedEnumMEALNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MEAL | EnumMEALFieldRefInput<$PrismaModel> | null
    in?: $Enums.MEAL[] | ListEnumMEALFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MEAL[] | ListEnumMEALFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMEALNullableWithAggregatesFilter<$PrismaModel> | $Enums.MEAL | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumMEALNullableFilter<$PrismaModel>
    _max?: NestedEnumMEALNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type MedicalCertificateCreateWithoutPatientInput = {
    nameOfThePatient: string
    addressOfThePatient: string
    fitForDuty: $Enums.MedicalCertificateStatus
    dateOfSickness: Date | string
    recommendedLeaveDays: number
    natureOfTheDisease: string
    ageOfThePatient: number
    reccomendations: string
    time: Date | string
  }

  export type MedicalCertificateUncheckedCreateWithoutPatientInput = {
    id?: number
    nameOfThePatient: string
    addressOfThePatient: string
    fitForDuty: $Enums.MedicalCertificateStatus
    dateOfSickness: Date | string
    recommendedLeaveDays: number
    natureOfTheDisease: string
    ageOfThePatient: number
    reccomendations: string
    time: Date | string
  }

  export type MedicalCertificateCreateOrConnectWithoutPatientInput = {
    where: MedicalCertificateWhereUniqueInput
    create: XOR<MedicalCertificateCreateWithoutPatientInput, MedicalCertificateUncheckedCreateWithoutPatientInput>
  }

  export type MedicalCertificateCreateManyPatientInputEnvelope = {
    data: MedicalCertificateCreateManyPatientInput | MedicalCertificateCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type PatientHistoryCreateWithoutPatientInput = {
    description?: string | null
    type: $Enums.PatientHistoryType
    time?: Date | string
    name: string
  }

  export type PatientHistoryUncheckedCreateWithoutPatientInput = {
    id?: number
    description?: string | null
    type: $Enums.PatientHistoryType
    time?: Date | string
    name: string
  }

  export type PatientHistoryCreateOrConnectWithoutPatientInput = {
    where: PatientHistoryWhereUniqueInput
    create: XOR<PatientHistoryCreateWithoutPatientInput, PatientHistoryUncheckedCreateWithoutPatientInput>
  }

  export type PatientHistoryCreateManyPatientInputEnvelope = {
    data: PatientHistoryCreateManyPatientInput | PatientHistoryCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type PatientReportCreateWithoutPatientInput = {
    time?: Date | string
    reportType: ReportTypeCreateNestedOneWithoutPatientReportInput
    parameters?: ReportValueCreateNestedManyWithoutPatientReportInput
  }

  export type PatientReportUncheckedCreateWithoutPatientInput = {
    id?: number
    reportTypeId: number
    time?: Date | string
    parameters?: ReportValueUncheckedCreateNestedManyWithoutPatientReportInput
  }

  export type PatientReportCreateOrConnectWithoutPatientInput = {
    where: PatientReportWhereUniqueInput
    create: XOR<PatientReportCreateWithoutPatientInput, PatientReportUncheckedCreateWithoutPatientInput>
  }

  export type PatientReportCreateManyPatientInputEnvelope = {
    data: PatientReportCreateManyPatientInput | PatientReportCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type PrescriptionCreateWithoutPatientInput = {
    time?: Date | string
    presentingSymptoms: string
    status?: $Enums.PrescriptionStatus
    details?: string | null
    finalPrice?: number | null
    issues?: IssueCreateNestedManyWithoutPrescriptionInput
    OffRecordMeds?: OffRecordMedsCreateNestedManyWithoutPrescriptionInput
    PrescriptionVitals?: PrescriptionVitalsCreateNestedManyWithoutPrescriptionInput
    Charges?: PrescriptionChargesCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionUncheckedCreateWithoutPatientInput = {
    id?: number
    time?: Date | string
    presentingSymptoms: string
    status?: $Enums.PrescriptionStatus
    details?: string | null
    finalPrice?: number | null
    issues?: IssueUncheckedCreateNestedManyWithoutPrescriptionInput
    OffRecordMeds?: OffRecordMedsUncheckedCreateNestedManyWithoutPrescriptionInput
    PrescriptionVitals?: PrescriptionVitalsUncheckedCreateNestedManyWithoutPrescriptionInput
    Charges?: PrescriptionChargesUncheckedCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionCreateOrConnectWithoutPatientInput = {
    where: PrescriptionWhereUniqueInput
    create: XOR<PrescriptionCreateWithoutPatientInput, PrescriptionUncheckedCreateWithoutPatientInput>
  }

  export type PrescriptionCreateManyPatientInputEnvelope = {
    data: PrescriptionCreateManyPatientInput | PrescriptionCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type QueueEntryCreateWithoutPatientInput = {
    token: number
    status?: $Enums.VisitStatus
    time?: Date | string
    queue: QueueCreateNestedOneWithoutEntriesInput
  }

  export type QueueEntryUncheckedCreateWithoutPatientInput = {
    id?: number
    token: number
    status?: $Enums.VisitStatus
    queueId: number
    time?: Date | string
  }

  export type QueueEntryCreateOrConnectWithoutPatientInput = {
    where: QueueEntryWhereUniqueInput
    create: XOR<QueueEntryCreateWithoutPatientInput, QueueEntryUncheckedCreateWithoutPatientInput>
  }

  export type QueueEntryCreateManyPatientInputEnvelope = {
    data: QueueEntryCreateManyPatientInput | QueueEntryCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type USSReferralCreateWithoutPatientInput = {
    nameOfThePatient: string
    presentingComplaint: string
    duration: string
    onExamination: string
    pshx_pmhx: string
    ageOfThePatient: number
    reportDate: Date | string
    USS_type: string
    radiologist: string
    radiologist_title: string
    time?: Date | string
  }

  export type USSReferralUncheckedCreateWithoutPatientInput = {
    id?: number
    nameOfThePatient: string
    presentingComplaint: string
    duration: string
    onExamination: string
    pshx_pmhx: string
    ageOfThePatient: number
    reportDate: Date | string
    USS_type: string
    radiologist: string
    radiologist_title: string
    time?: Date | string
  }

  export type USSReferralCreateOrConnectWithoutPatientInput = {
    where: USSReferralWhereUniqueInput
    create: XOR<USSReferralCreateWithoutPatientInput, USSReferralUncheckedCreateWithoutPatientInput>
  }

  export type USSReferralCreateManyPatientInputEnvelope = {
    data: USSReferralCreateManyPatientInput | USSReferralCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type ReferralLetterCreateWithoutPatientInput = {
    nameOfThePatient: string
    consultant_speciality: string
    consultant_name: string
    condition1: string
    condition2: string
    condition3: string
    investigations: string
    ageOfThePatient: number
    reportDate: Date | string
    time?: Date | string
  }

  export type ReferralLetterUncheckedCreateWithoutPatientInput = {
    id?: number
    nameOfThePatient: string
    consultant_speciality: string
    consultant_name: string
    condition1: string
    condition2: string
    condition3: string
    investigations: string
    ageOfThePatient: number
    reportDate: Date | string
    time?: Date | string
  }

  export type ReferralLetterCreateOrConnectWithoutPatientInput = {
    where: ReferralLetterWhereUniqueInput
    create: XOR<ReferralLetterCreateWithoutPatientInput, ReferralLetterUncheckedCreateWithoutPatientInput>
  }

  export type ReferralLetterCreateManyPatientInputEnvelope = {
    data: ReferralLetterCreateManyPatientInput | ReferralLetterCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type MedicalCertificateUpsertWithWhereUniqueWithoutPatientInput = {
    where: MedicalCertificateWhereUniqueInput
    update: XOR<MedicalCertificateUpdateWithoutPatientInput, MedicalCertificateUncheckedUpdateWithoutPatientInput>
    create: XOR<MedicalCertificateCreateWithoutPatientInput, MedicalCertificateUncheckedCreateWithoutPatientInput>
  }

  export type MedicalCertificateUpdateWithWhereUniqueWithoutPatientInput = {
    where: MedicalCertificateWhereUniqueInput
    data: XOR<MedicalCertificateUpdateWithoutPatientInput, MedicalCertificateUncheckedUpdateWithoutPatientInput>
  }

  export type MedicalCertificateUpdateManyWithWhereWithoutPatientInput = {
    where: MedicalCertificateScalarWhereInput
    data: XOR<MedicalCertificateUpdateManyMutationInput, MedicalCertificateUncheckedUpdateManyWithoutPatientInput>
  }

  export type MedicalCertificateScalarWhereInput = {
    AND?: MedicalCertificateScalarWhereInput | MedicalCertificateScalarWhereInput[]
    OR?: MedicalCertificateScalarWhereInput[]
    NOT?: MedicalCertificateScalarWhereInput | MedicalCertificateScalarWhereInput[]
    id?: IntFilter<"MedicalCertificate"> | number
    patientId?: IntFilter<"MedicalCertificate"> | number
    nameOfThePatient?: StringFilter<"MedicalCertificate"> | string
    addressOfThePatient?: StringFilter<"MedicalCertificate"> | string
    fitForDuty?: EnumMedicalCertificateStatusFilter<"MedicalCertificate"> | $Enums.MedicalCertificateStatus
    dateOfSickness?: DateTimeFilter<"MedicalCertificate"> | Date | string
    recommendedLeaveDays?: IntFilter<"MedicalCertificate"> | number
    natureOfTheDisease?: StringFilter<"MedicalCertificate"> | string
    ageOfThePatient?: IntFilter<"MedicalCertificate"> | number
    reccomendations?: StringFilter<"MedicalCertificate"> | string
    time?: DateTimeFilter<"MedicalCertificate"> | Date | string
  }

  export type PatientHistoryUpsertWithWhereUniqueWithoutPatientInput = {
    where: PatientHistoryWhereUniqueInput
    update: XOR<PatientHistoryUpdateWithoutPatientInput, PatientHistoryUncheckedUpdateWithoutPatientInput>
    create: XOR<PatientHistoryCreateWithoutPatientInput, PatientHistoryUncheckedCreateWithoutPatientInput>
  }

  export type PatientHistoryUpdateWithWhereUniqueWithoutPatientInput = {
    where: PatientHistoryWhereUniqueInput
    data: XOR<PatientHistoryUpdateWithoutPatientInput, PatientHistoryUncheckedUpdateWithoutPatientInput>
  }

  export type PatientHistoryUpdateManyWithWhereWithoutPatientInput = {
    where: PatientHistoryScalarWhereInput
    data: XOR<PatientHistoryUpdateManyMutationInput, PatientHistoryUncheckedUpdateManyWithoutPatientInput>
  }

  export type PatientHistoryScalarWhereInput = {
    AND?: PatientHistoryScalarWhereInput | PatientHistoryScalarWhereInput[]
    OR?: PatientHistoryScalarWhereInput[]
    NOT?: PatientHistoryScalarWhereInput | PatientHistoryScalarWhereInput[]
    id?: IntFilter<"PatientHistory"> | number
    patientId?: IntFilter<"PatientHistory"> | number
    description?: StringNullableFilter<"PatientHistory"> | string | null
    type?: EnumPatientHistoryTypeFilter<"PatientHistory"> | $Enums.PatientHistoryType
    time?: DateTimeFilter<"PatientHistory"> | Date | string
    name?: StringFilter<"PatientHistory"> | string
  }

  export type PatientReportUpsertWithWhereUniqueWithoutPatientInput = {
    where: PatientReportWhereUniqueInput
    update: XOR<PatientReportUpdateWithoutPatientInput, PatientReportUncheckedUpdateWithoutPatientInput>
    create: XOR<PatientReportCreateWithoutPatientInput, PatientReportUncheckedCreateWithoutPatientInput>
  }

  export type PatientReportUpdateWithWhereUniqueWithoutPatientInput = {
    where: PatientReportWhereUniqueInput
    data: XOR<PatientReportUpdateWithoutPatientInput, PatientReportUncheckedUpdateWithoutPatientInput>
  }

  export type PatientReportUpdateManyWithWhereWithoutPatientInput = {
    where: PatientReportScalarWhereInput
    data: XOR<PatientReportUpdateManyMutationInput, PatientReportUncheckedUpdateManyWithoutPatientInput>
  }

  export type PatientReportScalarWhereInput = {
    AND?: PatientReportScalarWhereInput | PatientReportScalarWhereInput[]
    OR?: PatientReportScalarWhereInput[]
    NOT?: PatientReportScalarWhereInput | PatientReportScalarWhereInput[]
    id?: IntFilter<"PatientReport"> | number
    patientId?: IntFilter<"PatientReport"> | number
    reportTypeId?: IntFilter<"PatientReport"> | number
    time?: DateTimeFilter<"PatientReport"> | Date | string
  }

  export type PrescriptionUpsertWithWhereUniqueWithoutPatientInput = {
    where: PrescriptionWhereUniqueInput
    update: XOR<PrescriptionUpdateWithoutPatientInput, PrescriptionUncheckedUpdateWithoutPatientInput>
    create: XOR<PrescriptionCreateWithoutPatientInput, PrescriptionUncheckedCreateWithoutPatientInput>
  }

  export type PrescriptionUpdateWithWhereUniqueWithoutPatientInput = {
    where: PrescriptionWhereUniqueInput
    data: XOR<PrescriptionUpdateWithoutPatientInput, PrescriptionUncheckedUpdateWithoutPatientInput>
  }

  export type PrescriptionUpdateManyWithWhereWithoutPatientInput = {
    where: PrescriptionScalarWhereInput
    data: XOR<PrescriptionUpdateManyMutationInput, PrescriptionUncheckedUpdateManyWithoutPatientInput>
  }

  export type PrescriptionScalarWhereInput = {
    AND?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
    OR?: PrescriptionScalarWhereInput[]
    NOT?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
    id?: IntFilter<"Prescription"> | number
    time?: DateTimeFilter<"Prescription"> | Date | string
    presentingSymptoms?: StringFilter<"Prescription"> | string
    status?: EnumPrescriptionStatusFilter<"Prescription"> | $Enums.PrescriptionStatus
    details?: StringNullableFilter<"Prescription"> | string | null
    patientId?: IntFilter<"Prescription"> | number
    finalPrice?: FloatNullableFilter<"Prescription"> | number | null
  }

  export type QueueEntryUpsertWithWhereUniqueWithoutPatientInput = {
    where: QueueEntryWhereUniqueInput
    update: XOR<QueueEntryUpdateWithoutPatientInput, QueueEntryUncheckedUpdateWithoutPatientInput>
    create: XOR<QueueEntryCreateWithoutPatientInput, QueueEntryUncheckedCreateWithoutPatientInput>
  }

  export type QueueEntryUpdateWithWhereUniqueWithoutPatientInput = {
    where: QueueEntryWhereUniqueInput
    data: XOR<QueueEntryUpdateWithoutPatientInput, QueueEntryUncheckedUpdateWithoutPatientInput>
  }

  export type QueueEntryUpdateManyWithWhereWithoutPatientInput = {
    where: QueueEntryScalarWhereInput
    data: XOR<QueueEntryUpdateManyMutationInput, QueueEntryUncheckedUpdateManyWithoutPatientInput>
  }

  export type QueueEntryScalarWhereInput = {
    AND?: QueueEntryScalarWhereInput | QueueEntryScalarWhereInput[]
    OR?: QueueEntryScalarWhereInput[]
    NOT?: QueueEntryScalarWhereInput | QueueEntryScalarWhereInput[]
    id?: IntFilter<"QueueEntry"> | number
    token?: IntFilter<"QueueEntry"> | number
    status?: EnumVisitStatusFilter<"QueueEntry"> | $Enums.VisitStatus
    queueId?: IntFilter<"QueueEntry"> | number
    patientId?: IntFilter<"QueueEntry"> | number
    time?: DateTimeFilter<"QueueEntry"> | Date | string
  }

  export type USSReferralUpsertWithWhereUniqueWithoutPatientInput = {
    where: USSReferralWhereUniqueInput
    update: XOR<USSReferralUpdateWithoutPatientInput, USSReferralUncheckedUpdateWithoutPatientInput>
    create: XOR<USSReferralCreateWithoutPatientInput, USSReferralUncheckedCreateWithoutPatientInput>
  }

  export type USSReferralUpdateWithWhereUniqueWithoutPatientInput = {
    where: USSReferralWhereUniqueInput
    data: XOR<USSReferralUpdateWithoutPatientInput, USSReferralUncheckedUpdateWithoutPatientInput>
  }

  export type USSReferralUpdateManyWithWhereWithoutPatientInput = {
    where: USSReferralScalarWhereInput
    data: XOR<USSReferralUpdateManyMutationInput, USSReferralUncheckedUpdateManyWithoutPatientInput>
  }

  export type USSReferralScalarWhereInput = {
    AND?: USSReferralScalarWhereInput | USSReferralScalarWhereInput[]
    OR?: USSReferralScalarWhereInput[]
    NOT?: USSReferralScalarWhereInput | USSReferralScalarWhereInput[]
    id?: IntFilter<"USSReferral"> | number
    patientId?: IntFilter<"USSReferral"> | number
    nameOfThePatient?: StringFilter<"USSReferral"> | string
    presentingComplaint?: StringFilter<"USSReferral"> | string
    duration?: StringFilter<"USSReferral"> | string
    onExamination?: StringFilter<"USSReferral"> | string
    pshx_pmhx?: StringFilter<"USSReferral"> | string
    ageOfThePatient?: IntFilter<"USSReferral"> | number
    reportDate?: DateTimeFilter<"USSReferral"> | Date | string
    USS_type?: StringFilter<"USSReferral"> | string
    radiologist?: StringFilter<"USSReferral"> | string
    radiologist_title?: StringFilter<"USSReferral"> | string
    time?: DateTimeFilter<"USSReferral"> | Date | string
  }

  export type ReferralLetterUpsertWithWhereUniqueWithoutPatientInput = {
    where: ReferralLetterWhereUniqueInput
    update: XOR<ReferralLetterUpdateWithoutPatientInput, ReferralLetterUncheckedUpdateWithoutPatientInput>
    create: XOR<ReferralLetterCreateWithoutPatientInput, ReferralLetterUncheckedCreateWithoutPatientInput>
  }

  export type ReferralLetterUpdateWithWhereUniqueWithoutPatientInput = {
    where: ReferralLetterWhereUniqueInput
    data: XOR<ReferralLetterUpdateWithoutPatientInput, ReferralLetterUncheckedUpdateWithoutPatientInput>
  }

  export type ReferralLetterUpdateManyWithWhereWithoutPatientInput = {
    where: ReferralLetterScalarWhereInput
    data: XOR<ReferralLetterUpdateManyMutationInput, ReferralLetterUncheckedUpdateManyWithoutPatientInput>
  }

  export type ReferralLetterScalarWhereInput = {
    AND?: ReferralLetterScalarWhereInput | ReferralLetterScalarWhereInput[]
    OR?: ReferralLetterScalarWhereInput[]
    NOT?: ReferralLetterScalarWhereInput | ReferralLetterScalarWhereInput[]
    id?: IntFilter<"ReferralLetter"> | number
    patientId?: IntFilter<"ReferralLetter"> | number
    nameOfThePatient?: StringFilter<"ReferralLetter"> | string
    consultant_speciality?: StringFilter<"ReferralLetter"> | string
    consultant_name?: StringFilter<"ReferralLetter"> | string
    condition1?: StringFilter<"ReferralLetter"> | string
    condition2?: StringFilter<"ReferralLetter"> | string
    condition3?: StringFilter<"ReferralLetter"> | string
    investigations?: StringFilter<"ReferralLetter"> | string
    ageOfThePatient?: IntFilter<"ReferralLetter"> | number
    reportDate?: DateTimeFilter<"ReferralLetter"> | Date | string
    time?: DateTimeFilter<"ReferralLetter"> | Date | string
  }

  export type PatientCreateWithoutPatientHistoryInput = {
    telephone: string
    name: string
    birthDate?: Date | string | null
    address?: string | null
    height?: number | null
    weight?: number | null
    gender: $Enums.Gender
    NIC?: string | null
    medicalCert?: MedicalCertificateCreateNestedManyWithoutPatientInput
    reports?: PatientReportCreateNestedManyWithoutPatientInput
    prescription?: PrescriptionCreateNestedManyWithoutPatientInput
    queueEntry?: QueueEntryCreateNestedManyWithoutPatientInput
    USSReferral?: USSReferralCreateNestedManyWithoutPatientInput
    referralLetters?: ReferralLetterCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutPatientHistoryInput = {
    id?: number
    telephone: string
    name: string
    birthDate?: Date | string | null
    address?: string | null
    height?: number | null
    weight?: number | null
    gender: $Enums.Gender
    NIC?: string | null
    medicalCert?: MedicalCertificateUncheckedCreateNestedManyWithoutPatientInput
    reports?: PatientReportUncheckedCreateNestedManyWithoutPatientInput
    prescription?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    queueEntry?: QueueEntryUncheckedCreateNestedManyWithoutPatientInput
    USSReferral?: USSReferralUncheckedCreateNestedManyWithoutPatientInput
    referralLetters?: ReferralLetterUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutPatientHistoryInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutPatientHistoryInput, PatientUncheckedCreateWithoutPatientHistoryInput>
  }

  export type PatientUpsertWithoutPatientHistoryInput = {
    update: XOR<PatientUpdateWithoutPatientHistoryInput, PatientUncheckedUpdateWithoutPatientHistoryInput>
    create: XOR<PatientCreateWithoutPatientHistoryInput, PatientUncheckedCreateWithoutPatientHistoryInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutPatientHistoryInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutPatientHistoryInput, PatientUncheckedUpdateWithoutPatientHistoryInput>
  }

  export type PatientUpdateWithoutPatientHistoryInput = {
    telephone?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
    medicalCert?: MedicalCertificateUpdateManyWithoutPatientNestedInput
    reports?: PatientReportUpdateManyWithoutPatientNestedInput
    prescription?: PrescriptionUpdateManyWithoutPatientNestedInput
    queueEntry?: QueueEntryUpdateManyWithoutPatientNestedInput
    USSReferral?: USSReferralUpdateManyWithoutPatientNestedInput
    referralLetters?: ReferralLetterUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutPatientHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    telephone?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
    medicalCert?: MedicalCertificateUncheckedUpdateManyWithoutPatientNestedInput
    reports?: PatientReportUncheckedUpdateManyWithoutPatientNestedInput
    prescription?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    queueEntry?: QueueEntryUncheckedUpdateManyWithoutPatientNestedInput
    USSReferral?: USSReferralUncheckedUpdateManyWithoutPatientNestedInput
    referralLetters?: ReferralLetterUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type QueueEntryCreateWithoutQueueInput = {
    token: number
    status?: $Enums.VisitStatus
    time?: Date | string
    patient: PatientCreateNestedOneWithoutQueueEntryInput
  }

  export type QueueEntryUncheckedCreateWithoutQueueInput = {
    id?: number
    token: number
    status?: $Enums.VisitStatus
    patientId: number
    time?: Date | string
  }

  export type QueueEntryCreateOrConnectWithoutQueueInput = {
    where: QueueEntryWhereUniqueInput
    create: XOR<QueueEntryCreateWithoutQueueInput, QueueEntryUncheckedCreateWithoutQueueInput>
  }

  export type QueueEntryCreateManyQueueInputEnvelope = {
    data: QueueEntryCreateManyQueueInput | QueueEntryCreateManyQueueInput[]
    skipDuplicates?: boolean
  }

  export type QueueEntryUpsertWithWhereUniqueWithoutQueueInput = {
    where: QueueEntryWhereUniqueInput
    update: XOR<QueueEntryUpdateWithoutQueueInput, QueueEntryUncheckedUpdateWithoutQueueInput>
    create: XOR<QueueEntryCreateWithoutQueueInput, QueueEntryUncheckedCreateWithoutQueueInput>
  }

  export type QueueEntryUpdateWithWhereUniqueWithoutQueueInput = {
    where: QueueEntryWhereUniqueInput
    data: XOR<QueueEntryUpdateWithoutQueueInput, QueueEntryUncheckedUpdateWithoutQueueInput>
  }

  export type QueueEntryUpdateManyWithWhereWithoutQueueInput = {
    where: QueueEntryScalarWhereInput
    data: XOR<QueueEntryUpdateManyMutationInput, QueueEntryUncheckedUpdateManyWithoutQueueInput>
  }

  export type PatientCreateWithoutQueueEntryInput = {
    telephone: string
    name: string
    birthDate?: Date | string | null
    address?: string | null
    height?: number | null
    weight?: number | null
    gender: $Enums.Gender
    NIC?: string | null
    medicalCert?: MedicalCertificateCreateNestedManyWithoutPatientInput
    PatientHistory?: PatientHistoryCreateNestedManyWithoutPatientInput
    reports?: PatientReportCreateNestedManyWithoutPatientInput
    prescription?: PrescriptionCreateNestedManyWithoutPatientInput
    USSReferral?: USSReferralCreateNestedManyWithoutPatientInput
    referralLetters?: ReferralLetterCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutQueueEntryInput = {
    id?: number
    telephone: string
    name: string
    birthDate?: Date | string | null
    address?: string | null
    height?: number | null
    weight?: number | null
    gender: $Enums.Gender
    NIC?: string | null
    medicalCert?: MedicalCertificateUncheckedCreateNestedManyWithoutPatientInput
    PatientHistory?: PatientHistoryUncheckedCreateNestedManyWithoutPatientInput
    reports?: PatientReportUncheckedCreateNestedManyWithoutPatientInput
    prescription?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    USSReferral?: USSReferralUncheckedCreateNestedManyWithoutPatientInput
    referralLetters?: ReferralLetterUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutQueueEntryInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutQueueEntryInput, PatientUncheckedCreateWithoutQueueEntryInput>
  }

  export type QueueCreateWithoutEntriesInput = {
    start?: Date | string
    end?: Date | string | null
    status?: $Enums.QueueStatus
  }

  export type QueueUncheckedCreateWithoutEntriesInput = {
    id?: number
    start?: Date | string
    end?: Date | string | null
    status?: $Enums.QueueStatus
  }

  export type QueueCreateOrConnectWithoutEntriesInput = {
    where: QueueWhereUniqueInput
    create: XOR<QueueCreateWithoutEntriesInput, QueueUncheckedCreateWithoutEntriesInput>
  }

  export type PatientUpsertWithoutQueueEntryInput = {
    update: XOR<PatientUpdateWithoutQueueEntryInput, PatientUncheckedUpdateWithoutQueueEntryInput>
    create: XOR<PatientCreateWithoutQueueEntryInput, PatientUncheckedCreateWithoutQueueEntryInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutQueueEntryInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutQueueEntryInput, PatientUncheckedUpdateWithoutQueueEntryInput>
  }

  export type PatientUpdateWithoutQueueEntryInput = {
    telephone?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
    medicalCert?: MedicalCertificateUpdateManyWithoutPatientNestedInput
    PatientHistory?: PatientHistoryUpdateManyWithoutPatientNestedInput
    reports?: PatientReportUpdateManyWithoutPatientNestedInput
    prescription?: PrescriptionUpdateManyWithoutPatientNestedInput
    USSReferral?: USSReferralUpdateManyWithoutPatientNestedInput
    referralLetters?: ReferralLetterUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutQueueEntryInput = {
    id?: IntFieldUpdateOperationsInput | number
    telephone?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
    medicalCert?: MedicalCertificateUncheckedUpdateManyWithoutPatientNestedInput
    PatientHistory?: PatientHistoryUncheckedUpdateManyWithoutPatientNestedInput
    reports?: PatientReportUncheckedUpdateManyWithoutPatientNestedInput
    prescription?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    USSReferral?: USSReferralUncheckedUpdateManyWithoutPatientNestedInput
    referralLetters?: ReferralLetterUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type QueueUpsertWithoutEntriesInput = {
    update: XOR<QueueUpdateWithoutEntriesInput, QueueUncheckedUpdateWithoutEntriesInput>
    create: XOR<QueueCreateWithoutEntriesInput, QueueUncheckedCreateWithoutEntriesInput>
    where?: QueueWhereInput
  }

  export type QueueUpdateToOneWithWhereWithoutEntriesInput = {
    where?: QueueWhereInput
    data: XOR<QueueUpdateWithoutEntriesInput, QueueUncheckedUpdateWithoutEntriesInput>
  }

  export type QueueUpdateWithoutEntriesInput = {
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus
  }

  export type QueueUncheckedUpdateWithoutEntriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus
  }

  export type BatchCreateWithoutDrugBrandInput = {
    number: string
    type: $Enums.DrugType
    fullAmount: number
    expiry: Date | string
    stockDate?: Date | string
    remainingQuantity: number
    wholesalePrice: number
    retailPrice: number
    status: $Enums.BatchStatus
    drug: DrugCreateNestedOneWithoutBatchInput
    Supplier: SupplierCreateNestedOneWithoutBatchesInput
    unitConcentration: UnitConcentrationCreateNestedOneWithoutBatchInput
    BatchHistory?: BatchHistoryCreateNestedManyWithoutBatchInput
    Issue?: IssueCreateNestedManyWithoutBatchInput
  }

  export type BatchUncheckedCreateWithoutDrugBrandInput = {
    id?: number
    number: string
    drugId: number
    type: $Enums.DrugType
    fullAmount: number
    expiry: Date | string
    stockDate?: Date | string
    remainingQuantity: number
    wholesalePrice: number
    retailPrice: number
    status: $Enums.BatchStatus
    unitConcentrationId: number
    supplierId: number
    BatchHistory?: BatchHistoryUncheckedCreateNestedManyWithoutBatchInput
    Issue?: IssueUncheckedCreateNestedManyWithoutBatchInput
  }

  export type BatchCreateOrConnectWithoutDrugBrandInput = {
    where: BatchWhereUniqueInput
    create: XOR<BatchCreateWithoutDrugBrandInput, BatchUncheckedCreateWithoutDrugBrandInput>
  }

  export type BatchCreateManyDrugBrandInputEnvelope = {
    data: BatchCreateManyDrugBrandInput | BatchCreateManyDrugBrandInput[]
    skipDuplicates?: boolean
  }

  export type BatchHistoryCreateWithoutBrandInput = {
    type: $Enums.DrugType
    batch: BatchCreateNestedOneWithoutBatchHistoryInput
    drug: DrugCreateNestedOneWithoutBatchHistoryInput
    unitConcentration: UnitConcentrationCreateNestedOneWithoutBatchHistoryInput
  }

  export type BatchHistoryUncheckedCreateWithoutBrandInput = {
    id?: number
    drugId: number
    type: $Enums.DrugType
    unitConcentrationId: number
    batchId: number
  }

  export type BatchHistoryCreateOrConnectWithoutBrandInput = {
    where: BatchHistoryWhereUniqueInput
    create: XOR<BatchHistoryCreateWithoutBrandInput, BatchHistoryUncheckedCreateWithoutBrandInput>
  }

  export type BatchHistoryCreateManyBrandInputEnvelope = {
    data: BatchHistoryCreateManyBrandInput | BatchHistoryCreateManyBrandInput[]
    skipDuplicates?: boolean
  }

  export type IssueCreateWithoutBrandInput = {
    strategy: $Enums.IssuingStrategy
    quantity: number
    dose: number
    details?: string | null
    meal?: $Enums.MEAL | null
    type: $Enums.DrugType
    batch?: BatchCreateNestedOneWithoutIssueInput
    drug: DrugCreateNestedOneWithoutIssueInput
    prescription: PrescriptionCreateNestedOneWithoutIssuesInput
    unitConcentration: UnitConcentrationCreateNestedOneWithoutIssueInput
    stratergyHistory?: StratergyHistoryCreateNestedManyWithoutIssueInput
  }

  export type IssueUncheckedCreateWithoutBrandInput = {
    id?: number
    prescriptionId: number
    batchId?: number | null
    drugId: number
    strategy: $Enums.IssuingStrategy
    quantity: number
    dose: number
    details?: string | null
    meal?: $Enums.MEAL | null
    type: $Enums.DrugType
    unitConcentrationId: number
    stratergyHistory?: StratergyHistoryUncheckedCreateNestedManyWithoutIssueInput
  }

  export type IssueCreateOrConnectWithoutBrandInput = {
    where: IssueWhereUniqueInput
    create: XOR<IssueCreateWithoutBrandInput, IssueUncheckedCreateWithoutBrandInput>
  }

  export type IssueCreateManyBrandInputEnvelope = {
    data: IssueCreateManyBrandInput | IssueCreateManyBrandInput[]
    skipDuplicates?: boolean
  }

  export type BatchUpsertWithWhereUniqueWithoutDrugBrandInput = {
    where: BatchWhereUniqueInput
    update: XOR<BatchUpdateWithoutDrugBrandInput, BatchUncheckedUpdateWithoutDrugBrandInput>
    create: XOR<BatchCreateWithoutDrugBrandInput, BatchUncheckedCreateWithoutDrugBrandInput>
  }

  export type BatchUpdateWithWhereUniqueWithoutDrugBrandInput = {
    where: BatchWhereUniqueInput
    data: XOR<BatchUpdateWithoutDrugBrandInput, BatchUncheckedUpdateWithoutDrugBrandInput>
  }

  export type BatchUpdateManyWithWhereWithoutDrugBrandInput = {
    where: BatchScalarWhereInput
    data: XOR<BatchUpdateManyMutationInput, BatchUncheckedUpdateManyWithoutDrugBrandInput>
  }

  export type BatchScalarWhereInput = {
    AND?: BatchScalarWhereInput | BatchScalarWhereInput[]
    OR?: BatchScalarWhereInput[]
    NOT?: BatchScalarWhereInput | BatchScalarWhereInput[]
    id?: IntFilter<"Batch"> | number
    number?: StringFilter<"Batch"> | string
    drugId?: IntFilter<"Batch"> | number
    drugBrandId?: IntFilter<"Batch"> | number
    type?: EnumDrugTypeFilter<"Batch"> | $Enums.DrugType
    fullAmount?: FloatFilter<"Batch"> | number
    expiry?: DateTimeFilter<"Batch"> | Date | string
    stockDate?: DateTimeFilter<"Batch"> | Date | string
    remainingQuantity?: FloatFilter<"Batch"> | number
    wholesalePrice?: FloatFilter<"Batch"> | number
    retailPrice?: FloatFilter<"Batch"> | number
    status?: EnumBatchStatusFilter<"Batch"> | $Enums.BatchStatus
    unitConcentrationId?: IntFilter<"Batch"> | number
    supplierId?: IntFilter<"Batch"> | number
  }

  export type BatchHistoryUpsertWithWhereUniqueWithoutBrandInput = {
    where: BatchHistoryWhereUniqueInput
    update: XOR<BatchHistoryUpdateWithoutBrandInput, BatchHistoryUncheckedUpdateWithoutBrandInput>
    create: XOR<BatchHistoryCreateWithoutBrandInput, BatchHistoryUncheckedCreateWithoutBrandInput>
  }

  export type BatchHistoryUpdateWithWhereUniqueWithoutBrandInput = {
    where: BatchHistoryWhereUniqueInput
    data: XOR<BatchHistoryUpdateWithoutBrandInput, BatchHistoryUncheckedUpdateWithoutBrandInput>
  }

  export type BatchHistoryUpdateManyWithWhereWithoutBrandInput = {
    where: BatchHistoryScalarWhereInput
    data: XOR<BatchHistoryUpdateManyMutationInput, BatchHistoryUncheckedUpdateManyWithoutBrandInput>
  }

  export type BatchHistoryScalarWhereInput = {
    AND?: BatchHistoryScalarWhereInput | BatchHistoryScalarWhereInput[]
    OR?: BatchHistoryScalarWhereInput[]
    NOT?: BatchHistoryScalarWhereInput | BatchHistoryScalarWhereInput[]
    id?: IntFilter<"BatchHistory"> | number
    drugId?: IntFilter<"BatchHistory"> | number
    type?: EnumDrugTypeFilter<"BatchHistory"> | $Enums.DrugType
    unitConcentrationId?: IntFilter<"BatchHistory"> | number
    drugBrandId?: IntFilter<"BatchHistory"> | number
    batchId?: IntFilter<"BatchHistory"> | number
  }

  export type IssueUpsertWithWhereUniqueWithoutBrandInput = {
    where: IssueWhereUniqueInput
    update: XOR<IssueUpdateWithoutBrandInput, IssueUncheckedUpdateWithoutBrandInput>
    create: XOR<IssueCreateWithoutBrandInput, IssueUncheckedCreateWithoutBrandInput>
  }

  export type IssueUpdateWithWhereUniqueWithoutBrandInput = {
    where: IssueWhereUniqueInput
    data: XOR<IssueUpdateWithoutBrandInput, IssueUncheckedUpdateWithoutBrandInput>
  }

  export type IssueUpdateManyWithWhereWithoutBrandInput = {
    where: IssueScalarWhereInput
    data: XOR<IssueUpdateManyMutationInput, IssueUncheckedUpdateManyWithoutBrandInput>
  }

  export type IssueScalarWhereInput = {
    AND?: IssueScalarWhereInput | IssueScalarWhereInput[]
    OR?: IssueScalarWhereInput[]
    NOT?: IssueScalarWhereInput | IssueScalarWhereInput[]
    id?: IntFilter<"Issue"> | number
    prescriptionId?: IntFilter<"Issue"> | number
    batchId?: IntNullableFilter<"Issue"> | number | null
    drugId?: IntFilter<"Issue"> | number
    brandId?: IntFilter<"Issue"> | number
    strategy?: EnumIssuingStrategyFilter<"Issue"> | $Enums.IssuingStrategy
    quantity?: FloatFilter<"Issue"> | number
    dose?: FloatFilter<"Issue"> | number
    details?: StringNullableFilter<"Issue"> | string | null
    meal?: EnumMEALNullableFilter<"Issue"> | $Enums.MEAL | null
    type?: EnumDrugTypeFilter<"Issue"> | $Enums.DrugType
    unitConcentrationId?: IntFilter<"Issue"> | number
  }

  export type BatchCreateWithoutDrugInput = {
    number: string
    type: $Enums.DrugType
    fullAmount: number
    expiry: Date | string
    stockDate?: Date | string
    remainingQuantity: number
    wholesalePrice: number
    retailPrice: number
    status: $Enums.BatchStatus
    drugBrand: DrugBrandCreateNestedOneWithoutBatchInput
    Supplier: SupplierCreateNestedOneWithoutBatchesInput
    unitConcentration: UnitConcentrationCreateNestedOneWithoutBatchInput
    BatchHistory?: BatchHistoryCreateNestedManyWithoutBatchInput
    Issue?: IssueCreateNestedManyWithoutBatchInput
  }

  export type BatchUncheckedCreateWithoutDrugInput = {
    id?: number
    number: string
    drugBrandId: number
    type: $Enums.DrugType
    fullAmount: number
    expiry: Date | string
    stockDate?: Date | string
    remainingQuantity: number
    wholesalePrice: number
    retailPrice: number
    status: $Enums.BatchStatus
    unitConcentrationId: number
    supplierId: number
    BatchHistory?: BatchHistoryUncheckedCreateNestedManyWithoutBatchInput
    Issue?: IssueUncheckedCreateNestedManyWithoutBatchInput
  }

  export type BatchCreateOrConnectWithoutDrugInput = {
    where: BatchWhereUniqueInput
    create: XOR<BatchCreateWithoutDrugInput, BatchUncheckedCreateWithoutDrugInput>
  }

  export type BatchCreateManyDrugInputEnvelope = {
    data: BatchCreateManyDrugInput | BatchCreateManyDrugInput[]
    skipDuplicates?: boolean
  }

  export type BatchHistoryCreateWithoutDrugInput = {
    type: $Enums.DrugType
    batch: BatchCreateNestedOneWithoutBatchHistoryInput
    brand: DrugBrandCreateNestedOneWithoutBatchHistoryInput
    unitConcentration: UnitConcentrationCreateNestedOneWithoutBatchHistoryInput
  }

  export type BatchHistoryUncheckedCreateWithoutDrugInput = {
    id?: number
    type: $Enums.DrugType
    unitConcentrationId: number
    drugBrandId: number
    batchId: number
  }

  export type BatchHistoryCreateOrConnectWithoutDrugInput = {
    where: BatchHistoryWhereUniqueInput
    create: XOR<BatchHistoryCreateWithoutDrugInput, BatchHistoryUncheckedCreateWithoutDrugInput>
  }

  export type BatchHistoryCreateManyDrugInputEnvelope = {
    data: BatchHistoryCreateManyDrugInput | BatchHistoryCreateManyDrugInput[]
    skipDuplicates?: boolean
  }

  export type IssueCreateWithoutDrugInput = {
    strategy: $Enums.IssuingStrategy
    quantity: number
    dose: number
    details?: string | null
    meal?: $Enums.MEAL | null
    type: $Enums.DrugType
    batch?: BatchCreateNestedOneWithoutIssueInput
    brand: DrugBrandCreateNestedOneWithoutIssueInput
    prescription: PrescriptionCreateNestedOneWithoutIssuesInput
    unitConcentration: UnitConcentrationCreateNestedOneWithoutIssueInput
    stratergyHistory?: StratergyHistoryCreateNestedManyWithoutIssueInput
  }

  export type IssueUncheckedCreateWithoutDrugInput = {
    id?: number
    prescriptionId: number
    batchId?: number | null
    brandId: number
    strategy: $Enums.IssuingStrategy
    quantity: number
    dose: number
    details?: string | null
    meal?: $Enums.MEAL | null
    type: $Enums.DrugType
    unitConcentrationId: number
    stratergyHistory?: StratergyHistoryUncheckedCreateNestedManyWithoutIssueInput
  }

  export type IssueCreateOrConnectWithoutDrugInput = {
    where: IssueWhereUniqueInput
    create: XOR<IssueCreateWithoutDrugInput, IssueUncheckedCreateWithoutDrugInput>
  }

  export type IssueCreateManyDrugInputEnvelope = {
    data: IssueCreateManyDrugInput | IssueCreateManyDrugInput[]
    skipDuplicates?: boolean
  }

  export type StratergyHistoryCreateWithoutDrugInput = {
    issue: IssueCreateNestedOneWithoutStratergyHistoryInput
  }

  export type StratergyHistoryUncheckedCreateWithoutDrugInput = {
    id?: number
    issueId: number
  }

  export type StratergyHistoryCreateOrConnectWithoutDrugInput = {
    where: StratergyHistoryWhereUniqueInput
    create: XOR<StratergyHistoryCreateWithoutDrugInput, StratergyHistoryUncheckedCreateWithoutDrugInput>
  }

  export type BufferLevelCreateWithoutDrugInput = {
    type: $Enums.DrugType
    bufferAmount: number
    unitConcentration: UnitConcentrationCreateNestedOneWithoutBufferLevelInput
  }

  export type BufferLevelUncheckedCreateWithoutDrugInput = {
    id?: number
    type: $Enums.DrugType
    unitConcentrationId: number
    bufferAmount: number
  }

  export type BufferLevelCreateOrConnectWithoutDrugInput = {
    where: BufferLevelWhereUniqueInput
    create: XOR<BufferLevelCreateWithoutDrugInput, BufferLevelUncheckedCreateWithoutDrugInput>
  }

  export type BufferLevelCreateManyDrugInputEnvelope = {
    data: BufferLevelCreateManyDrugInput | BufferLevelCreateManyDrugInput[]
    skipDuplicates?: boolean
  }

  export type BatchUpsertWithWhereUniqueWithoutDrugInput = {
    where: BatchWhereUniqueInput
    update: XOR<BatchUpdateWithoutDrugInput, BatchUncheckedUpdateWithoutDrugInput>
    create: XOR<BatchCreateWithoutDrugInput, BatchUncheckedCreateWithoutDrugInput>
  }

  export type BatchUpdateWithWhereUniqueWithoutDrugInput = {
    where: BatchWhereUniqueInput
    data: XOR<BatchUpdateWithoutDrugInput, BatchUncheckedUpdateWithoutDrugInput>
  }

  export type BatchUpdateManyWithWhereWithoutDrugInput = {
    where: BatchScalarWhereInput
    data: XOR<BatchUpdateManyMutationInput, BatchUncheckedUpdateManyWithoutDrugInput>
  }

  export type BatchHistoryUpsertWithWhereUniqueWithoutDrugInput = {
    where: BatchHistoryWhereUniqueInput
    update: XOR<BatchHistoryUpdateWithoutDrugInput, BatchHistoryUncheckedUpdateWithoutDrugInput>
    create: XOR<BatchHistoryCreateWithoutDrugInput, BatchHistoryUncheckedCreateWithoutDrugInput>
  }

  export type BatchHistoryUpdateWithWhereUniqueWithoutDrugInput = {
    where: BatchHistoryWhereUniqueInput
    data: XOR<BatchHistoryUpdateWithoutDrugInput, BatchHistoryUncheckedUpdateWithoutDrugInput>
  }

  export type BatchHistoryUpdateManyWithWhereWithoutDrugInput = {
    where: BatchHistoryScalarWhereInput
    data: XOR<BatchHistoryUpdateManyMutationInput, BatchHistoryUncheckedUpdateManyWithoutDrugInput>
  }

  export type IssueUpsertWithWhereUniqueWithoutDrugInput = {
    where: IssueWhereUniqueInput
    update: XOR<IssueUpdateWithoutDrugInput, IssueUncheckedUpdateWithoutDrugInput>
    create: XOR<IssueCreateWithoutDrugInput, IssueUncheckedCreateWithoutDrugInput>
  }

  export type IssueUpdateWithWhereUniqueWithoutDrugInput = {
    where: IssueWhereUniqueInput
    data: XOR<IssueUpdateWithoutDrugInput, IssueUncheckedUpdateWithoutDrugInput>
  }

  export type IssueUpdateManyWithWhereWithoutDrugInput = {
    where: IssueScalarWhereInput
    data: XOR<IssueUpdateManyMutationInput, IssueUncheckedUpdateManyWithoutDrugInput>
  }

  export type StratergyHistoryUpsertWithoutDrugInput = {
    update: XOR<StratergyHistoryUpdateWithoutDrugInput, StratergyHistoryUncheckedUpdateWithoutDrugInput>
    create: XOR<StratergyHistoryCreateWithoutDrugInput, StratergyHistoryUncheckedCreateWithoutDrugInput>
    where?: StratergyHistoryWhereInput
  }

  export type StratergyHistoryUpdateToOneWithWhereWithoutDrugInput = {
    where?: StratergyHistoryWhereInput
    data: XOR<StratergyHistoryUpdateWithoutDrugInput, StratergyHistoryUncheckedUpdateWithoutDrugInput>
  }

  export type StratergyHistoryUpdateWithoutDrugInput = {
    issue?: IssueUpdateOneRequiredWithoutStratergyHistoryNestedInput
  }

  export type StratergyHistoryUncheckedUpdateWithoutDrugInput = {
    id?: IntFieldUpdateOperationsInput | number
    issueId?: IntFieldUpdateOperationsInput | number
  }

  export type BufferLevelUpsertWithWhereUniqueWithoutDrugInput = {
    where: BufferLevelWhereUniqueInput
    update: XOR<BufferLevelUpdateWithoutDrugInput, BufferLevelUncheckedUpdateWithoutDrugInput>
    create: XOR<BufferLevelCreateWithoutDrugInput, BufferLevelUncheckedCreateWithoutDrugInput>
  }

  export type BufferLevelUpdateWithWhereUniqueWithoutDrugInput = {
    where: BufferLevelWhereUniqueInput
    data: XOR<BufferLevelUpdateWithoutDrugInput, BufferLevelUncheckedUpdateWithoutDrugInput>
  }

  export type BufferLevelUpdateManyWithWhereWithoutDrugInput = {
    where: BufferLevelScalarWhereInput
    data: XOR<BufferLevelUpdateManyMutationInput, BufferLevelUncheckedUpdateManyWithoutDrugInput>
  }

  export type BufferLevelScalarWhereInput = {
    AND?: BufferLevelScalarWhereInput | BufferLevelScalarWhereInput[]
    OR?: BufferLevelScalarWhereInput[]
    NOT?: BufferLevelScalarWhereInput | BufferLevelScalarWhereInput[]
    id?: IntFilter<"BufferLevel"> | number
    drugId?: IntFilter<"BufferLevel"> | number
    type?: EnumDrugTypeFilter<"BufferLevel"> | $Enums.DrugType
    unitConcentrationId?: IntFilter<"BufferLevel"> | number
    bufferAmount?: IntFilter<"BufferLevel"> | number
  }

  export type DrugCreateWithoutBufferLevelsInput = {
    name: string
    batch?: BatchCreateNestedManyWithoutDrugInput
    BatchHistory?: BatchHistoryCreateNestedManyWithoutDrugInput
    Issue?: IssueCreateNestedManyWithoutDrugInput
    stratergyHistory?: StratergyHistoryCreateNestedOneWithoutDrugInput
  }

  export type DrugUncheckedCreateWithoutBufferLevelsInput = {
    id?: number
    name: string
    batch?: BatchUncheckedCreateNestedManyWithoutDrugInput
    BatchHistory?: BatchHistoryUncheckedCreateNestedManyWithoutDrugInput
    Issue?: IssueUncheckedCreateNestedManyWithoutDrugInput
    stratergyHistory?: StratergyHistoryUncheckedCreateNestedOneWithoutDrugInput
  }

  export type DrugCreateOrConnectWithoutBufferLevelsInput = {
    where: DrugWhereUniqueInput
    create: XOR<DrugCreateWithoutBufferLevelsInput, DrugUncheckedCreateWithoutBufferLevelsInput>
  }

  export type UnitConcentrationCreateWithoutBufferLevelInput = {
    concentration: number
    Batch?: BatchCreateNestedManyWithoutUnitConcentrationInput
    BatchHistory?: BatchHistoryCreateNestedManyWithoutUnitConcentrationInput
    Issue?: IssueCreateNestedManyWithoutUnitConcentrationInput
  }

  export type UnitConcentrationUncheckedCreateWithoutBufferLevelInput = {
    id?: number
    concentration: number
    Batch?: BatchUncheckedCreateNestedManyWithoutUnitConcentrationInput
    BatchHistory?: BatchHistoryUncheckedCreateNestedManyWithoutUnitConcentrationInput
    Issue?: IssueUncheckedCreateNestedManyWithoutUnitConcentrationInput
  }

  export type UnitConcentrationCreateOrConnectWithoutBufferLevelInput = {
    where: UnitConcentrationWhereUniqueInput
    create: XOR<UnitConcentrationCreateWithoutBufferLevelInput, UnitConcentrationUncheckedCreateWithoutBufferLevelInput>
  }

  export type DrugUpsertWithoutBufferLevelsInput = {
    update: XOR<DrugUpdateWithoutBufferLevelsInput, DrugUncheckedUpdateWithoutBufferLevelsInput>
    create: XOR<DrugCreateWithoutBufferLevelsInput, DrugUncheckedCreateWithoutBufferLevelsInput>
    where?: DrugWhereInput
  }

  export type DrugUpdateToOneWithWhereWithoutBufferLevelsInput = {
    where?: DrugWhereInput
    data: XOR<DrugUpdateWithoutBufferLevelsInput, DrugUncheckedUpdateWithoutBufferLevelsInput>
  }

  export type DrugUpdateWithoutBufferLevelsInput = {
    name?: StringFieldUpdateOperationsInput | string
    batch?: BatchUpdateManyWithoutDrugNestedInput
    BatchHistory?: BatchHistoryUpdateManyWithoutDrugNestedInput
    Issue?: IssueUpdateManyWithoutDrugNestedInput
    stratergyHistory?: StratergyHistoryUpdateOneWithoutDrugNestedInput
  }

  export type DrugUncheckedUpdateWithoutBufferLevelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    batch?: BatchUncheckedUpdateManyWithoutDrugNestedInput
    BatchHistory?: BatchHistoryUncheckedUpdateManyWithoutDrugNestedInput
    Issue?: IssueUncheckedUpdateManyWithoutDrugNestedInput
    stratergyHistory?: StratergyHistoryUncheckedUpdateOneWithoutDrugNestedInput
  }

  export type UnitConcentrationUpsertWithoutBufferLevelInput = {
    update: XOR<UnitConcentrationUpdateWithoutBufferLevelInput, UnitConcentrationUncheckedUpdateWithoutBufferLevelInput>
    create: XOR<UnitConcentrationCreateWithoutBufferLevelInput, UnitConcentrationUncheckedCreateWithoutBufferLevelInput>
    where?: UnitConcentrationWhereInput
  }

  export type UnitConcentrationUpdateToOneWithWhereWithoutBufferLevelInput = {
    where?: UnitConcentrationWhereInput
    data: XOR<UnitConcentrationUpdateWithoutBufferLevelInput, UnitConcentrationUncheckedUpdateWithoutBufferLevelInput>
  }

  export type UnitConcentrationUpdateWithoutBufferLevelInput = {
    concentration?: FloatFieldUpdateOperationsInput | number
    Batch?: BatchUpdateManyWithoutUnitConcentrationNestedInput
    BatchHistory?: BatchHistoryUpdateManyWithoutUnitConcentrationNestedInput
    Issue?: IssueUpdateManyWithoutUnitConcentrationNestedInput
  }

  export type UnitConcentrationUncheckedUpdateWithoutBufferLevelInput = {
    id?: IntFieldUpdateOperationsInput | number
    concentration?: FloatFieldUpdateOperationsInput | number
    Batch?: BatchUncheckedUpdateManyWithoutUnitConcentrationNestedInput
    BatchHistory?: BatchHistoryUncheckedUpdateManyWithoutUnitConcentrationNestedInput
    Issue?: IssueUncheckedUpdateManyWithoutUnitConcentrationNestedInput
  }

  export type BatchCreateWithoutSupplierInput = {
    number: string
    type: $Enums.DrugType
    fullAmount: number
    expiry: Date | string
    stockDate?: Date | string
    remainingQuantity: number
    wholesalePrice: number
    retailPrice: number
    status: $Enums.BatchStatus
    drugBrand: DrugBrandCreateNestedOneWithoutBatchInput
    drug: DrugCreateNestedOneWithoutBatchInput
    unitConcentration: UnitConcentrationCreateNestedOneWithoutBatchInput
    BatchHistory?: BatchHistoryCreateNestedManyWithoutBatchInput
    Issue?: IssueCreateNestedManyWithoutBatchInput
  }

  export type BatchUncheckedCreateWithoutSupplierInput = {
    id?: number
    number: string
    drugId: number
    drugBrandId: number
    type: $Enums.DrugType
    fullAmount: number
    expiry: Date | string
    stockDate?: Date | string
    remainingQuantity: number
    wholesalePrice: number
    retailPrice: number
    status: $Enums.BatchStatus
    unitConcentrationId: number
    BatchHistory?: BatchHistoryUncheckedCreateNestedManyWithoutBatchInput
    Issue?: IssueUncheckedCreateNestedManyWithoutBatchInput
  }

  export type BatchCreateOrConnectWithoutSupplierInput = {
    where: BatchWhereUniqueInput
    create: XOR<BatchCreateWithoutSupplierInput, BatchUncheckedCreateWithoutSupplierInput>
  }

  export type BatchCreateManySupplierInputEnvelope = {
    data: BatchCreateManySupplierInput | BatchCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type BatchUpsertWithWhereUniqueWithoutSupplierInput = {
    where: BatchWhereUniqueInput
    update: XOR<BatchUpdateWithoutSupplierInput, BatchUncheckedUpdateWithoutSupplierInput>
    create: XOR<BatchCreateWithoutSupplierInput, BatchUncheckedCreateWithoutSupplierInput>
  }

  export type BatchUpdateWithWhereUniqueWithoutSupplierInput = {
    where: BatchWhereUniqueInput
    data: XOR<BatchUpdateWithoutSupplierInput, BatchUncheckedUpdateWithoutSupplierInput>
  }

  export type BatchUpdateManyWithWhereWithoutSupplierInput = {
    where: BatchScalarWhereInput
    data: XOR<BatchUpdateManyMutationInput, BatchUncheckedUpdateManyWithoutSupplierInput>
  }

  export type DrugBrandCreateWithoutBatchInput = {
    name: string
    description?: string | null
    BatchHistory?: BatchHistoryCreateNestedManyWithoutBrandInput
    Issue?: IssueCreateNestedManyWithoutBrandInput
  }

  export type DrugBrandUncheckedCreateWithoutBatchInput = {
    id?: number
    name: string
    description?: string | null
    BatchHistory?: BatchHistoryUncheckedCreateNestedManyWithoutBrandInput
    Issue?: IssueUncheckedCreateNestedManyWithoutBrandInput
  }

  export type DrugBrandCreateOrConnectWithoutBatchInput = {
    where: DrugBrandWhereUniqueInput
    create: XOR<DrugBrandCreateWithoutBatchInput, DrugBrandUncheckedCreateWithoutBatchInput>
  }

  export type DrugCreateWithoutBatchInput = {
    name: string
    BatchHistory?: BatchHistoryCreateNestedManyWithoutDrugInput
    Issue?: IssueCreateNestedManyWithoutDrugInput
    stratergyHistory?: StratergyHistoryCreateNestedOneWithoutDrugInput
    bufferLevels?: BufferLevelCreateNestedManyWithoutDrugInput
  }

  export type DrugUncheckedCreateWithoutBatchInput = {
    id?: number
    name: string
    BatchHistory?: BatchHistoryUncheckedCreateNestedManyWithoutDrugInput
    Issue?: IssueUncheckedCreateNestedManyWithoutDrugInput
    stratergyHistory?: StratergyHistoryUncheckedCreateNestedOneWithoutDrugInput
    bufferLevels?: BufferLevelUncheckedCreateNestedManyWithoutDrugInput
  }

  export type DrugCreateOrConnectWithoutBatchInput = {
    where: DrugWhereUniqueInput
    create: XOR<DrugCreateWithoutBatchInput, DrugUncheckedCreateWithoutBatchInput>
  }

  export type SupplierCreateWithoutBatchesInput = {
    name: string
    contact?: string | null
  }

  export type SupplierUncheckedCreateWithoutBatchesInput = {
    id?: number
    name: string
    contact?: string | null
  }

  export type SupplierCreateOrConnectWithoutBatchesInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutBatchesInput, SupplierUncheckedCreateWithoutBatchesInput>
  }

  export type UnitConcentrationCreateWithoutBatchInput = {
    concentration: number
    BatchHistory?: BatchHistoryCreateNestedManyWithoutUnitConcentrationInput
    Issue?: IssueCreateNestedManyWithoutUnitConcentrationInput
    BufferLevel?: BufferLevelCreateNestedManyWithoutUnitConcentrationInput
  }

  export type UnitConcentrationUncheckedCreateWithoutBatchInput = {
    id?: number
    concentration: number
    BatchHistory?: BatchHistoryUncheckedCreateNestedManyWithoutUnitConcentrationInput
    Issue?: IssueUncheckedCreateNestedManyWithoutUnitConcentrationInput
    BufferLevel?: BufferLevelUncheckedCreateNestedManyWithoutUnitConcentrationInput
  }

  export type UnitConcentrationCreateOrConnectWithoutBatchInput = {
    where: UnitConcentrationWhereUniqueInput
    create: XOR<UnitConcentrationCreateWithoutBatchInput, UnitConcentrationUncheckedCreateWithoutBatchInput>
  }

  export type BatchHistoryCreateWithoutBatchInput = {
    type: $Enums.DrugType
    brand: DrugBrandCreateNestedOneWithoutBatchHistoryInput
    drug: DrugCreateNestedOneWithoutBatchHistoryInput
    unitConcentration: UnitConcentrationCreateNestedOneWithoutBatchHistoryInput
  }

  export type BatchHistoryUncheckedCreateWithoutBatchInput = {
    id?: number
    drugId: number
    type: $Enums.DrugType
    unitConcentrationId: number
    drugBrandId: number
  }

  export type BatchHistoryCreateOrConnectWithoutBatchInput = {
    where: BatchHistoryWhereUniqueInput
    create: XOR<BatchHistoryCreateWithoutBatchInput, BatchHistoryUncheckedCreateWithoutBatchInput>
  }

  export type BatchHistoryCreateManyBatchInputEnvelope = {
    data: BatchHistoryCreateManyBatchInput | BatchHistoryCreateManyBatchInput[]
    skipDuplicates?: boolean
  }

  export type IssueCreateWithoutBatchInput = {
    strategy: $Enums.IssuingStrategy
    quantity: number
    dose: number
    details?: string | null
    meal?: $Enums.MEAL | null
    type: $Enums.DrugType
    brand: DrugBrandCreateNestedOneWithoutIssueInput
    drug: DrugCreateNestedOneWithoutIssueInput
    prescription: PrescriptionCreateNestedOneWithoutIssuesInput
    unitConcentration: UnitConcentrationCreateNestedOneWithoutIssueInput
    stratergyHistory?: StratergyHistoryCreateNestedManyWithoutIssueInput
  }

  export type IssueUncheckedCreateWithoutBatchInput = {
    id?: number
    prescriptionId: number
    drugId: number
    brandId: number
    strategy: $Enums.IssuingStrategy
    quantity: number
    dose: number
    details?: string | null
    meal?: $Enums.MEAL | null
    type: $Enums.DrugType
    unitConcentrationId: number
    stratergyHistory?: StratergyHistoryUncheckedCreateNestedManyWithoutIssueInput
  }

  export type IssueCreateOrConnectWithoutBatchInput = {
    where: IssueWhereUniqueInput
    create: XOR<IssueCreateWithoutBatchInput, IssueUncheckedCreateWithoutBatchInput>
  }

  export type IssueCreateManyBatchInputEnvelope = {
    data: IssueCreateManyBatchInput | IssueCreateManyBatchInput[]
    skipDuplicates?: boolean
  }

  export type DrugBrandUpsertWithoutBatchInput = {
    update: XOR<DrugBrandUpdateWithoutBatchInput, DrugBrandUncheckedUpdateWithoutBatchInput>
    create: XOR<DrugBrandCreateWithoutBatchInput, DrugBrandUncheckedCreateWithoutBatchInput>
    where?: DrugBrandWhereInput
  }

  export type DrugBrandUpdateToOneWithWhereWithoutBatchInput = {
    where?: DrugBrandWhereInput
    data: XOR<DrugBrandUpdateWithoutBatchInput, DrugBrandUncheckedUpdateWithoutBatchInput>
  }

  export type DrugBrandUpdateWithoutBatchInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    BatchHistory?: BatchHistoryUpdateManyWithoutBrandNestedInput
    Issue?: IssueUpdateManyWithoutBrandNestedInput
  }

  export type DrugBrandUncheckedUpdateWithoutBatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    BatchHistory?: BatchHistoryUncheckedUpdateManyWithoutBrandNestedInput
    Issue?: IssueUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type DrugUpsertWithoutBatchInput = {
    update: XOR<DrugUpdateWithoutBatchInput, DrugUncheckedUpdateWithoutBatchInput>
    create: XOR<DrugCreateWithoutBatchInput, DrugUncheckedCreateWithoutBatchInput>
    where?: DrugWhereInput
  }

  export type DrugUpdateToOneWithWhereWithoutBatchInput = {
    where?: DrugWhereInput
    data: XOR<DrugUpdateWithoutBatchInput, DrugUncheckedUpdateWithoutBatchInput>
  }

  export type DrugUpdateWithoutBatchInput = {
    name?: StringFieldUpdateOperationsInput | string
    BatchHistory?: BatchHistoryUpdateManyWithoutDrugNestedInput
    Issue?: IssueUpdateManyWithoutDrugNestedInput
    stratergyHistory?: StratergyHistoryUpdateOneWithoutDrugNestedInput
    bufferLevels?: BufferLevelUpdateManyWithoutDrugNestedInput
  }

  export type DrugUncheckedUpdateWithoutBatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    BatchHistory?: BatchHistoryUncheckedUpdateManyWithoutDrugNestedInput
    Issue?: IssueUncheckedUpdateManyWithoutDrugNestedInput
    stratergyHistory?: StratergyHistoryUncheckedUpdateOneWithoutDrugNestedInput
    bufferLevels?: BufferLevelUncheckedUpdateManyWithoutDrugNestedInput
  }

  export type SupplierUpsertWithoutBatchesInput = {
    update: XOR<SupplierUpdateWithoutBatchesInput, SupplierUncheckedUpdateWithoutBatchesInput>
    create: XOR<SupplierCreateWithoutBatchesInput, SupplierUncheckedCreateWithoutBatchesInput>
    where?: SupplierWhereInput
  }

  export type SupplierUpdateToOneWithWhereWithoutBatchesInput = {
    where?: SupplierWhereInput
    data: XOR<SupplierUpdateWithoutBatchesInput, SupplierUncheckedUpdateWithoutBatchesInput>
  }

  export type SupplierUpdateWithoutBatchesInput = {
    name?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SupplierUncheckedUpdateWithoutBatchesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UnitConcentrationUpsertWithoutBatchInput = {
    update: XOR<UnitConcentrationUpdateWithoutBatchInput, UnitConcentrationUncheckedUpdateWithoutBatchInput>
    create: XOR<UnitConcentrationCreateWithoutBatchInput, UnitConcentrationUncheckedCreateWithoutBatchInput>
    where?: UnitConcentrationWhereInput
  }

  export type UnitConcentrationUpdateToOneWithWhereWithoutBatchInput = {
    where?: UnitConcentrationWhereInput
    data: XOR<UnitConcentrationUpdateWithoutBatchInput, UnitConcentrationUncheckedUpdateWithoutBatchInput>
  }

  export type UnitConcentrationUpdateWithoutBatchInput = {
    concentration?: FloatFieldUpdateOperationsInput | number
    BatchHistory?: BatchHistoryUpdateManyWithoutUnitConcentrationNestedInput
    Issue?: IssueUpdateManyWithoutUnitConcentrationNestedInput
    BufferLevel?: BufferLevelUpdateManyWithoutUnitConcentrationNestedInput
  }

  export type UnitConcentrationUncheckedUpdateWithoutBatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    concentration?: FloatFieldUpdateOperationsInput | number
    BatchHistory?: BatchHistoryUncheckedUpdateManyWithoutUnitConcentrationNestedInput
    Issue?: IssueUncheckedUpdateManyWithoutUnitConcentrationNestedInput
    BufferLevel?: BufferLevelUncheckedUpdateManyWithoutUnitConcentrationNestedInput
  }

  export type BatchHistoryUpsertWithWhereUniqueWithoutBatchInput = {
    where: BatchHistoryWhereUniqueInput
    update: XOR<BatchHistoryUpdateWithoutBatchInput, BatchHistoryUncheckedUpdateWithoutBatchInput>
    create: XOR<BatchHistoryCreateWithoutBatchInput, BatchHistoryUncheckedCreateWithoutBatchInput>
  }

  export type BatchHistoryUpdateWithWhereUniqueWithoutBatchInput = {
    where: BatchHistoryWhereUniqueInput
    data: XOR<BatchHistoryUpdateWithoutBatchInput, BatchHistoryUncheckedUpdateWithoutBatchInput>
  }

  export type BatchHistoryUpdateManyWithWhereWithoutBatchInput = {
    where: BatchHistoryScalarWhereInput
    data: XOR<BatchHistoryUpdateManyMutationInput, BatchHistoryUncheckedUpdateManyWithoutBatchInput>
  }

  export type IssueUpsertWithWhereUniqueWithoutBatchInput = {
    where: IssueWhereUniqueInput
    update: XOR<IssueUpdateWithoutBatchInput, IssueUncheckedUpdateWithoutBatchInput>
    create: XOR<IssueCreateWithoutBatchInput, IssueUncheckedCreateWithoutBatchInput>
  }

  export type IssueUpdateWithWhereUniqueWithoutBatchInput = {
    where: IssueWhereUniqueInput
    data: XOR<IssueUpdateWithoutBatchInput, IssueUncheckedUpdateWithoutBatchInput>
  }

  export type IssueUpdateManyWithWhereWithoutBatchInput = {
    where: IssueScalarWhereInput
    data: XOR<IssueUpdateManyMutationInput, IssueUncheckedUpdateManyWithoutBatchInput>
  }

  export type BatchCreateWithoutUnitConcentrationInput = {
    number: string
    type: $Enums.DrugType
    fullAmount: number
    expiry: Date | string
    stockDate?: Date | string
    remainingQuantity: number
    wholesalePrice: number
    retailPrice: number
    status: $Enums.BatchStatus
    drugBrand: DrugBrandCreateNestedOneWithoutBatchInput
    drug: DrugCreateNestedOneWithoutBatchInput
    Supplier: SupplierCreateNestedOneWithoutBatchesInput
    BatchHistory?: BatchHistoryCreateNestedManyWithoutBatchInput
    Issue?: IssueCreateNestedManyWithoutBatchInput
  }

  export type BatchUncheckedCreateWithoutUnitConcentrationInput = {
    id?: number
    number: string
    drugId: number
    drugBrandId: number
    type: $Enums.DrugType
    fullAmount: number
    expiry: Date | string
    stockDate?: Date | string
    remainingQuantity: number
    wholesalePrice: number
    retailPrice: number
    status: $Enums.BatchStatus
    supplierId: number
    BatchHistory?: BatchHistoryUncheckedCreateNestedManyWithoutBatchInput
    Issue?: IssueUncheckedCreateNestedManyWithoutBatchInput
  }

  export type BatchCreateOrConnectWithoutUnitConcentrationInput = {
    where: BatchWhereUniqueInput
    create: XOR<BatchCreateWithoutUnitConcentrationInput, BatchUncheckedCreateWithoutUnitConcentrationInput>
  }

  export type BatchCreateManyUnitConcentrationInputEnvelope = {
    data: BatchCreateManyUnitConcentrationInput | BatchCreateManyUnitConcentrationInput[]
    skipDuplicates?: boolean
  }

  export type BatchHistoryCreateWithoutUnitConcentrationInput = {
    type: $Enums.DrugType
    batch: BatchCreateNestedOneWithoutBatchHistoryInput
    brand: DrugBrandCreateNestedOneWithoutBatchHistoryInput
    drug: DrugCreateNestedOneWithoutBatchHistoryInput
  }

  export type BatchHistoryUncheckedCreateWithoutUnitConcentrationInput = {
    id?: number
    drugId: number
    type: $Enums.DrugType
    drugBrandId: number
    batchId: number
  }

  export type BatchHistoryCreateOrConnectWithoutUnitConcentrationInput = {
    where: BatchHistoryWhereUniqueInput
    create: XOR<BatchHistoryCreateWithoutUnitConcentrationInput, BatchHistoryUncheckedCreateWithoutUnitConcentrationInput>
  }

  export type BatchHistoryCreateManyUnitConcentrationInputEnvelope = {
    data: BatchHistoryCreateManyUnitConcentrationInput | BatchHistoryCreateManyUnitConcentrationInput[]
    skipDuplicates?: boolean
  }

  export type IssueCreateWithoutUnitConcentrationInput = {
    strategy: $Enums.IssuingStrategy
    quantity: number
    dose: number
    details?: string | null
    meal?: $Enums.MEAL | null
    type: $Enums.DrugType
    batch?: BatchCreateNestedOneWithoutIssueInput
    brand: DrugBrandCreateNestedOneWithoutIssueInput
    drug: DrugCreateNestedOneWithoutIssueInput
    prescription: PrescriptionCreateNestedOneWithoutIssuesInput
    stratergyHistory?: StratergyHistoryCreateNestedManyWithoutIssueInput
  }

  export type IssueUncheckedCreateWithoutUnitConcentrationInput = {
    id?: number
    prescriptionId: number
    batchId?: number | null
    drugId: number
    brandId: number
    strategy: $Enums.IssuingStrategy
    quantity: number
    dose: number
    details?: string | null
    meal?: $Enums.MEAL | null
    type: $Enums.DrugType
    stratergyHistory?: StratergyHistoryUncheckedCreateNestedManyWithoutIssueInput
  }

  export type IssueCreateOrConnectWithoutUnitConcentrationInput = {
    where: IssueWhereUniqueInput
    create: XOR<IssueCreateWithoutUnitConcentrationInput, IssueUncheckedCreateWithoutUnitConcentrationInput>
  }

  export type IssueCreateManyUnitConcentrationInputEnvelope = {
    data: IssueCreateManyUnitConcentrationInput | IssueCreateManyUnitConcentrationInput[]
    skipDuplicates?: boolean
  }

  export type BufferLevelCreateWithoutUnitConcentrationInput = {
    type: $Enums.DrugType
    bufferAmount: number
    drug: DrugCreateNestedOneWithoutBufferLevelsInput
  }

  export type BufferLevelUncheckedCreateWithoutUnitConcentrationInput = {
    id?: number
    drugId: number
    type: $Enums.DrugType
    bufferAmount: number
  }

  export type BufferLevelCreateOrConnectWithoutUnitConcentrationInput = {
    where: BufferLevelWhereUniqueInput
    create: XOR<BufferLevelCreateWithoutUnitConcentrationInput, BufferLevelUncheckedCreateWithoutUnitConcentrationInput>
  }

  export type BufferLevelCreateManyUnitConcentrationInputEnvelope = {
    data: BufferLevelCreateManyUnitConcentrationInput | BufferLevelCreateManyUnitConcentrationInput[]
    skipDuplicates?: boolean
  }

  export type BatchUpsertWithWhereUniqueWithoutUnitConcentrationInput = {
    where: BatchWhereUniqueInput
    update: XOR<BatchUpdateWithoutUnitConcentrationInput, BatchUncheckedUpdateWithoutUnitConcentrationInput>
    create: XOR<BatchCreateWithoutUnitConcentrationInput, BatchUncheckedCreateWithoutUnitConcentrationInput>
  }

  export type BatchUpdateWithWhereUniqueWithoutUnitConcentrationInput = {
    where: BatchWhereUniqueInput
    data: XOR<BatchUpdateWithoutUnitConcentrationInput, BatchUncheckedUpdateWithoutUnitConcentrationInput>
  }

  export type BatchUpdateManyWithWhereWithoutUnitConcentrationInput = {
    where: BatchScalarWhereInput
    data: XOR<BatchUpdateManyMutationInput, BatchUncheckedUpdateManyWithoutUnitConcentrationInput>
  }

  export type BatchHistoryUpsertWithWhereUniqueWithoutUnitConcentrationInput = {
    where: BatchHistoryWhereUniqueInput
    update: XOR<BatchHistoryUpdateWithoutUnitConcentrationInput, BatchHistoryUncheckedUpdateWithoutUnitConcentrationInput>
    create: XOR<BatchHistoryCreateWithoutUnitConcentrationInput, BatchHistoryUncheckedCreateWithoutUnitConcentrationInput>
  }

  export type BatchHistoryUpdateWithWhereUniqueWithoutUnitConcentrationInput = {
    where: BatchHistoryWhereUniqueInput
    data: XOR<BatchHistoryUpdateWithoutUnitConcentrationInput, BatchHistoryUncheckedUpdateWithoutUnitConcentrationInput>
  }

  export type BatchHistoryUpdateManyWithWhereWithoutUnitConcentrationInput = {
    where: BatchHistoryScalarWhereInput
    data: XOR<BatchHistoryUpdateManyMutationInput, BatchHistoryUncheckedUpdateManyWithoutUnitConcentrationInput>
  }

  export type IssueUpsertWithWhereUniqueWithoutUnitConcentrationInput = {
    where: IssueWhereUniqueInput
    update: XOR<IssueUpdateWithoutUnitConcentrationInput, IssueUncheckedUpdateWithoutUnitConcentrationInput>
    create: XOR<IssueCreateWithoutUnitConcentrationInput, IssueUncheckedCreateWithoutUnitConcentrationInput>
  }

  export type IssueUpdateWithWhereUniqueWithoutUnitConcentrationInput = {
    where: IssueWhereUniqueInput
    data: XOR<IssueUpdateWithoutUnitConcentrationInput, IssueUncheckedUpdateWithoutUnitConcentrationInput>
  }

  export type IssueUpdateManyWithWhereWithoutUnitConcentrationInput = {
    where: IssueScalarWhereInput
    data: XOR<IssueUpdateManyMutationInput, IssueUncheckedUpdateManyWithoutUnitConcentrationInput>
  }

  export type BufferLevelUpsertWithWhereUniqueWithoutUnitConcentrationInput = {
    where: BufferLevelWhereUniqueInput
    update: XOR<BufferLevelUpdateWithoutUnitConcentrationInput, BufferLevelUncheckedUpdateWithoutUnitConcentrationInput>
    create: XOR<BufferLevelCreateWithoutUnitConcentrationInput, BufferLevelUncheckedCreateWithoutUnitConcentrationInput>
  }

  export type BufferLevelUpdateWithWhereUniqueWithoutUnitConcentrationInput = {
    where: BufferLevelWhereUniqueInput
    data: XOR<BufferLevelUpdateWithoutUnitConcentrationInput, BufferLevelUncheckedUpdateWithoutUnitConcentrationInput>
  }

  export type BufferLevelUpdateManyWithWhereWithoutUnitConcentrationInput = {
    where: BufferLevelScalarWhereInput
    data: XOR<BufferLevelUpdateManyMutationInput, BufferLevelUncheckedUpdateManyWithoutUnitConcentrationInput>
  }

  export type IssueCreateWithoutPrescriptionInput = {
    strategy: $Enums.IssuingStrategy
    quantity: number
    dose: number
    details?: string | null
    meal?: $Enums.MEAL | null
    type: $Enums.DrugType
    batch?: BatchCreateNestedOneWithoutIssueInput
    brand: DrugBrandCreateNestedOneWithoutIssueInput
    drug: DrugCreateNestedOneWithoutIssueInput
    unitConcentration: UnitConcentrationCreateNestedOneWithoutIssueInput
    stratergyHistory?: StratergyHistoryCreateNestedManyWithoutIssueInput
  }

  export type IssueUncheckedCreateWithoutPrescriptionInput = {
    id?: number
    batchId?: number | null
    drugId: number
    brandId: number
    strategy: $Enums.IssuingStrategy
    quantity: number
    dose: number
    details?: string | null
    meal?: $Enums.MEAL | null
    type: $Enums.DrugType
    unitConcentrationId: number
    stratergyHistory?: StratergyHistoryUncheckedCreateNestedManyWithoutIssueInput
  }

  export type IssueCreateOrConnectWithoutPrescriptionInput = {
    where: IssueWhereUniqueInput
    create: XOR<IssueCreateWithoutPrescriptionInput, IssueUncheckedCreateWithoutPrescriptionInput>
  }

  export type IssueCreateManyPrescriptionInputEnvelope = {
    data: IssueCreateManyPrescriptionInput | IssueCreateManyPrescriptionInput[]
    skipDuplicates?: boolean
  }

  export type OffRecordMedsCreateWithoutPrescriptionInput = {
    name: string
    description?: string | null
  }

  export type OffRecordMedsUncheckedCreateWithoutPrescriptionInput = {
    id?: number
    name: string
    description?: string | null
  }

  export type OffRecordMedsCreateOrConnectWithoutPrescriptionInput = {
    where: OffRecordMedsWhereUniqueInput
    create: XOR<OffRecordMedsCreateWithoutPrescriptionInput, OffRecordMedsUncheckedCreateWithoutPrescriptionInput>
  }

  export type OffRecordMedsCreateManyPrescriptionInputEnvelope = {
    data: OffRecordMedsCreateManyPrescriptionInput | OffRecordMedsCreateManyPrescriptionInput[]
    skipDuplicates?: boolean
  }

  export type PatientCreateWithoutPrescriptionInput = {
    telephone: string
    name: string
    birthDate?: Date | string | null
    address?: string | null
    height?: number | null
    weight?: number | null
    gender: $Enums.Gender
    NIC?: string | null
    medicalCert?: MedicalCertificateCreateNestedManyWithoutPatientInput
    PatientHistory?: PatientHistoryCreateNestedManyWithoutPatientInput
    reports?: PatientReportCreateNestedManyWithoutPatientInput
    queueEntry?: QueueEntryCreateNestedManyWithoutPatientInput
    USSReferral?: USSReferralCreateNestedManyWithoutPatientInput
    referralLetters?: ReferralLetterCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutPrescriptionInput = {
    id?: number
    telephone: string
    name: string
    birthDate?: Date | string | null
    address?: string | null
    height?: number | null
    weight?: number | null
    gender: $Enums.Gender
    NIC?: string | null
    medicalCert?: MedicalCertificateUncheckedCreateNestedManyWithoutPatientInput
    PatientHistory?: PatientHistoryUncheckedCreateNestedManyWithoutPatientInput
    reports?: PatientReportUncheckedCreateNestedManyWithoutPatientInput
    queueEntry?: QueueEntryUncheckedCreateNestedManyWithoutPatientInput
    USSReferral?: USSReferralUncheckedCreateNestedManyWithoutPatientInput
    referralLetters?: ReferralLetterUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutPrescriptionInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutPrescriptionInput, PatientUncheckedCreateWithoutPrescriptionInput>
  }

  export type PrescriptionVitalsCreateWithoutPrescriptionInput = {
    value: string
    vital: VitalsCreateNestedOneWithoutPrescriptionVitalsInput
  }

  export type PrescriptionVitalsUncheckedCreateWithoutPrescriptionInput = {
    id?: number
    vitalId: number
    value: string
  }

  export type PrescriptionVitalsCreateOrConnectWithoutPrescriptionInput = {
    where: PrescriptionVitalsWhereUniqueInput
    create: XOR<PrescriptionVitalsCreateWithoutPrescriptionInput, PrescriptionVitalsUncheckedCreateWithoutPrescriptionInput>
  }

  export type PrescriptionVitalsCreateManyPrescriptionInputEnvelope = {
    data: PrescriptionVitalsCreateManyPrescriptionInput | PrescriptionVitalsCreateManyPrescriptionInput[]
    skipDuplicates?: boolean
  }

  export type PrescriptionChargesCreateWithoutPrescriptionInput = {
    name: string
    type: $Enums.ChargeType
    value: number
    description?: string | null
  }

  export type PrescriptionChargesUncheckedCreateWithoutPrescriptionInput = {
    id?: number
    name: string
    type: $Enums.ChargeType
    value: number
    description?: string | null
  }

  export type PrescriptionChargesCreateOrConnectWithoutPrescriptionInput = {
    where: PrescriptionChargesWhereUniqueInput
    create: XOR<PrescriptionChargesCreateWithoutPrescriptionInput, PrescriptionChargesUncheckedCreateWithoutPrescriptionInput>
  }

  export type PrescriptionChargesCreateManyPrescriptionInputEnvelope = {
    data: PrescriptionChargesCreateManyPrescriptionInput | PrescriptionChargesCreateManyPrescriptionInput[]
    skipDuplicates?: boolean
  }

  export type IssueUpsertWithWhereUniqueWithoutPrescriptionInput = {
    where: IssueWhereUniqueInput
    update: XOR<IssueUpdateWithoutPrescriptionInput, IssueUncheckedUpdateWithoutPrescriptionInput>
    create: XOR<IssueCreateWithoutPrescriptionInput, IssueUncheckedCreateWithoutPrescriptionInput>
  }

  export type IssueUpdateWithWhereUniqueWithoutPrescriptionInput = {
    where: IssueWhereUniqueInput
    data: XOR<IssueUpdateWithoutPrescriptionInput, IssueUncheckedUpdateWithoutPrescriptionInput>
  }

  export type IssueUpdateManyWithWhereWithoutPrescriptionInput = {
    where: IssueScalarWhereInput
    data: XOR<IssueUpdateManyMutationInput, IssueUncheckedUpdateManyWithoutPrescriptionInput>
  }

  export type OffRecordMedsUpsertWithWhereUniqueWithoutPrescriptionInput = {
    where: OffRecordMedsWhereUniqueInput
    update: XOR<OffRecordMedsUpdateWithoutPrescriptionInput, OffRecordMedsUncheckedUpdateWithoutPrescriptionInput>
    create: XOR<OffRecordMedsCreateWithoutPrescriptionInput, OffRecordMedsUncheckedCreateWithoutPrescriptionInput>
  }

  export type OffRecordMedsUpdateWithWhereUniqueWithoutPrescriptionInput = {
    where: OffRecordMedsWhereUniqueInput
    data: XOR<OffRecordMedsUpdateWithoutPrescriptionInput, OffRecordMedsUncheckedUpdateWithoutPrescriptionInput>
  }

  export type OffRecordMedsUpdateManyWithWhereWithoutPrescriptionInput = {
    where: OffRecordMedsScalarWhereInput
    data: XOR<OffRecordMedsUpdateManyMutationInput, OffRecordMedsUncheckedUpdateManyWithoutPrescriptionInput>
  }

  export type OffRecordMedsScalarWhereInput = {
    AND?: OffRecordMedsScalarWhereInput | OffRecordMedsScalarWhereInput[]
    OR?: OffRecordMedsScalarWhereInput[]
    NOT?: OffRecordMedsScalarWhereInput | OffRecordMedsScalarWhereInput[]
    id?: IntFilter<"OffRecordMeds"> | number
    name?: StringFilter<"OffRecordMeds"> | string
    description?: StringNullableFilter<"OffRecordMeds"> | string | null
    prescriptionId?: IntFilter<"OffRecordMeds"> | number
  }

  export type PatientUpsertWithoutPrescriptionInput = {
    update: XOR<PatientUpdateWithoutPrescriptionInput, PatientUncheckedUpdateWithoutPrescriptionInput>
    create: XOR<PatientCreateWithoutPrescriptionInput, PatientUncheckedCreateWithoutPrescriptionInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutPrescriptionInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutPrescriptionInput, PatientUncheckedUpdateWithoutPrescriptionInput>
  }

  export type PatientUpdateWithoutPrescriptionInput = {
    telephone?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
    medicalCert?: MedicalCertificateUpdateManyWithoutPatientNestedInput
    PatientHistory?: PatientHistoryUpdateManyWithoutPatientNestedInput
    reports?: PatientReportUpdateManyWithoutPatientNestedInput
    queueEntry?: QueueEntryUpdateManyWithoutPatientNestedInput
    USSReferral?: USSReferralUpdateManyWithoutPatientNestedInput
    referralLetters?: ReferralLetterUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutPrescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    telephone?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
    medicalCert?: MedicalCertificateUncheckedUpdateManyWithoutPatientNestedInput
    PatientHistory?: PatientHistoryUncheckedUpdateManyWithoutPatientNestedInput
    reports?: PatientReportUncheckedUpdateManyWithoutPatientNestedInput
    queueEntry?: QueueEntryUncheckedUpdateManyWithoutPatientNestedInput
    USSReferral?: USSReferralUncheckedUpdateManyWithoutPatientNestedInput
    referralLetters?: ReferralLetterUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PrescriptionVitalsUpsertWithWhereUniqueWithoutPrescriptionInput = {
    where: PrescriptionVitalsWhereUniqueInput
    update: XOR<PrescriptionVitalsUpdateWithoutPrescriptionInput, PrescriptionVitalsUncheckedUpdateWithoutPrescriptionInput>
    create: XOR<PrescriptionVitalsCreateWithoutPrescriptionInput, PrescriptionVitalsUncheckedCreateWithoutPrescriptionInput>
  }

  export type PrescriptionVitalsUpdateWithWhereUniqueWithoutPrescriptionInput = {
    where: PrescriptionVitalsWhereUniqueInput
    data: XOR<PrescriptionVitalsUpdateWithoutPrescriptionInput, PrescriptionVitalsUncheckedUpdateWithoutPrescriptionInput>
  }

  export type PrescriptionVitalsUpdateManyWithWhereWithoutPrescriptionInput = {
    where: PrescriptionVitalsScalarWhereInput
    data: XOR<PrescriptionVitalsUpdateManyMutationInput, PrescriptionVitalsUncheckedUpdateManyWithoutPrescriptionInput>
  }

  export type PrescriptionVitalsScalarWhereInput = {
    AND?: PrescriptionVitalsScalarWhereInput | PrescriptionVitalsScalarWhereInput[]
    OR?: PrescriptionVitalsScalarWhereInput[]
    NOT?: PrescriptionVitalsScalarWhereInput | PrescriptionVitalsScalarWhereInput[]
    id?: IntFilter<"PrescriptionVitals"> | number
    prescriptionId?: IntFilter<"PrescriptionVitals"> | number
    vitalId?: IntFilter<"PrescriptionVitals"> | number
    value?: StringFilter<"PrescriptionVitals"> | string
  }

  export type PrescriptionChargesUpsertWithWhereUniqueWithoutPrescriptionInput = {
    where: PrescriptionChargesWhereUniqueInput
    update: XOR<PrescriptionChargesUpdateWithoutPrescriptionInput, PrescriptionChargesUncheckedUpdateWithoutPrescriptionInput>
    create: XOR<PrescriptionChargesCreateWithoutPrescriptionInput, PrescriptionChargesUncheckedCreateWithoutPrescriptionInput>
  }

  export type PrescriptionChargesUpdateWithWhereUniqueWithoutPrescriptionInput = {
    where: PrescriptionChargesWhereUniqueInput
    data: XOR<PrescriptionChargesUpdateWithoutPrescriptionInput, PrescriptionChargesUncheckedUpdateWithoutPrescriptionInput>
  }

  export type PrescriptionChargesUpdateManyWithWhereWithoutPrescriptionInput = {
    where: PrescriptionChargesScalarWhereInput
    data: XOR<PrescriptionChargesUpdateManyMutationInput, PrescriptionChargesUncheckedUpdateManyWithoutPrescriptionInput>
  }

  export type PrescriptionChargesScalarWhereInput = {
    AND?: PrescriptionChargesScalarWhereInput | PrescriptionChargesScalarWhereInput[]
    OR?: PrescriptionChargesScalarWhereInput[]
    NOT?: PrescriptionChargesScalarWhereInput | PrescriptionChargesScalarWhereInput[]
    id?: IntFilter<"PrescriptionCharges"> | number
    prescriptionId?: IntFilter<"PrescriptionCharges"> | number
    name?: StringFilter<"PrescriptionCharges"> | string
    type?: EnumChargeTypeFilter<"PrescriptionCharges"> | $Enums.ChargeType
    value?: FloatFilter<"PrescriptionCharges"> | number
    description?: StringNullableFilter<"PrescriptionCharges"> | string | null
  }

  export type PrescriptionCreateWithoutChargesInput = {
    time?: Date | string
    presentingSymptoms: string
    status?: $Enums.PrescriptionStatus
    details?: string | null
    finalPrice?: number | null
    issues?: IssueCreateNestedManyWithoutPrescriptionInput
    OffRecordMeds?: OffRecordMedsCreateNestedManyWithoutPrescriptionInput
    patient: PatientCreateNestedOneWithoutPrescriptionInput
    PrescriptionVitals?: PrescriptionVitalsCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionUncheckedCreateWithoutChargesInput = {
    id?: number
    time?: Date | string
    presentingSymptoms: string
    status?: $Enums.PrescriptionStatus
    details?: string | null
    patientId: number
    finalPrice?: number | null
    issues?: IssueUncheckedCreateNestedManyWithoutPrescriptionInput
    OffRecordMeds?: OffRecordMedsUncheckedCreateNestedManyWithoutPrescriptionInput
    PrescriptionVitals?: PrescriptionVitalsUncheckedCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionCreateOrConnectWithoutChargesInput = {
    where: PrescriptionWhereUniqueInput
    create: XOR<PrescriptionCreateWithoutChargesInput, PrescriptionUncheckedCreateWithoutChargesInput>
  }

  export type PrescriptionUpsertWithoutChargesInput = {
    update: XOR<PrescriptionUpdateWithoutChargesInput, PrescriptionUncheckedUpdateWithoutChargesInput>
    create: XOR<PrescriptionCreateWithoutChargesInput, PrescriptionUncheckedCreateWithoutChargesInput>
    where?: PrescriptionWhereInput
  }

  export type PrescriptionUpdateToOneWithWhereWithoutChargesInput = {
    where?: PrescriptionWhereInput
    data: XOR<PrescriptionUpdateWithoutChargesInput, PrescriptionUncheckedUpdateWithoutChargesInput>
  }

  export type PrescriptionUpdateWithoutChargesInput = {
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    presentingSymptoms?: StringFieldUpdateOperationsInput | string
    status?: EnumPrescriptionStatusFieldUpdateOperationsInput | $Enums.PrescriptionStatus
    details?: NullableStringFieldUpdateOperationsInput | string | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    issues?: IssueUpdateManyWithoutPrescriptionNestedInput
    OffRecordMeds?: OffRecordMedsUpdateManyWithoutPrescriptionNestedInput
    patient?: PatientUpdateOneRequiredWithoutPrescriptionNestedInput
    PrescriptionVitals?: PrescriptionVitalsUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateWithoutChargesInput = {
    id?: IntFieldUpdateOperationsInput | number
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    presentingSymptoms?: StringFieldUpdateOperationsInput | string
    status?: EnumPrescriptionStatusFieldUpdateOperationsInput | $Enums.PrescriptionStatus
    details?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: IntFieldUpdateOperationsInput | number
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    issues?: IssueUncheckedUpdateManyWithoutPrescriptionNestedInput
    OffRecordMeds?: OffRecordMedsUncheckedUpdateManyWithoutPrescriptionNestedInput
    PrescriptionVitals?: PrescriptionVitalsUncheckedUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionVitalsCreateWithoutVitalInput = {
    value: string
    prescription: PrescriptionCreateNestedOneWithoutPrescriptionVitalsInput
  }

  export type PrescriptionVitalsUncheckedCreateWithoutVitalInput = {
    id?: number
    prescriptionId: number
    value: string
  }

  export type PrescriptionVitalsCreateOrConnectWithoutVitalInput = {
    where: PrescriptionVitalsWhereUniqueInput
    create: XOR<PrescriptionVitalsCreateWithoutVitalInput, PrescriptionVitalsUncheckedCreateWithoutVitalInput>
  }

  export type PrescriptionVitalsCreateManyVitalInputEnvelope = {
    data: PrescriptionVitalsCreateManyVitalInput | PrescriptionVitalsCreateManyVitalInput[]
    skipDuplicates?: boolean
  }

  export type PrescriptionVitalsUpsertWithWhereUniqueWithoutVitalInput = {
    where: PrescriptionVitalsWhereUniqueInput
    update: XOR<PrescriptionVitalsUpdateWithoutVitalInput, PrescriptionVitalsUncheckedUpdateWithoutVitalInput>
    create: XOR<PrescriptionVitalsCreateWithoutVitalInput, PrescriptionVitalsUncheckedCreateWithoutVitalInput>
  }

  export type PrescriptionVitalsUpdateWithWhereUniqueWithoutVitalInput = {
    where: PrescriptionVitalsWhereUniqueInput
    data: XOR<PrescriptionVitalsUpdateWithoutVitalInput, PrescriptionVitalsUncheckedUpdateWithoutVitalInput>
  }

  export type PrescriptionVitalsUpdateManyWithWhereWithoutVitalInput = {
    where: PrescriptionVitalsScalarWhereInput
    data: XOR<PrescriptionVitalsUpdateManyMutationInput, PrescriptionVitalsUncheckedUpdateManyWithoutVitalInput>
  }

  export type PrescriptionCreateWithoutPrescriptionVitalsInput = {
    time?: Date | string
    presentingSymptoms: string
    status?: $Enums.PrescriptionStatus
    details?: string | null
    finalPrice?: number | null
    issues?: IssueCreateNestedManyWithoutPrescriptionInput
    OffRecordMeds?: OffRecordMedsCreateNestedManyWithoutPrescriptionInput
    patient: PatientCreateNestedOneWithoutPrescriptionInput
    Charges?: PrescriptionChargesCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionUncheckedCreateWithoutPrescriptionVitalsInput = {
    id?: number
    time?: Date | string
    presentingSymptoms: string
    status?: $Enums.PrescriptionStatus
    details?: string | null
    patientId: number
    finalPrice?: number | null
    issues?: IssueUncheckedCreateNestedManyWithoutPrescriptionInput
    OffRecordMeds?: OffRecordMedsUncheckedCreateNestedManyWithoutPrescriptionInput
    Charges?: PrescriptionChargesUncheckedCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionCreateOrConnectWithoutPrescriptionVitalsInput = {
    where: PrescriptionWhereUniqueInput
    create: XOR<PrescriptionCreateWithoutPrescriptionVitalsInput, PrescriptionUncheckedCreateWithoutPrescriptionVitalsInput>
  }

  export type VitalsCreateWithoutPrescriptionVitalsInput = {
    name: string
    icon: string
    color: string
    placeholder: string
    forGender?: $Enums.Gender | null
    type: $Enums.VitalType
  }

  export type VitalsUncheckedCreateWithoutPrescriptionVitalsInput = {
    id?: number
    name: string
    icon: string
    color: string
    placeholder: string
    forGender?: $Enums.Gender | null
    type: $Enums.VitalType
  }

  export type VitalsCreateOrConnectWithoutPrescriptionVitalsInput = {
    where: VitalsWhereUniqueInput
    create: XOR<VitalsCreateWithoutPrescriptionVitalsInput, VitalsUncheckedCreateWithoutPrescriptionVitalsInput>
  }

  export type PrescriptionUpsertWithoutPrescriptionVitalsInput = {
    update: XOR<PrescriptionUpdateWithoutPrescriptionVitalsInput, PrescriptionUncheckedUpdateWithoutPrescriptionVitalsInput>
    create: XOR<PrescriptionCreateWithoutPrescriptionVitalsInput, PrescriptionUncheckedCreateWithoutPrescriptionVitalsInput>
    where?: PrescriptionWhereInput
  }

  export type PrescriptionUpdateToOneWithWhereWithoutPrescriptionVitalsInput = {
    where?: PrescriptionWhereInput
    data: XOR<PrescriptionUpdateWithoutPrescriptionVitalsInput, PrescriptionUncheckedUpdateWithoutPrescriptionVitalsInput>
  }

  export type PrescriptionUpdateWithoutPrescriptionVitalsInput = {
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    presentingSymptoms?: StringFieldUpdateOperationsInput | string
    status?: EnumPrescriptionStatusFieldUpdateOperationsInput | $Enums.PrescriptionStatus
    details?: NullableStringFieldUpdateOperationsInput | string | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    issues?: IssueUpdateManyWithoutPrescriptionNestedInput
    OffRecordMeds?: OffRecordMedsUpdateManyWithoutPrescriptionNestedInput
    patient?: PatientUpdateOneRequiredWithoutPrescriptionNestedInput
    Charges?: PrescriptionChargesUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateWithoutPrescriptionVitalsInput = {
    id?: IntFieldUpdateOperationsInput | number
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    presentingSymptoms?: StringFieldUpdateOperationsInput | string
    status?: EnumPrescriptionStatusFieldUpdateOperationsInput | $Enums.PrescriptionStatus
    details?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: IntFieldUpdateOperationsInput | number
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    issues?: IssueUncheckedUpdateManyWithoutPrescriptionNestedInput
    OffRecordMeds?: OffRecordMedsUncheckedUpdateManyWithoutPrescriptionNestedInput
    Charges?: PrescriptionChargesUncheckedUpdateManyWithoutPrescriptionNestedInput
  }

  export type VitalsUpsertWithoutPrescriptionVitalsInput = {
    update: XOR<VitalsUpdateWithoutPrescriptionVitalsInput, VitalsUncheckedUpdateWithoutPrescriptionVitalsInput>
    create: XOR<VitalsCreateWithoutPrescriptionVitalsInput, VitalsUncheckedCreateWithoutPrescriptionVitalsInput>
    where?: VitalsWhereInput
  }

  export type VitalsUpdateToOneWithWhereWithoutPrescriptionVitalsInput = {
    where?: VitalsWhereInput
    data: XOR<VitalsUpdateWithoutPrescriptionVitalsInput, VitalsUncheckedUpdateWithoutPrescriptionVitalsInput>
  }

  export type VitalsUpdateWithoutPrescriptionVitalsInput = {
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    placeholder?: StringFieldUpdateOperationsInput | string
    forGender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    type?: EnumVitalTypeFieldUpdateOperationsInput | $Enums.VitalType
  }

  export type VitalsUncheckedUpdateWithoutPrescriptionVitalsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    placeholder?: StringFieldUpdateOperationsInput | string
    forGender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    type?: EnumVitalTypeFieldUpdateOperationsInput | $Enums.VitalType
  }

  export type PatientCreateWithoutMedicalCertInput = {
    telephone: string
    name: string
    birthDate?: Date | string | null
    address?: string | null
    height?: number | null
    weight?: number | null
    gender: $Enums.Gender
    NIC?: string | null
    PatientHistory?: PatientHistoryCreateNestedManyWithoutPatientInput
    reports?: PatientReportCreateNestedManyWithoutPatientInput
    prescription?: PrescriptionCreateNestedManyWithoutPatientInput
    queueEntry?: QueueEntryCreateNestedManyWithoutPatientInput
    USSReferral?: USSReferralCreateNestedManyWithoutPatientInput
    referralLetters?: ReferralLetterCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutMedicalCertInput = {
    id?: number
    telephone: string
    name: string
    birthDate?: Date | string | null
    address?: string | null
    height?: number | null
    weight?: number | null
    gender: $Enums.Gender
    NIC?: string | null
    PatientHistory?: PatientHistoryUncheckedCreateNestedManyWithoutPatientInput
    reports?: PatientReportUncheckedCreateNestedManyWithoutPatientInput
    prescription?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    queueEntry?: QueueEntryUncheckedCreateNestedManyWithoutPatientInput
    USSReferral?: USSReferralUncheckedCreateNestedManyWithoutPatientInput
    referralLetters?: ReferralLetterUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutMedicalCertInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutMedicalCertInput, PatientUncheckedCreateWithoutMedicalCertInput>
  }

  export type PatientUpsertWithoutMedicalCertInput = {
    update: XOR<PatientUpdateWithoutMedicalCertInput, PatientUncheckedUpdateWithoutMedicalCertInput>
    create: XOR<PatientCreateWithoutMedicalCertInput, PatientUncheckedCreateWithoutMedicalCertInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutMedicalCertInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutMedicalCertInput, PatientUncheckedUpdateWithoutMedicalCertInput>
  }

  export type PatientUpdateWithoutMedicalCertInput = {
    telephone?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
    PatientHistory?: PatientHistoryUpdateManyWithoutPatientNestedInput
    reports?: PatientReportUpdateManyWithoutPatientNestedInput
    prescription?: PrescriptionUpdateManyWithoutPatientNestedInput
    queueEntry?: QueueEntryUpdateManyWithoutPatientNestedInput
    USSReferral?: USSReferralUpdateManyWithoutPatientNestedInput
    referralLetters?: ReferralLetterUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutMedicalCertInput = {
    id?: IntFieldUpdateOperationsInput | number
    telephone?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
    PatientHistory?: PatientHistoryUncheckedUpdateManyWithoutPatientNestedInput
    reports?: PatientReportUncheckedUpdateManyWithoutPatientNestedInput
    prescription?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    queueEntry?: QueueEntryUncheckedUpdateManyWithoutPatientNestedInput
    USSReferral?: USSReferralUncheckedUpdateManyWithoutPatientNestedInput
    referralLetters?: ReferralLetterUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientCreateWithoutUSSReferralInput = {
    telephone: string
    name: string
    birthDate?: Date | string | null
    address?: string | null
    height?: number | null
    weight?: number | null
    gender: $Enums.Gender
    NIC?: string | null
    medicalCert?: MedicalCertificateCreateNestedManyWithoutPatientInput
    PatientHistory?: PatientHistoryCreateNestedManyWithoutPatientInput
    reports?: PatientReportCreateNestedManyWithoutPatientInput
    prescription?: PrescriptionCreateNestedManyWithoutPatientInput
    queueEntry?: QueueEntryCreateNestedManyWithoutPatientInput
    referralLetters?: ReferralLetterCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutUSSReferralInput = {
    id?: number
    telephone: string
    name: string
    birthDate?: Date | string | null
    address?: string | null
    height?: number | null
    weight?: number | null
    gender: $Enums.Gender
    NIC?: string | null
    medicalCert?: MedicalCertificateUncheckedCreateNestedManyWithoutPatientInput
    PatientHistory?: PatientHistoryUncheckedCreateNestedManyWithoutPatientInput
    reports?: PatientReportUncheckedCreateNestedManyWithoutPatientInput
    prescription?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    queueEntry?: QueueEntryUncheckedCreateNestedManyWithoutPatientInput
    referralLetters?: ReferralLetterUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutUSSReferralInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutUSSReferralInput, PatientUncheckedCreateWithoutUSSReferralInput>
  }

  export type PatientUpsertWithoutUSSReferralInput = {
    update: XOR<PatientUpdateWithoutUSSReferralInput, PatientUncheckedUpdateWithoutUSSReferralInput>
    create: XOR<PatientCreateWithoutUSSReferralInput, PatientUncheckedCreateWithoutUSSReferralInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutUSSReferralInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutUSSReferralInput, PatientUncheckedUpdateWithoutUSSReferralInput>
  }

  export type PatientUpdateWithoutUSSReferralInput = {
    telephone?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
    medicalCert?: MedicalCertificateUpdateManyWithoutPatientNestedInput
    PatientHistory?: PatientHistoryUpdateManyWithoutPatientNestedInput
    reports?: PatientReportUpdateManyWithoutPatientNestedInput
    prescription?: PrescriptionUpdateManyWithoutPatientNestedInput
    queueEntry?: QueueEntryUpdateManyWithoutPatientNestedInput
    referralLetters?: ReferralLetterUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutUSSReferralInput = {
    id?: IntFieldUpdateOperationsInput | number
    telephone?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
    medicalCert?: MedicalCertificateUncheckedUpdateManyWithoutPatientNestedInput
    PatientHistory?: PatientHistoryUncheckedUpdateManyWithoutPatientNestedInput
    reports?: PatientReportUncheckedUpdateManyWithoutPatientNestedInput
    prescription?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    queueEntry?: QueueEntryUncheckedUpdateManyWithoutPatientNestedInput
    referralLetters?: ReferralLetterUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientCreateWithoutReferralLettersInput = {
    telephone: string
    name: string
    birthDate?: Date | string | null
    address?: string | null
    height?: number | null
    weight?: number | null
    gender: $Enums.Gender
    NIC?: string | null
    medicalCert?: MedicalCertificateCreateNestedManyWithoutPatientInput
    PatientHistory?: PatientHistoryCreateNestedManyWithoutPatientInput
    reports?: PatientReportCreateNestedManyWithoutPatientInput
    prescription?: PrescriptionCreateNestedManyWithoutPatientInput
    queueEntry?: QueueEntryCreateNestedManyWithoutPatientInput
    USSReferral?: USSReferralCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutReferralLettersInput = {
    id?: number
    telephone: string
    name: string
    birthDate?: Date | string | null
    address?: string | null
    height?: number | null
    weight?: number | null
    gender: $Enums.Gender
    NIC?: string | null
    medicalCert?: MedicalCertificateUncheckedCreateNestedManyWithoutPatientInput
    PatientHistory?: PatientHistoryUncheckedCreateNestedManyWithoutPatientInput
    reports?: PatientReportUncheckedCreateNestedManyWithoutPatientInput
    prescription?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    queueEntry?: QueueEntryUncheckedCreateNestedManyWithoutPatientInput
    USSReferral?: USSReferralUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutReferralLettersInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutReferralLettersInput, PatientUncheckedCreateWithoutReferralLettersInput>
  }

  export type PatientUpsertWithoutReferralLettersInput = {
    update: XOR<PatientUpdateWithoutReferralLettersInput, PatientUncheckedUpdateWithoutReferralLettersInput>
    create: XOR<PatientCreateWithoutReferralLettersInput, PatientUncheckedCreateWithoutReferralLettersInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutReferralLettersInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutReferralLettersInput, PatientUncheckedUpdateWithoutReferralLettersInput>
  }

  export type PatientUpdateWithoutReferralLettersInput = {
    telephone?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
    medicalCert?: MedicalCertificateUpdateManyWithoutPatientNestedInput
    PatientHistory?: PatientHistoryUpdateManyWithoutPatientNestedInput
    reports?: PatientReportUpdateManyWithoutPatientNestedInput
    prescription?: PrescriptionUpdateManyWithoutPatientNestedInput
    queueEntry?: QueueEntryUpdateManyWithoutPatientNestedInput
    USSReferral?: USSReferralUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutReferralLettersInput = {
    id?: IntFieldUpdateOperationsInput | number
    telephone?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
    medicalCert?: MedicalCertificateUncheckedUpdateManyWithoutPatientNestedInput
    PatientHistory?: PatientHistoryUncheckedUpdateManyWithoutPatientNestedInput
    reports?: PatientReportUncheckedUpdateManyWithoutPatientNestedInput
    prescription?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    queueEntry?: QueueEntryUncheckedUpdateManyWithoutPatientNestedInput
    USSReferral?: USSReferralUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PrescriptionCreateWithoutOffRecordMedsInput = {
    time?: Date | string
    presentingSymptoms: string
    status?: $Enums.PrescriptionStatus
    details?: string | null
    finalPrice?: number | null
    issues?: IssueCreateNestedManyWithoutPrescriptionInput
    patient: PatientCreateNestedOneWithoutPrescriptionInput
    PrescriptionVitals?: PrescriptionVitalsCreateNestedManyWithoutPrescriptionInput
    Charges?: PrescriptionChargesCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionUncheckedCreateWithoutOffRecordMedsInput = {
    id?: number
    time?: Date | string
    presentingSymptoms: string
    status?: $Enums.PrescriptionStatus
    details?: string | null
    patientId: number
    finalPrice?: number | null
    issues?: IssueUncheckedCreateNestedManyWithoutPrescriptionInput
    PrescriptionVitals?: PrescriptionVitalsUncheckedCreateNestedManyWithoutPrescriptionInput
    Charges?: PrescriptionChargesUncheckedCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionCreateOrConnectWithoutOffRecordMedsInput = {
    where: PrescriptionWhereUniqueInput
    create: XOR<PrescriptionCreateWithoutOffRecordMedsInput, PrescriptionUncheckedCreateWithoutOffRecordMedsInput>
  }

  export type PrescriptionUpsertWithoutOffRecordMedsInput = {
    update: XOR<PrescriptionUpdateWithoutOffRecordMedsInput, PrescriptionUncheckedUpdateWithoutOffRecordMedsInput>
    create: XOR<PrescriptionCreateWithoutOffRecordMedsInput, PrescriptionUncheckedCreateWithoutOffRecordMedsInput>
    where?: PrescriptionWhereInput
  }

  export type PrescriptionUpdateToOneWithWhereWithoutOffRecordMedsInput = {
    where?: PrescriptionWhereInput
    data: XOR<PrescriptionUpdateWithoutOffRecordMedsInput, PrescriptionUncheckedUpdateWithoutOffRecordMedsInput>
  }

  export type PrescriptionUpdateWithoutOffRecordMedsInput = {
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    presentingSymptoms?: StringFieldUpdateOperationsInput | string
    status?: EnumPrescriptionStatusFieldUpdateOperationsInput | $Enums.PrescriptionStatus
    details?: NullableStringFieldUpdateOperationsInput | string | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    issues?: IssueUpdateManyWithoutPrescriptionNestedInput
    patient?: PatientUpdateOneRequiredWithoutPrescriptionNestedInput
    PrescriptionVitals?: PrescriptionVitalsUpdateManyWithoutPrescriptionNestedInput
    Charges?: PrescriptionChargesUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateWithoutOffRecordMedsInput = {
    id?: IntFieldUpdateOperationsInput | number
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    presentingSymptoms?: StringFieldUpdateOperationsInput | string
    status?: EnumPrescriptionStatusFieldUpdateOperationsInput | $Enums.PrescriptionStatus
    details?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: IntFieldUpdateOperationsInput | number
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    issues?: IssueUncheckedUpdateManyWithoutPrescriptionNestedInput
    PrescriptionVitals?: PrescriptionVitalsUncheckedUpdateManyWithoutPrescriptionNestedInput
    Charges?: PrescriptionChargesUncheckedUpdateManyWithoutPrescriptionNestedInput
  }

  export type BatchCreateWithoutIssueInput = {
    number: string
    type: $Enums.DrugType
    fullAmount: number
    expiry: Date | string
    stockDate?: Date | string
    remainingQuantity: number
    wholesalePrice: number
    retailPrice: number
    status: $Enums.BatchStatus
    drugBrand: DrugBrandCreateNestedOneWithoutBatchInput
    drug: DrugCreateNestedOneWithoutBatchInput
    Supplier: SupplierCreateNestedOneWithoutBatchesInput
    unitConcentration: UnitConcentrationCreateNestedOneWithoutBatchInput
    BatchHistory?: BatchHistoryCreateNestedManyWithoutBatchInput
  }

  export type BatchUncheckedCreateWithoutIssueInput = {
    id?: number
    number: string
    drugId: number
    drugBrandId: number
    type: $Enums.DrugType
    fullAmount: number
    expiry: Date | string
    stockDate?: Date | string
    remainingQuantity: number
    wholesalePrice: number
    retailPrice: number
    status: $Enums.BatchStatus
    unitConcentrationId: number
    supplierId: number
    BatchHistory?: BatchHistoryUncheckedCreateNestedManyWithoutBatchInput
  }

  export type BatchCreateOrConnectWithoutIssueInput = {
    where: BatchWhereUniqueInput
    create: XOR<BatchCreateWithoutIssueInput, BatchUncheckedCreateWithoutIssueInput>
  }

  export type DrugBrandCreateWithoutIssueInput = {
    name: string
    description?: string | null
    Batch?: BatchCreateNestedManyWithoutDrugBrandInput
    BatchHistory?: BatchHistoryCreateNestedManyWithoutBrandInput
  }

  export type DrugBrandUncheckedCreateWithoutIssueInput = {
    id?: number
    name: string
    description?: string | null
    Batch?: BatchUncheckedCreateNestedManyWithoutDrugBrandInput
    BatchHistory?: BatchHistoryUncheckedCreateNestedManyWithoutBrandInput
  }

  export type DrugBrandCreateOrConnectWithoutIssueInput = {
    where: DrugBrandWhereUniqueInput
    create: XOR<DrugBrandCreateWithoutIssueInput, DrugBrandUncheckedCreateWithoutIssueInput>
  }

  export type DrugCreateWithoutIssueInput = {
    name: string
    batch?: BatchCreateNestedManyWithoutDrugInput
    BatchHistory?: BatchHistoryCreateNestedManyWithoutDrugInput
    stratergyHistory?: StratergyHistoryCreateNestedOneWithoutDrugInput
    bufferLevels?: BufferLevelCreateNestedManyWithoutDrugInput
  }

  export type DrugUncheckedCreateWithoutIssueInput = {
    id?: number
    name: string
    batch?: BatchUncheckedCreateNestedManyWithoutDrugInput
    BatchHistory?: BatchHistoryUncheckedCreateNestedManyWithoutDrugInput
    stratergyHistory?: StratergyHistoryUncheckedCreateNestedOneWithoutDrugInput
    bufferLevels?: BufferLevelUncheckedCreateNestedManyWithoutDrugInput
  }

  export type DrugCreateOrConnectWithoutIssueInput = {
    where: DrugWhereUniqueInput
    create: XOR<DrugCreateWithoutIssueInput, DrugUncheckedCreateWithoutIssueInput>
  }

  export type PrescriptionCreateWithoutIssuesInput = {
    time?: Date | string
    presentingSymptoms: string
    status?: $Enums.PrescriptionStatus
    details?: string | null
    finalPrice?: number | null
    OffRecordMeds?: OffRecordMedsCreateNestedManyWithoutPrescriptionInput
    patient: PatientCreateNestedOneWithoutPrescriptionInput
    PrescriptionVitals?: PrescriptionVitalsCreateNestedManyWithoutPrescriptionInput
    Charges?: PrescriptionChargesCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionUncheckedCreateWithoutIssuesInput = {
    id?: number
    time?: Date | string
    presentingSymptoms: string
    status?: $Enums.PrescriptionStatus
    details?: string | null
    patientId: number
    finalPrice?: number | null
    OffRecordMeds?: OffRecordMedsUncheckedCreateNestedManyWithoutPrescriptionInput
    PrescriptionVitals?: PrescriptionVitalsUncheckedCreateNestedManyWithoutPrescriptionInput
    Charges?: PrescriptionChargesUncheckedCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionCreateOrConnectWithoutIssuesInput = {
    where: PrescriptionWhereUniqueInput
    create: XOR<PrescriptionCreateWithoutIssuesInput, PrescriptionUncheckedCreateWithoutIssuesInput>
  }

  export type UnitConcentrationCreateWithoutIssueInput = {
    concentration: number
    Batch?: BatchCreateNestedManyWithoutUnitConcentrationInput
    BatchHistory?: BatchHistoryCreateNestedManyWithoutUnitConcentrationInput
    BufferLevel?: BufferLevelCreateNestedManyWithoutUnitConcentrationInput
  }

  export type UnitConcentrationUncheckedCreateWithoutIssueInput = {
    id?: number
    concentration: number
    Batch?: BatchUncheckedCreateNestedManyWithoutUnitConcentrationInput
    BatchHistory?: BatchHistoryUncheckedCreateNestedManyWithoutUnitConcentrationInput
    BufferLevel?: BufferLevelUncheckedCreateNestedManyWithoutUnitConcentrationInput
  }

  export type UnitConcentrationCreateOrConnectWithoutIssueInput = {
    where: UnitConcentrationWhereUniqueInput
    create: XOR<UnitConcentrationCreateWithoutIssueInput, UnitConcentrationUncheckedCreateWithoutIssueInput>
  }

  export type StratergyHistoryCreateWithoutIssueInput = {
    drug: DrugCreateNestedOneWithoutStratergyHistoryInput
  }

  export type StratergyHistoryUncheckedCreateWithoutIssueInput = {
    id?: number
    drugId: number
  }

  export type StratergyHistoryCreateOrConnectWithoutIssueInput = {
    where: StratergyHistoryWhereUniqueInput
    create: XOR<StratergyHistoryCreateWithoutIssueInput, StratergyHistoryUncheckedCreateWithoutIssueInput>
  }

  export type StratergyHistoryCreateManyIssueInputEnvelope = {
    data: StratergyHistoryCreateManyIssueInput | StratergyHistoryCreateManyIssueInput[]
    skipDuplicates?: boolean
  }

  export type BatchUpsertWithoutIssueInput = {
    update: XOR<BatchUpdateWithoutIssueInput, BatchUncheckedUpdateWithoutIssueInput>
    create: XOR<BatchCreateWithoutIssueInput, BatchUncheckedCreateWithoutIssueInput>
    where?: BatchWhereInput
  }

  export type BatchUpdateToOneWithWhereWithoutIssueInput = {
    where?: BatchWhereInput
    data: XOR<BatchUpdateWithoutIssueInput, BatchUncheckedUpdateWithoutIssueInput>
  }

  export type BatchUpdateWithoutIssueInput = {
    number?: StringFieldUpdateOperationsInput | string
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    fullAmount?: FloatFieldUpdateOperationsInput | number
    expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    stockDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remainingQuantity?: FloatFieldUpdateOperationsInput | number
    wholesalePrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    drugBrand?: DrugBrandUpdateOneRequiredWithoutBatchNestedInput
    drug?: DrugUpdateOneRequiredWithoutBatchNestedInput
    Supplier?: SupplierUpdateOneRequiredWithoutBatchesNestedInput
    unitConcentration?: UnitConcentrationUpdateOneRequiredWithoutBatchNestedInput
    BatchHistory?: BatchHistoryUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateWithoutIssueInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    drugId?: IntFieldUpdateOperationsInput | number
    drugBrandId?: IntFieldUpdateOperationsInput | number
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    fullAmount?: FloatFieldUpdateOperationsInput | number
    expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    stockDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remainingQuantity?: FloatFieldUpdateOperationsInput | number
    wholesalePrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    unitConcentrationId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    BatchHistory?: BatchHistoryUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type DrugBrandUpsertWithoutIssueInput = {
    update: XOR<DrugBrandUpdateWithoutIssueInput, DrugBrandUncheckedUpdateWithoutIssueInput>
    create: XOR<DrugBrandCreateWithoutIssueInput, DrugBrandUncheckedCreateWithoutIssueInput>
    where?: DrugBrandWhereInput
  }

  export type DrugBrandUpdateToOneWithWhereWithoutIssueInput = {
    where?: DrugBrandWhereInput
    data: XOR<DrugBrandUpdateWithoutIssueInput, DrugBrandUncheckedUpdateWithoutIssueInput>
  }

  export type DrugBrandUpdateWithoutIssueInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    Batch?: BatchUpdateManyWithoutDrugBrandNestedInput
    BatchHistory?: BatchHistoryUpdateManyWithoutBrandNestedInput
  }

  export type DrugBrandUncheckedUpdateWithoutIssueInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    Batch?: BatchUncheckedUpdateManyWithoutDrugBrandNestedInput
    BatchHistory?: BatchHistoryUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type DrugUpsertWithoutIssueInput = {
    update: XOR<DrugUpdateWithoutIssueInput, DrugUncheckedUpdateWithoutIssueInput>
    create: XOR<DrugCreateWithoutIssueInput, DrugUncheckedCreateWithoutIssueInput>
    where?: DrugWhereInput
  }

  export type DrugUpdateToOneWithWhereWithoutIssueInput = {
    where?: DrugWhereInput
    data: XOR<DrugUpdateWithoutIssueInput, DrugUncheckedUpdateWithoutIssueInput>
  }

  export type DrugUpdateWithoutIssueInput = {
    name?: StringFieldUpdateOperationsInput | string
    batch?: BatchUpdateManyWithoutDrugNestedInput
    BatchHistory?: BatchHistoryUpdateManyWithoutDrugNestedInput
    stratergyHistory?: StratergyHistoryUpdateOneWithoutDrugNestedInput
    bufferLevels?: BufferLevelUpdateManyWithoutDrugNestedInput
  }

  export type DrugUncheckedUpdateWithoutIssueInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    batch?: BatchUncheckedUpdateManyWithoutDrugNestedInput
    BatchHistory?: BatchHistoryUncheckedUpdateManyWithoutDrugNestedInput
    stratergyHistory?: StratergyHistoryUncheckedUpdateOneWithoutDrugNestedInput
    bufferLevels?: BufferLevelUncheckedUpdateManyWithoutDrugNestedInput
  }

  export type PrescriptionUpsertWithoutIssuesInput = {
    update: XOR<PrescriptionUpdateWithoutIssuesInput, PrescriptionUncheckedUpdateWithoutIssuesInput>
    create: XOR<PrescriptionCreateWithoutIssuesInput, PrescriptionUncheckedCreateWithoutIssuesInput>
    where?: PrescriptionWhereInput
  }

  export type PrescriptionUpdateToOneWithWhereWithoutIssuesInput = {
    where?: PrescriptionWhereInput
    data: XOR<PrescriptionUpdateWithoutIssuesInput, PrescriptionUncheckedUpdateWithoutIssuesInput>
  }

  export type PrescriptionUpdateWithoutIssuesInput = {
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    presentingSymptoms?: StringFieldUpdateOperationsInput | string
    status?: EnumPrescriptionStatusFieldUpdateOperationsInput | $Enums.PrescriptionStatus
    details?: NullableStringFieldUpdateOperationsInput | string | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    OffRecordMeds?: OffRecordMedsUpdateManyWithoutPrescriptionNestedInput
    patient?: PatientUpdateOneRequiredWithoutPrescriptionNestedInput
    PrescriptionVitals?: PrescriptionVitalsUpdateManyWithoutPrescriptionNestedInput
    Charges?: PrescriptionChargesUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateWithoutIssuesInput = {
    id?: IntFieldUpdateOperationsInput | number
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    presentingSymptoms?: StringFieldUpdateOperationsInput | string
    status?: EnumPrescriptionStatusFieldUpdateOperationsInput | $Enums.PrescriptionStatus
    details?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: IntFieldUpdateOperationsInput | number
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    OffRecordMeds?: OffRecordMedsUncheckedUpdateManyWithoutPrescriptionNestedInput
    PrescriptionVitals?: PrescriptionVitalsUncheckedUpdateManyWithoutPrescriptionNestedInput
    Charges?: PrescriptionChargesUncheckedUpdateManyWithoutPrescriptionNestedInput
  }

  export type UnitConcentrationUpsertWithoutIssueInput = {
    update: XOR<UnitConcentrationUpdateWithoutIssueInput, UnitConcentrationUncheckedUpdateWithoutIssueInput>
    create: XOR<UnitConcentrationCreateWithoutIssueInput, UnitConcentrationUncheckedCreateWithoutIssueInput>
    where?: UnitConcentrationWhereInput
  }

  export type UnitConcentrationUpdateToOneWithWhereWithoutIssueInput = {
    where?: UnitConcentrationWhereInput
    data: XOR<UnitConcentrationUpdateWithoutIssueInput, UnitConcentrationUncheckedUpdateWithoutIssueInput>
  }

  export type UnitConcentrationUpdateWithoutIssueInput = {
    concentration?: FloatFieldUpdateOperationsInput | number
    Batch?: BatchUpdateManyWithoutUnitConcentrationNestedInput
    BatchHistory?: BatchHistoryUpdateManyWithoutUnitConcentrationNestedInput
    BufferLevel?: BufferLevelUpdateManyWithoutUnitConcentrationNestedInput
  }

  export type UnitConcentrationUncheckedUpdateWithoutIssueInput = {
    id?: IntFieldUpdateOperationsInput | number
    concentration?: FloatFieldUpdateOperationsInput | number
    Batch?: BatchUncheckedUpdateManyWithoutUnitConcentrationNestedInput
    BatchHistory?: BatchHistoryUncheckedUpdateManyWithoutUnitConcentrationNestedInput
    BufferLevel?: BufferLevelUncheckedUpdateManyWithoutUnitConcentrationNestedInput
  }

  export type StratergyHistoryUpsertWithWhereUniqueWithoutIssueInput = {
    where: StratergyHistoryWhereUniqueInput
    update: XOR<StratergyHistoryUpdateWithoutIssueInput, StratergyHistoryUncheckedUpdateWithoutIssueInput>
    create: XOR<StratergyHistoryCreateWithoutIssueInput, StratergyHistoryUncheckedCreateWithoutIssueInput>
  }

  export type StratergyHistoryUpdateWithWhereUniqueWithoutIssueInput = {
    where: StratergyHistoryWhereUniqueInput
    data: XOR<StratergyHistoryUpdateWithoutIssueInput, StratergyHistoryUncheckedUpdateWithoutIssueInput>
  }

  export type StratergyHistoryUpdateManyWithWhereWithoutIssueInput = {
    where: StratergyHistoryScalarWhereInput
    data: XOR<StratergyHistoryUpdateManyMutationInput, StratergyHistoryUncheckedUpdateManyWithoutIssueInput>
  }

  export type StratergyHistoryScalarWhereInput = {
    AND?: StratergyHistoryScalarWhereInput | StratergyHistoryScalarWhereInput[]
    OR?: StratergyHistoryScalarWhereInput[]
    NOT?: StratergyHistoryScalarWhereInput | StratergyHistoryScalarWhereInput[]
    id?: IntFilter<"StratergyHistory"> | number
    drugId?: IntFilter<"StratergyHistory"> | number
    issueId?: IntFilter<"StratergyHistory"> | number
  }

  export type ReportTypeCreateWithoutParametersInput = {
    name: string
    description?: string | null
    PatientReport?: PatientReportCreateNestedManyWithoutReportTypeInput
  }

  export type ReportTypeUncheckedCreateWithoutParametersInput = {
    id?: number
    name: string
    description?: string | null
    PatientReport?: PatientReportUncheckedCreateNestedManyWithoutReportTypeInput
  }

  export type ReportTypeCreateOrConnectWithoutParametersInput = {
    where: ReportTypeWhereUniqueInput
    create: XOR<ReportTypeCreateWithoutParametersInput, ReportTypeUncheckedCreateWithoutParametersInput>
  }

  export type ReportValueCreateWithoutReportParameterInput = {
    attention?: boolean
    value: string
    PatientReport?: PatientReportCreateNestedOneWithoutParametersInput
  }

  export type ReportValueUncheckedCreateWithoutReportParameterInput = {
    id?: number
    attention?: boolean
    value: string
    patientReportId?: number | null
  }

  export type ReportValueCreateOrConnectWithoutReportParameterInput = {
    where: ReportValueWhereUniqueInput
    create: XOR<ReportValueCreateWithoutReportParameterInput, ReportValueUncheckedCreateWithoutReportParameterInput>
  }

  export type ReportValueCreateManyReportParameterInputEnvelope = {
    data: ReportValueCreateManyReportParameterInput | ReportValueCreateManyReportParameterInput[]
    skipDuplicates?: boolean
  }

  export type ReportTypeUpsertWithoutParametersInput = {
    update: XOR<ReportTypeUpdateWithoutParametersInput, ReportTypeUncheckedUpdateWithoutParametersInput>
    create: XOR<ReportTypeCreateWithoutParametersInput, ReportTypeUncheckedCreateWithoutParametersInput>
    where?: ReportTypeWhereInput
  }

  export type ReportTypeUpdateToOneWithWhereWithoutParametersInput = {
    where?: ReportTypeWhereInput
    data: XOR<ReportTypeUpdateWithoutParametersInput, ReportTypeUncheckedUpdateWithoutParametersInput>
  }

  export type ReportTypeUpdateWithoutParametersInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    PatientReport?: PatientReportUpdateManyWithoutReportTypeNestedInput
  }

  export type ReportTypeUncheckedUpdateWithoutParametersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    PatientReport?: PatientReportUncheckedUpdateManyWithoutReportTypeNestedInput
  }

  export type ReportValueUpsertWithWhereUniqueWithoutReportParameterInput = {
    where: ReportValueWhereUniqueInput
    update: XOR<ReportValueUpdateWithoutReportParameterInput, ReportValueUncheckedUpdateWithoutReportParameterInput>
    create: XOR<ReportValueCreateWithoutReportParameterInput, ReportValueUncheckedCreateWithoutReportParameterInput>
  }

  export type ReportValueUpdateWithWhereUniqueWithoutReportParameterInput = {
    where: ReportValueWhereUniqueInput
    data: XOR<ReportValueUpdateWithoutReportParameterInput, ReportValueUncheckedUpdateWithoutReportParameterInput>
  }

  export type ReportValueUpdateManyWithWhereWithoutReportParameterInput = {
    where: ReportValueScalarWhereInput
    data: XOR<ReportValueUpdateManyMutationInput, ReportValueUncheckedUpdateManyWithoutReportParameterInput>
  }

  export type ReportValueScalarWhereInput = {
    AND?: ReportValueScalarWhereInput | ReportValueScalarWhereInput[]
    OR?: ReportValueScalarWhereInput[]
    NOT?: ReportValueScalarWhereInput | ReportValueScalarWhereInput[]
    id?: IntFilter<"ReportValue"> | number
    reportParameterId?: IntFilter<"ReportValue"> | number
    attention?: BoolFilter<"ReportValue"> | boolean
    value?: StringFilter<"ReportValue"> | string
    patientReportId?: IntNullableFilter<"ReportValue"> | number | null
  }

  export type PatientReportCreateWithoutReportTypeInput = {
    time?: Date | string
    patient: PatientCreateNestedOneWithoutReportsInput
    parameters?: ReportValueCreateNestedManyWithoutPatientReportInput
  }

  export type PatientReportUncheckedCreateWithoutReportTypeInput = {
    id?: number
    patientId: number
    time?: Date | string
    parameters?: ReportValueUncheckedCreateNestedManyWithoutPatientReportInput
  }

  export type PatientReportCreateOrConnectWithoutReportTypeInput = {
    where: PatientReportWhereUniqueInput
    create: XOR<PatientReportCreateWithoutReportTypeInput, PatientReportUncheckedCreateWithoutReportTypeInput>
  }

  export type PatientReportCreateManyReportTypeInputEnvelope = {
    data: PatientReportCreateManyReportTypeInput | PatientReportCreateManyReportTypeInput[]
    skipDuplicates?: boolean
  }

  export type ReportParameterCreateWithoutReportTypeInput = {
    name: string
    units?: string | null
    ReportValue?: ReportValueCreateNestedManyWithoutReportParameterInput
  }

  export type ReportParameterUncheckedCreateWithoutReportTypeInput = {
    id?: number
    name: string
    units?: string | null
    ReportValue?: ReportValueUncheckedCreateNestedManyWithoutReportParameterInput
  }

  export type ReportParameterCreateOrConnectWithoutReportTypeInput = {
    where: ReportParameterWhereUniqueInput
    create: XOR<ReportParameterCreateWithoutReportTypeInput, ReportParameterUncheckedCreateWithoutReportTypeInput>
  }

  export type ReportParameterCreateManyReportTypeInputEnvelope = {
    data: ReportParameterCreateManyReportTypeInput | ReportParameterCreateManyReportTypeInput[]
    skipDuplicates?: boolean
  }

  export type PatientReportUpsertWithWhereUniqueWithoutReportTypeInput = {
    where: PatientReportWhereUniqueInput
    update: XOR<PatientReportUpdateWithoutReportTypeInput, PatientReportUncheckedUpdateWithoutReportTypeInput>
    create: XOR<PatientReportCreateWithoutReportTypeInput, PatientReportUncheckedCreateWithoutReportTypeInput>
  }

  export type PatientReportUpdateWithWhereUniqueWithoutReportTypeInput = {
    where: PatientReportWhereUniqueInput
    data: XOR<PatientReportUpdateWithoutReportTypeInput, PatientReportUncheckedUpdateWithoutReportTypeInput>
  }

  export type PatientReportUpdateManyWithWhereWithoutReportTypeInput = {
    where: PatientReportScalarWhereInput
    data: XOR<PatientReportUpdateManyMutationInput, PatientReportUncheckedUpdateManyWithoutReportTypeInput>
  }

  export type ReportParameterUpsertWithWhereUniqueWithoutReportTypeInput = {
    where: ReportParameterWhereUniqueInput
    update: XOR<ReportParameterUpdateWithoutReportTypeInput, ReportParameterUncheckedUpdateWithoutReportTypeInput>
    create: XOR<ReportParameterCreateWithoutReportTypeInput, ReportParameterUncheckedCreateWithoutReportTypeInput>
  }

  export type ReportParameterUpdateWithWhereUniqueWithoutReportTypeInput = {
    where: ReportParameterWhereUniqueInput
    data: XOR<ReportParameterUpdateWithoutReportTypeInput, ReportParameterUncheckedUpdateWithoutReportTypeInput>
  }

  export type ReportParameterUpdateManyWithWhereWithoutReportTypeInput = {
    where: ReportParameterScalarWhereInput
    data: XOR<ReportParameterUpdateManyMutationInput, ReportParameterUncheckedUpdateManyWithoutReportTypeInput>
  }

  export type ReportParameterScalarWhereInput = {
    AND?: ReportParameterScalarWhereInput | ReportParameterScalarWhereInput[]
    OR?: ReportParameterScalarWhereInput[]
    NOT?: ReportParameterScalarWhereInput | ReportParameterScalarWhereInput[]
    id?: IntFilter<"ReportParameter"> | number
    name?: StringFilter<"ReportParameter"> | string
    units?: StringNullableFilter<"ReportParameter"> | string | null
    reportTypeId?: IntNullableFilter<"ReportParameter"> | number | null
  }

  export type PatientCreateWithoutReportsInput = {
    telephone: string
    name: string
    birthDate?: Date | string | null
    address?: string | null
    height?: number | null
    weight?: number | null
    gender: $Enums.Gender
    NIC?: string | null
    medicalCert?: MedicalCertificateCreateNestedManyWithoutPatientInput
    PatientHistory?: PatientHistoryCreateNestedManyWithoutPatientInput
    prescription?: PrescriptionCreateNestedManyWithoutPatientInput
    queueEntry?: QueueEntryCreateNestedManyWithoutPatientInput
    USSReferral?: USSReferralCreateNestedManyWithoutPatientInput
    referralLetters?: ReferralLetterCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutReportsInput = {
    id?: number
    telephone: string
    name: string
    birthDate?: Date | string | null
    address?: string | null
    height?: number | null
    weight?: number | null
    gender: $Enums.Gender
    NIC?: string | null
    medicalCert?: MedicalCertificateUncheckedCreateNestedManyWithoutPatientInput
    PatientHistory?: PatientHistoryUncheckedCreateNestedManyWithoutPatientInput
    prescription?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    queueEntry?: QueueEntryUncheckedCreateNestedManyWithoutPatientInput
    USSReferral?: USSReferralUncheckedCreateNestedManyWithoutPatientInput
    referralLetters?: ReferralLetterUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutReportsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutReportsInput, PatientUncheckedCreateWithoutReportsInput>
  }

  export type ReportTypeCreateWithoutPatientReportInput = {
    name: string
    description?: string | null
    parameters?: ReportParameterCreateNestedManyWithoutReportTypeInput
  }

  export type ReportTypeUncheckedCreateWithoutPatientReportInput = {
    id?: number
    name: string
    description?: string | null
    parameters?: ReportParameterUncheckedCreateNestedManyWithoutReportTypeInput
  }

  export type ReportTypeCreateOrConnectWithoutPatientReportInput = {
    where: ReportTypeWhereUniqueInput
    create: XOR<ReportTypeCreateWithoutPatientReportInput, ReportTypeUncheckedCreateWithoutPatientReportInput>
  }

  export type ReportValueCreateWithoutPatientReportInput = {
    attention?: boolean
    value: string
    reportParameter: ReportParameterCreateNestedOneWithoutReportValueInput
  }

  export type ReportValueUncheckedCreateWithoutPatientReportInput = {
    id?: number
    reportParameterId: number
    attention?: boolean
    value: string
  }

  export type ReportValueCreateOrConnectWithoutPatientReportInput = {
    where: ReportValueWhereUniqueInput
    create: XOR<ReportValueCreateWithoutPatientReportInput, ReportValueUncheckedCreateWithoutPatientReportInput>
  }

  export type ReportValueCreateManyPatientReportInputEnvelope = {
    data: ReportValueCreateManyPatientReportInput | ReportValueCreateManyPatientReportInput[]
    skipDuplicates?: boolean
  }

  export type PatientUpsertWithoutReportsInput = {
    update: XOR<PatientUpdateWithoutReportsInput, PatientUncheckedUpdateWithoutReportsInput>
    create: XOR<PatientCreateWithoutReportsInput, PatientUncheckedCreateWithoutReportsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutReportsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutReportsInput, PatientUncheckedUpdateWithoutReportsInput>
  }

  export type PatientUpdateWithoutReportsInput = {
    telephone?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
    medicalCert?: MedicalCertificateUpdateManyWithoutPatientNestedInput
    PatientHistory?: PatientHistoryUpdateManyWithoutPatientNestedInput
    prescription?: PrescriptionUpdateManyWithoutPatientNestedInput
    queueEntry?: QueueEntryUpdateManyWithoutPatientNestedInput
    USSReferral?: USSReferralUpdateManyWithoutPatientNestedInput
    referralLetters?: ReferralLetterUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutReportsInput = {
    id?: IntFieldUpdateOperationsInput | number
    telephone?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
    medicalCert?: MedicalCertificateUncheckedUpdateManyWithoutPatientNestedInput
    PatientHistory?: PatientHistoryUncheckedUpdateManyWithoutPatientNestedInput
    prescription?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    queueEntry?: QueueEntryUncheckedUpdateManyWithoutPatientNestedInput
    USSReferral?: USSReferralUncheckedUpdateManyWithoutPatientNestedInput
    referralLetters?: ReferralLetterUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type ReportTypeUpsertWithoutPatientReportInput = {
    update: XOR<ReportTypeUpdateWithoutPatientReportInput, ReportTypeUncheckedUpdateWithoutPatientReportInput>
    create: XOR<ReportTypeCreateWithoutPatientReportInput, ReportTypeUncheckedCreateWithoutPatientReportInput>
    where?: ReportTypeWhereInput
  }

  export type ReportTypeUpdateToOneWithWhereWithoutPatientReportInput = {
    where?: ReportTypeWhereInput
    data: XOR<ReportTypeUpdateWithoutPatientReportInput, ReportTypeUncheckedUpdateWithoutPatientReportInput>
  }

  export type ReportTypeUpdateWithoutPatientReportInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parameters?: ReportParameterUpdateManyWithoutReportTypeNestedInput
  }

  export type ReportTypeUncheckedUpdateWithoutPatientReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parameters?: ReportParameterUncheckedUpdateManyWithoutReportTypeNestedInput
  }

  export type ReportValueUpsertWithWhereUniqueWithoutPatientReportInput = {
    where: ReportValueWhereUniqueInput
    update: XOR<ReportValueUpdateWithoutPatientReportInput, ReportValueUncheckedUpdateWithoutPatientReportInput>
    create: XOR<ReportValueCreateWithoutPatientReportInput, ReportValueUncheckedCreateWithoutPatientReportInput>
  }

  export type ReportValueUpdateWithWhereUniqueWithoutPatientReportInput = {
    where: ReportValueWhereUniqueInput
    data: XOR<ReportValueUpdateWithoutPatientReportInput, ReportValueUncheckedUpdateWithoutPatientReportInput>
  }

  export type ReportValueUpdateManyWithWhereWithoutPatientReportInput = {
    where: ReportValueScalarWhereInput
    data: XOR<ReportValueUpdateManyMutationInput, ReportValueUncheckedUpdateManyWithoutPatientReportInput>
  }

  export type PatientReportCreateWithoutParametersInput = {
    time?: Date | string
    patient: PatientCreateNestedOneWithoutReportsInput
    reportType: ReportTypeCreateNestedOneWithoutPatientReportInput
  }

  export type PatientReportUncheckedCreateWithoutParametersInput = {
    id?: number
    patientId: number
    reportTypeId: number
    time?: Date | string
  }

  export type PatientReportCreateOrConnectWithoutParametersInput = {
    where: PatientReportWhereUniqueInput
    create: XOR<PatientReportCreateWithoutParametersInput, PatientReportUncheckedCreateWithoutParametersInput>
  }

  export type ReportParameterCreateWithoutReportValueInput = {
    name: string
    units?: string | null
    ReportType?: ReportTypeCreateNestedOneWithoutParametersInput
  }

  export type ReportParameterUncheckedCreateWithoutReportValueInput = {
    id?: number
    name: string
    units?: string | null
    reportTypeId?: number | null
  }

  export type ReportParameterCreateOrConnectWithoutReportValueInput = {
    where: ReportParameterWhereUniqueInput
    create: XOR<ReportParameterCreateWithoutReportValueInput, ReportParameterUncheckedCreateWithoutReportValueInput>
  }

  export type PatientReportUpsertWithoutParametersInput = {
    update: XOR<PatientReportUpdateWithoutParametersInput, PatientReportUncheckedUpdateWithoutParametersInput>
    create: XOR<PatientReportCreateWithoutParametersInput, PatientReportUncheckedCreateWithoutParametersInput>
    where?: PatientReportWhereInput
  }

  export type PatientReportUpdateToOneWithWhereWithoutParametersInput = {
    where?: PatientReportWhereInput
    data: XOR<PatientReportUpdateWithoutParametersInput, PatientReportUncheckedUpdateWithoutParametersInput>
  }

  export type PatientReportUpdateWithoutParametersInput = {
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutReportsNestedInput
    reportType?: ReportTypeUpdateOneRequiredWithoutPatientReportNestedInput
  }

  export type PatientReportUncheckedUpdateWithoutParametersInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    reportTypeId?: IntFieldUpdateOperationsInput | number
    time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportParameterUpsertWithoutReportValueInput = {
    update: XOR<ReportParameterUpdateWithoutReportValueInput, ReportParameterUncheckedUpdateWithoutReportValueInput>
    create: XOR<ReportParameterCreateWithoutReportValueInput, ReportParameterUncheckedCreateWithoutReportValueInput>
    where?: ReportParameterWhereInput
  }

  export type ReportParameterUpdateToOneWithWhereWithoutReportValueInput = {
    where?: ReportParameterWhereInput
    data: XOR<ReportParameterUpdateWithoutReportValueInput, ReportParameterUncheckedUpdateWithoutReportValueInput>
  }

  export type ReportParameterUpdateWithoutReportValueInput = {
    name?: StringFieldUpdateOperationsInput | string
    units?: NullableStringFieldUpdateOperationsInput | string | null
    ReportType?: ReportTypeUpdateOneWithoutParametersNestedInput
  }

  export type ReportParameterUncheckedUpdateWithoutReportValueInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    units?: NullableStringFieldUpdateOperationsInput | string | null
    reportTypeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DrugCreateWithoutStratergyHistoryInput = {
    name: string
    batch?: BatchCreateNestedManyWithoutDrugInput
    BatchHistory?: BatchHistoryCreateNestedManyWithoutDrugInput
    Issue?: IssueCreateNestedManyWithoutDrugInput
    bufferLevels?: BufferLevelCreateNestedManyWithoutDrugInput
  }

  export type DrugUncheckedCreateWithoutStratergyHistoryInput = {
    id?: number
    name: string
    batch?: BatchUncheckedCreateNestedManyWithoutDrugInput
    BatchHistory?: BatchHistoryUncheckedCreateNestedManyWithoutDrugInput
    Issue?: IssueUncheckedCreateNestedManyWithoutDrugInput
    bufferLevels?: BufferLevelUncheckedCreateNestedManyWithoutDrugInput
  }

  export type DrugCreateOrConnectWithoutStratergyHistoryInput = {
    where: DrugWhereUniqueInput
    create: XOR<DrugCreateWithoutStratergyHistoryInput, DrugUncheckedCreateWithoutStratergyHistoryInput>
  }

  export type IssueCreateWithoutStratergyHistoryInput = {
    strategy: $Enums.IssuingStrategy
    quantity: number
    dose: number
    details?: string | null
    meal?: $Enums.MEAL | null
    type: $Enums.DrugType
    batch?: BatchCreateNestedOneWithoutIssueInput
    brand: DrugBrandCreateNestedOneWithoutIssueInput
    drug: DrugCreateNestedOneWithoutIssueInput
    prescription: PrescriptionCreateNestedOneWithoutIssuesInput
    unitConcentration: UnitConcentrationCreateNestedOneWithoutIssueInput
  }

  export type IssueUncheckedCreateWithoutStratergyHistoryInput = {
    id?: number
    prescriptionId: number
    batchId?: number | null
    drugId: number
    brandId: number
    strategy: $Enums.IssuingStrategy
    quantity: number
    dose: number
    details?: string | null
    meal?: $Enums.MEAL | null
    type: $Enums.DrugType
    unitConcentrationId: number
  }

  export type IssueCreateOrConnectWithoutStratergyHistoryInput = {
    where: IssueWhereUniqueInput
    create: XOR<IssueCreateWithoutStratergyHistoryInput, IssueUncheckedCreateWithoutStratergyHistoryInput>
  }

  export type DrugUpsertWithoutStratergyHistoryInput = {
    update: XOR<DrugUpdateWithoutStratergyHistoryInput, DrugUncheckedUpdateWithoutStratergyHistoryInput>
    create: XOR<DrugCreateWithoutStratergyHistoryInput, DrugUncheckedCreateWithoutStratergyHistoryInput>
    where?: DrugWhereInput
  }

  export type DrugUpdateToOneWithWhereWithoutStratergyHistoryInput = {
    where?: DrugWhereInput
    data: XOR<DrugUpdateWithoutStratergyHistoryInput, DrugUncheckedUpdateWithoutStratergyHistoryInput>
  }

  export type DrugUpdateWithoutStratergyHistoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    batch?: BatchUpdateManyWithoutDrugNestedInput
    BatchHistory?: BatchHistoryUpdateManyWithoutDrugNestedInput
    Issue?: IssueUpdateManyWithoutDrugNestedInput
    bufferLevels?: BufferLevelUpdateManyWithoutDrugNestedInput
  }

  export type DrugUncheckedUpdateWithoutStratergyHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    batch?: BatchUncheckedUpdateManyWithoutDrugNestedInput
    BatchHistory?: BatchHistoryUncheckedUpdateManyWithoutDrugNestedInput
    Issue?: IssueUncheckedUpdateManyWithoutDrugNestedInput
    bufferLevels?: BufferLevelUncheckedUpdateManyWithoutDrugNestedInput
  }

  export type IssueUpsertWithoutStratergyHistoryInput = {
    update: XOR<IssueUpdateWithoutStratergyHistoryInput, IssueUncheckedUpdateWithoutStratergyHistoryInput>
    create: XOR<IssueCreateWithoutStratergyHistoryInput, IssueUncheckedCreateWithoutStratergyHistoryInput>
    where?: IssueWhereInput
  }

  export type IssueUpdateToOneWithWhereWithoutStratergyHistoryInput = {
    where?: IssueWhereInput
    data: XOR<IssueUpdateWithoutStratergyHistoryInput, IssueUncheckedUpdateWithoutStratergyHistoryInput>
  }

  export type IssueUpdateWithoutStratergyHistoryInput = {
    strategy?: EnumIssuingStrategyFieldUpdateOperationsInput | $Enums.IssuingStrategy
    quantity?: FloatFieldUpdateOperationsInput | number
    dose?: FloatFieldUpdateOperationsInput | number
    details?: NullableStringFieldUpdateOperationsInput | string | null
    meal?: NullableEnumMEALFieldUpdateOperationsInput | $Enums.MEAL | null
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    batch?: BatchUpdateOneWithoutIssueNestedInput
    brand?: DrugBrandUpdateOneRequiredWithoutIssueNestedInput
    drug?: DrugUpdateOneRequiredWithoutIssueNestedInput
    prescription?: PrescriptionUpdateOneRequiredWithoutIssuesNestedInput
    unitConcentration?: UnitConcentrationUpdateOneRequiredWithoutIssueNestedInput
  }

  export type IssueUncheckedUpdateWithoutStratergyHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    prescriptionId?: IntFieldUpdateOperationsInput | number
    batchId?: NullableIntFieldUpdateOperationsInput | number | null
    drugId?: IntFieldUpdateOperationsInput | number
    brandId?: IntFieldUpdateOperationsInput | number
    strategy?: EnumIssuingStrategyFieldUpdateOperationsInput | $Enums.IssuingStrategy
    quantity?: FloatFieldUpdateOperationsInput | number
    dose?: FloatFieldUpdateOperationsInput | number
    details?: NullableStringFieldUpdateOperationsInput | string | null
    meal?: NullableEnumMEALFieldUpdateOperationsInput | $Enums.MEAL | null
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    unitConcentrationId?: IntFieldUpdateOperationsInput | number
  }

  export type BatchCreateWithoutBatchHistoryInput = {
    number: string
    type: $Enums.DrugType
    fullAmount: number
    expiry: Date | string
    stockDate?: Date | string
    remainingQuantity: number
    wholesalePrice: number
    retailPrice: number
    status: $Enums.BatchStatus
    drugBrand: DrugBrandCreateNestedOneWithoutBatchInput
    drug: DrugCreateNestedOneWithoutBatchInput
    Supplier: SupplierCreateNestedOneWithoutBatchesInput
    unitConcentration: UnitConcentrationCreateNestedOneWithoutBatchInput
    Issue?: IssueCreateNestedManyWithoutBatchInput
  }

  export type BatchUncheckedCreateWithoutBatchHistoryInput = {
    id?: number
    number: string
    drugId: number
    drugBrandId: number
    type: $Enums.DrugType
    fullAmount: number
    expiry: Date | string
    stockDate?: Date | string
    remainingQuantity: number
    wholesalePrice: number
    retailPrice: number
    status: $Enums.BatchStatus
    unitConcentrationId: number
    supplierId: number
    Issue?: IssueUncheckedCreateNestedManyWithoutBatchInput
  }

  export type BatchCreateOrConnectWithoutBatchHistoryInput = {
    where: BatchWhereUniqueInput
    create: XOR<BatchCreateWithoutBatchHistoryInput, BatchUncheckedCreateWithoutBatchHistoryInput>
  }

  export type DrugBrandCreateWithoutBatchHistoryInput = {
    name: string
    description?: string | null
    Batch?: BatchCreateNestedManyWithoutDrugBrandInput
    Issue?: IssueCreateNestedManyWithoutBrandInput
  }

  export type DrugBrandUncheckedCreateWithoutBatchHistoryInput = {
    id?: number
    name: string
    description?: string | null
    Batch?: BatchUncheckedCreateNestedManyWithoutDrugBrandInput
    Issue?: IssueUncheckedCreateNestedManyWithoutBrandInput
  }

  export type DrugBrandCreateOrConnectWithoutBatchHistoryInput = {
    where: DrugBrandWhereUniqueInput
    create: XOR<DrugBrandCreateWithoutBatchHistoryInput, DrugBrandUncheckedCreateWithoutBatchHistoryInput>
  }

  export type DrugCreateWithoutBatchHistoryInput = {
    name: string
    batch?: BatchCreateNestedManyWithoutDrugInput
    Issue?: IssueCreateNestedManyWithoutDrugInput
    stratergyHistory?: StratergyHistoryCreateNestedOneWithoutDrugInput
    bufferLevels?: BufferLevelCreateNestedManyWithoutDrugInput
  }

  export type DrugUncheckedCreateWithoutBatchHistoryInput = {
    id?: number
    name: string
    batch?: BatchUncheckedCreateNestedManyWithoutDrugInput
    Issue?: IssueUncheckedCreateNestedManyWithoutDrugInput
    stratergyHistory?: StratergyHistoryUncheckedCreateNestedOneWithoutDrugInput
    bufferLevels?: BufferLevelUncheckedCreateNestedManyWithoutDrugInput
  }

  export type DrugCreateOrConnectWithoutBatchHistoryInput = {
    where: DrugWhereUniqueInput
    create: XOR<DrugCreateWithoutBatchHistoryInput, DrugUncheckedCreateWithoutBatchHistoryInput>
  }

  export type UnitConcentrationCreateWithoutBatchHistoryInput = {
    concentration: number
    Batch?: BatchCreateNestedManyWithoutUnitConcentrationInput
    Issue?: IssueCreateNestedManyWithoutUnitConcentrationInput
    BufferLevel?: BufferLevelCreateNestedManyWithoutUnitConcentrationInput
  }

  export type UnitConcentrationUncheckedCreateWithoutBatchHistoryInput = {
    id?: number
    concentration: number
    Batch?: BatchUncheckedCreateNestedManyWithoutUnitConcentrationInput
    Issue?: IssueUncheckedCreateNestedManyWithoutUnitConcentrationInput
    BufferLevel?: BufferLevelUncheckedCreateNestedManyWithoutUnitConcentrationInput
  }

  export type UnitConcentrationCreateOrConnectWithoutBatchHistoryInput = {
    where: UnitConcentrationWhereUniqueInput
    create: XOR<UnitConcentrationCreateWithoutBatchHistoryInput, UnitConcentrationUncheckedCreateWithoutBatchHistoryInput>
  }

  export type BatchUpsertWithoutBatchHistoryInput = {
    update: XOR<BatchUpdateWithoutBatchHistoryInput, BatchUncheckedUpdateWithoutBatchHistoryInput>
    create: XOR<BatchCreateWithoutBatchHistoryInput, BatchUncheckedCreateWithoutBatchHistoryInput>
    where?: BatchWhereInput
  }

  export type BatchUpdateToOneWithWhereWithoutBatchHistoryInput = {
    where?: BatchWhereInput
    data: XOR<BatchUpdateWithoutBatchHistoryInput, BatchUncheckedUpdateWithoutBatchHistoryInput>
  }

  export type BatchUpdateWithoutBatchHistoryInput = {
    number?: StringFieldUpdateOperationsInput | string
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    fullAmount?: FloatFieldUpdateOperationsInput | number
    expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    stockDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remainingQuantity?: FloatFieldUpdateOperationsInput | number
    wholesalePrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    drugBrand?: DrugBrandUpdateOneRequiredWithoutBatchNestedInput
    drug?: DrugUpdateOneRequiredWithoutBatchNestedInput
    Supplier?: SupplierUpdateOneRequiredWithoutBatchesNestedInput
    unitConcentration?: UnitConcentrationUpdateOneRequiredWithoutBatchNestedInput
    Issue?: IssueUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateWithoutBatchHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    drugId?: IntFieldUpdateOperationsInput | number
    drugBrandId?: IntFieldUpdateOperationsInput | number
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    fullAmount?: FloatFieldUpdateOperationsInput | number
    expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    stockDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remainingQuantity?: FloatFieldUpdateOperationsInput | number
    wholesalePrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    unitConcentrationId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    Issue?: IssueUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type DrugBrandUpsertWithoutBatchHistoryInput = {
    update: XOR<DrugBrandUpdateWithoutBatchHistoryInput, DrugBrandUncheckedUpdateWithoutBatchHistoryInput>
    create: XOR<DrugBrandCreateWithoutBatchHistoryInput, DrugBrandUncheckedCreateWithoutBatchHistoryInput>
    where?: DrugBrandWhereInput
  }

  export type DrugBrandUpdateToOneWithWhereWithoutBatchHistoryInput = {
    where?: DrugBrandWhereInput
    data: XOR<DrugBrandUpdateWithoutBatchHistoryInput, DrugBrandUncheckedUpdateWithoutBatchHistoryInput>
  }

  export type DrugBrandUpdateWithoutBatchHistoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    Batch?: BatchUpdateManyWithoutDrugBrandNestedInput
    Issue?: IssueUpdateManyWithoutBrandNestedInput
  }

  export type DrugBrandUncheckedUpdateWithoutBatchHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    Batch?: BatchUncheckedUpdateManyWithoutDrugBrandNestedInput
    Issue?: IssueUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type DrugUpsertWithoutBatchHistoryInput = {
    update: XOR<DrugUpdateWithoutBatchHistoryInput, DrugUncheckedUpdateWithoutBatchHistoryInput>
    create: XOR<DrugCreateWithoutBatchHistoryInput, DrugUncheckedCreateWithoutBatchHistoryInput>
    where?: DrugWhereInput
  }

  export type DrugUpdateToOneWithWhereWithoutBatchHistoryInput = {
    where?: DrugWhereInput
    data: XOR<DrugUpdateWithoutBatchHistoryInput, DrugUncheckedUpdateWithoutBatchHistoryInput>
  }

  export type DrugUpdateWithoutBatchHistoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    batch?: BatchUpdateManyWithoutDrugNestedInput
    Issue?: IssueUpdateManyWithoutDrugNestedInput
    stratergyHistory?: StratergyHistoryUpdateOneWithoutDrugNestedInput
    bufferLevels?: BufferLevelUpdateManyWithoutDrugNestedInput
  }

  export type DrugUncheckedUpdateWithoutBatchHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    batch?: BatchUncheckedUpdateManyWithoutDrugNestedInput
    Issue?: IssueUncheckedUpdateManyWithoutDrugNestedInput
    stratergyHistory?: StratergyHistoryUncheckedUpdateOneWithoutDrugNestedInput
    bufferLevels?: BufferLevelUncheckedUpdateManyWithoutDrugNestedInput
  }

  export type UnitConcentrationUpsertWithoutBatchHistoryInput = {
    update: XOR<UnitConcentrationUpdateWithoutBatchHistoryInput, UnitConcentrationUncheckedUpdateWithoutBatchHistoryInput>
    create: XOR<UnitConcentrationCreateWithoutBatchHistoryInput, UnitConcentrationUncheckedCreateWithoutBatchHistoryInput>
    where?: UnitConcentrationWhereInput
  }

  export type UnitConcentrationUpdateToOneWithWhereWithoutBatchHistoryInput = {
    where?: UnitConcentrationWhereInput
    data: XOR<UnitConcentrationUpdateWithoutBatchHistoryInput, UnitConcentrationUncheckedUpdateWithoutBatchHistoryInput>
  }

  export type UnitConcentrationUpdateWithoutBatchHistoryInput = {
    concentration?: FloatFieldUpdateOperationsInput | number
    Batch?: BatchUpdateManyWithoutUnitConcentrationNestedInput
    Issue?: IssueUpdateManyWithoutUnitConcentrationNestedInput
    BufferLevel?: BufferLevelUpdateManyWithoutUnitConcentrationNestedInput
  }

  export type UnitConcentrationUncheckedUpdateWithoutBatchHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    concentration?: FloatFieldUpdateOperationsInput | number
    Batch?: BatchUncheckedUpdateManyWithoutUnitConcentrationNestedInput
    Issue?: IssueUncheckedUpdateManyWithoutUnitConcentrationNestedInput
    BufferLevel?: BufferLevelUncheckedUpdateManyWithoutUnitConcentrationNestedInput
  }

  export type MedicalCertificateCreateManyPatientInput = {
    id?: number
    nameOfThePatient: string
    addressOfThePatient: string
    fitForDuty: $Enums.MedicalCertificateStatus
    dateOfSickness: Date | string
    recommendedLeaveDays: number
    natureOfTheDisease: string
    ageOfThePatient: number
    reccomendations: string
    time: Date | string
  }

  export type PatientHistoryCreateManyPatientInput = {
    id?: number
    description?: string | null
    type: $Enums.PatientHistoryType
    time?: Date | string
    name: string
  }

  export type PatientReportCreateManyPatientInput = {
    id?: number
    reportTypeId: number
    time?: Date | string
  }

  export type PrescriptionCreateManyPatientInput = {
    id?: number
    time?: Date | string
    presentingSymptoms: string
    status?: $Enums.PrescriptionStatus
    details?: string | null
    finalPrice?: number | null
  }

  export type QueueEntryCreateManyPatientInput = {
    id?: number
    token: number
    status?: $Enums.VisitStatus
    queueId: number
    time?: Date | string
  }

  export type USSReferralCreateManyPatientInput = {
    id?: number
    nameOfThePatient: string
    presentingComplaint: string
    duration: string
    onExamination: string
    pshx_pmhx: string
    ageOfThePatient: number
    reportDate: Date | string
    USS_type: string
    radiologist: string
    radiologist_title: string
    time?: Date | string
  }

  export type ReferralLetterCreateManyPatientInput = {
    id?: number
    nameOfThePatient: string
    consultant_speciality: string
    consultant_name: string
    condition1: string
    condition2: string
    condition3: string
    investigations: string
    ageOfThePatient: number
    reportDate: Date | string
    time?: Date | string
  }

  export type MedicalCertificateUpdateWithoutPatientInput = {
    nameOfThePatient?: StringFieldUpdateOperationsInput | string
    addressOfThePatient?: StringFieldUpdateOperationsInput | string
    fitForDuty?: EnumMedicalCertificateStatusFieldUpdateOperationsInput | $Enums.MedicalCertificateStatus
    dateOfSickness?: DateTimeFieldUpdateOperationsInput | Date | string
    recommendedLeaveDays?: IntFieldUpdateOperationsInput | number
    natureOfTheDisease?: StringFieldUpdateOperationsInput | string
    ageOfThePatient?: IntFieldUpdateOperationsInput | number
    reccomendations?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalCertificateUncheckedUpdateWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    nameOfThePatient?: StringFieldUpdateOperationsInput | string
    addressOfThePatient?: StringFieldUpdateOperationsInput | string
    fitForDuty?: EnumMedicalCertificateStatusFieldUpdateOperationsInput | $Enums.MedicalCertificateStatus
    dateOfSickness?: DateTimeFieldUpdateOperationsInput | Date | string
    recommendedLeaveDays?: IntFieldUpdateOperationsInput | number
    natureOfTheDisease?: StringFieldUpdateOperationsInput | string
    ageOfThePatient?: IntFieldUpdateOperationsInput | number
    reccomendations?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalCertificateUncheckedUpdateManyWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    nameOfThePatient?: StringFieldUpdateOperationsInput | string
    addressOfThePatient?: StringFieldUpdateOperationsInput | string
    fitForDuty?: EnumMedicalCertificateStatusFieldUpdateOperationsInput | $Enums.MedicalCertificateStatus
    dateOfSickness?: DateTimeFieldUpdateOperationsInput | Date | string
    recommendedLeaveDays?: IntFieldUpdateOperationsInput | number
    natureOfTheDisease?: StringFieldUpdateOperationsInput | string
    ageOfThePatient?: IntFieldUpdateOperationsInput | number
    reccomendations?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientHistoryUpdateWithoutPatientInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPatientHistoryTypeFieldUpdateOperationsInput | $Enums.PatientHistoryType
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PatientHistoryUncheckedUpdateWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPatientHistoryTypeFieldUpdateOperationsInput | $Enums.PatientHistoryType
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PatientHistoryUncheckedUpdateManyWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPatientHistoryTypeFieldUpdateOperationsInput | $Enums.PatientHistoryType
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PatientReportUpdateWithoutPatientInput = {
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    reportType?: ReportTypeUpdateOneRequiredWithoutPatientReportNestedInput
    parameters?: ReportValueUpdateManyWithoutPatientReportNestedInput
  }

  export type PatientReportUncheckedUpdateWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    reportTypeId?: IntFieldUpdateOperationsInput | number
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    parameters?: ReportValueUncheckedUpdateManyWithoutPatientReportNestedInput
  }

  export type PatientReportUncheckedUpdateManyWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    reportTypeId?: IntFieldUpdateOperationsInput | number
    time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrescriptionUpdateWithoutPatientInput = {
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    presentingSymptoms?: StringFieldUpdateOperationsInput | string
    status?: EnumPrescriptionStatusFieldUpdateOperationsInput | $Enums.PrescriptionStatus
    details?: NullableStringFieldUpdateOperationsInput | string | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    issues?: IssueUpdateManyWithoutPrescriptionNestedInput
    OffRecordMeds?: OffRecordMedsUpdateManyWithoutPrescriptionNestedInput
    PrescriptionVitals?: PrescriptionVitalsUpdateManyWithoutPrescriptionNestedInput
    Charges?: PrescriptionChargesUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    presentingSymptoms?: StringFieldUpdateOperationsInput | string
    status?: EnumPrescriptionStatusFieldUpdateOperationsInput | $Enums.PrescriptionStatus
    details?: NullableStringFieldUpdateOperationsInput | string | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    issues?: IssueUncheckedUpdateManyWithoutPrescriptionNestedInput
    OffRecordMeds?: OffRecordMedsUncheckedUpdateManyWithoutPrescriptionNestedInput
    PrescriptionVitals?: PrescriptionVitalsUncheckedUpdateManyWithoutPrescriptionNestedInput
    Charges?: PrescriptionChargesUncheckedUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateManyWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    presentingSymptoms?: StringFieldUpdateOperationsInput | string
    status?: EnumPrescriptionStatusFieldUpdateOperationsInput | $Enums.PrescriptionStatus
    details?: NullableStringFieldUpdateOperationsInput | string | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type QueueEntryUpdateWithoutPatientInput = {
    token?: IntFieldUpdateOperationsInput | number
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    queue?: QueueUpdateOneRequiredWithoutEntriesNestedInput
  }

  export type QueueEntryUncheckedUpdateWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: IntFieldUpdateOperationsInput | number
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    queueId?: IntFieldUpdateOperationsInput | number
    time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QueueEntryUncheckedUpdateManyWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: IntFieldUpdateOperationsInput | number
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    queueId?: IntFieldUpdateOperationsInput | number
    time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type USSReferralUpdateWithoutPatientInput = {
    nameOfThePatient?: StringFieldUpdateOperationsInput | string
    presentingComplaint?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    onExamination?: StringFieldUpdateOperationsInput | string
    pshx_pmhx?: StringFieldUpdateOperationsInput | string
    ageOfThePatient?: IntFieldUpdateOperationsInput | number
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    USS_type?: StringFieldUpdateOperationsInput | string
    radiologist?: StringFieldUpdateOperationsInput | string
    radiologist_title?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type USSReferralUncheckedUpdateWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    nameOfThePatient?: StringFieldUpdateOperationsInput | string
    presentingComplaint?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    onExamination?: StringFieldUpdateOperationsInput | string
    pshx_pmhx?: StringFieldUpdateOperationsInput | string
    ageOfThePatient?: IntFieldUpdateOperationsInput | number
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    USS_type?: StringFieldUpdateOperationsInput | string
    radiologist?: StringFieldUpdateOperationsInput | string
    radiologist_title?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type USSReferralUncheckedUpdateManyWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    nameOfThePatient?: StringFieldUpdateOperationsInput | string
    presentingComplaint?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    onExamination?: StringFieldUpdateOperationsInput | string
    pshx_pmhx?: StringFieldUpdateOperationsInput | string
    ageOfThePatient?: IntFieldUpdateOperationsInput | number
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    USS_type?: StringFieldUpdateOperationsInput | string
    radiologist?: StringFieldUpdateOperationsInput | string
    radiologist_title?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralLetterUpdateWithoutPatientInput = {
    nameOfThePatient?: StringFieldUpdateOperationsInput | string
    consultant_speciality?: StringFieldUpdateOperationsInput | string
    consultant_name?: StringFieldUpdateOperationsInput | string
    condition1?: StringFieldUpdateOperationsInput | string
    condition2?: StringFieldUpdateOperationsInput | string
    condition3?: StringFieldUpdateOperationsInput | string
    investigations?: StringFieldUpdateOperationsInput | string
    ageOfThePatient?: IntFieldUpdateOperationsInput | number
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralLetterUncheckedUpdateWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    nameOfThePatient?: StringFieldUpdateOperationsInput | string
    consultant_speciality?: StringFieldUpdateOperationsInput | string
    consultant_name?: StringFieldUpdateOperationsInput | string
    condition1?: StringFieldUpdateOperationsInput | string
    condition2?: StringFieldUpdateOperationsInput | string
    condition3?: StringFieldUpdateOperationsInput | string
    investigations?: StringFieldUpdateOperationsInput | string
    ageOfThePatient?: IntFieldUpdateOperationsInput | number
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralLetterUncheckedUpdateManyWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    nameOfThePatient?: StringFieldUpdateOperationsInput | string
    consultant_speciality?: StringFieldUpdateOperationsInput | string
    consultant_name?: StringFieldUpdateOperationsInput | string
    condition1?: StringFieldUpdateOperationsInput | string
    condition2?: StringFieldUpdateOperationsInput | string
    condition3?: StringFieldUpdateOperationsInput | string
    investigations?: StringFieldUpdateOperationsInput | string
    ageOfThePatient?: IntFieldUpdateOperationsInput | number
    reportDate?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QueueEntryCreateManyQueueInput = {
    id?: number
    token: number
    status?: $Enums.VisitStatus
    patientId: number
    time?: Date | string
  }

  export type QueueEntryUpdateWithoutQueueInput = {
    token?: IntFieldUpdateOperationsInput | number
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutQueueEntryNestedInput
  }

  export type QueueEntryUncheckedUpdateWithoutQueueInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: IntFieldUpdateOperationsInput | number
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    patientId?: IntFieldUpdateOperationsInput | number
    time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QueueEntryUncheckedUpdateManyWithoutQueueInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: IntFieldUpdateOperationsInput | number
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    patientId?: IntFieldUpdateOperationsInput | number
    time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchCreateManyDrugBrandInput = {
    id?: number
    number: string
    drugId: number
    type: $Enums.DrugType
    fullAmount: number
    expiry: Date | string
    stockDate?: Date | string
    remainingQuantity: number
    wholesalePrice: number
    retailPrice: number
    status: $Enums.BatchStatus
    unitConcentrationId: number
    supplierId: number
  }

  export type BatchHistoryCreateManyBrandInput = {
    id?: number
    drugId: number
    type: $Enums.DrugType
    unitConcentrationId: number
    batchId: number
  }

  export type IssueCreateManyBrandInput = {
    id?: number
    prescriptionId: number
    batchId?: number | null
    drugId: number
    strategy: $Enums.IssuingStrategy
    quantity: number
    dose: number
    details?: string | null
    meal?: $Enums.MEAL | null
    type: $Enums.DrugType
    unitConcentrationId: number
  }

  export type BatchUpdateWithoutDrugBrandInput = {
    number?: StringFieldUpdateOperationsInput | string
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    fullAmount?: FloatFieldUpdateOperationsInput | number
    expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    stockDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remainingQuantity?: FloatFieldUpdateOperationsInput | number
    wholesalePrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    drug?: DrugUpdateOneRequiredWithoutBatchNestedInput
    Supplier?: SupplierUpdateOneRequiredWithoutBatchesNestedInput
    unitConcentration?: UnitConcentrationUpdateOneRequiredWithoutBatchNestedInput
    BatchHistory?: BatchHistoryUpdateManyWithoutBatchNestedInput
    Issue?: IssueUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateWithoutDrugBrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    drugId?: IntFieldUpdateOperationsInput | number
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    fullAmount?: FloatFieldUpdateOperationsInput | number
    expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    stockDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remainingQuantity?: FloatFieldUpdateOperationsInput | number
    wholesalePrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    unitConcentrationId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    BatchHistory?: BatchHistoryUncheckedUpdateManyWithoutBatchNestedInput
    Issue?: IssueUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateManyWithoutDrugBrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    drugId?: IntFieldUpdateOperationsInput | number
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    fullAmount?: FloatFieldUpdateOperationsInput | number
    expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    stockDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remainingQuantity?: FloatFieldUpdateOperationsInput | number
    wholesalePrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    unitConcentrationId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
  }

  export type BatchHistoryUpdateWithoutBrandInput = {
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    batch?: BatchUpdateOneRequiredWithoutBatchHistoryNestedInput
    drug?: DrugUpdateOneRequiredWithoutBatchHistoryNestedInput
    unitConcentration?: UnitConcentrationUpdateOneRequiredWithoutBatchHistoryNestedInput
  }

  export type BatchHistoryUncheckedUpdateWithoutBrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    drugId?: IntFieldUpdateOperationsInput | number
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    unitConcentrationId?: IntFieldUpdateOperationsInput | number
    batchId?: IntFieldUpdateOperationsInput | number
  }

  export type BatchHistoryUncheckedUpdateManyWithoutBrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    drugId?: IntFieldUpdateOperationsInput | number
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    unitConcentrationId?: IntFieldUpdateOperationsInput | number
    batchId?: IntFieldUpdateOperationsInput | number
  }

  export type IssueUpdateWithoutBrandInput = {
    strategy?: EnumIssuingStrategyFieldUpdateOperationsInput | $Enums.IssuingStrategy
    quantity?: FloatFieldUpdateOperationsInput | number
    dose?: FloatFieldUpdateOperationsInput | number
    details?: NullableStringFieldUpdateOperationsInput | string | null
    meal?: NullableEnumMEALFieldUpdateOperationsInput | $Enums.MEAL | null
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    batch?: BatchUpdateOneWithoutIssueNestedInput
    drug?: DrugUpdateOneRequiredWithoutIssueNestedInput
    prescription?: PrescriptionUpdateOneRequiredWithoutIssuesNestedInput
    unitConcentration?: UnitConcentrationUpdateOneRequiredWithoutIssueNestedInput
    stratergyHistory?: StratergyHistoryUpdateManyWithoutIssueNestedInput
  }

  export type IssueUncheckedUpdateWithoutBrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    prescriptionId?: IntFieldUpdateOperationsInput | number
    batchId?: NullableIntFieldUpdateOperationsInput | number | null
    drugId?: IntFieldUpdateOperationsInput | number
    strategy?: EnumIssuingStrategyFieldUpdateOperationsInput | $Enums.IssuingStrategy
    quantity?: FloatFieldUpdateOperationsInput | number
    dose?: FloatFieldUpdateOperationsInput | number
    details?: NullableStringFieldUpdateOperationsInput | string | null
    meal?: NullableEnumMEALFieldUpdateOperationsInput | $Enums.MEAL | null
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    unitConcentrationId?: IntFieldUpdateOperationsInput | number
    stratergyHistory?: StratergyHistoryUncheckedUpdateManyWithoutIssueNestedInput
  }

  export type IssueUncheckedUpdateManyWithoutBrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    prescriptionId?: IntFieldUpdateOperationsInput | number
    batchId?: NullableIntFieldUpdateOperationsInput | number | null
    drugId?: IntFieldUpdateOperationsInput | number
    strategy?: EnumIssuingStrategyFieldUpdateOperationsInput | $Enums.IssuingStrategy
    quantity?: FloatFieldUpdateOperationsInput | number
    dose?: FloatFieldUpdateOperationsInput | number
    details?: NullableStringFieldUpdateOperationsInput | string | null
    meal?: NullableEnumMEALFieldUpdateOperationsInput | $Enums.MEAL | null
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    unitConcentrationId?: IntFieldUpdateOperationsInput | number
  }

  export type BatchCreateManyDrugInput = {
    id?: number
    number: string
    drugBrandId: number
    type: $Enums.DrugType
    fullAmount: number
    expiry: Date | string
    stockDate?: Date | string
    remainingQuantity: number
    wholesalePrice: number
    retailPrice: number
    status: $Enums.BatchStatus
    unitConcentrationId: number
    supplierId: number
  }

  export type BatchHistoryCreateManyDrugInput = {
    id?: number
    type: $Enums.DrugType
    unitConcentrationId: number
    drugBrandId: number
    batchId: number
  }

  export type IssueCreateManyDrugInput = {
    id?: number
    prescriptionId: number
    batchId?: number | null
    brandId: number
    strategy: $Enums.IssuingStrategy
    quantity: number
    dose: number
    details?: string | null
    meal?: $Enums.MEAL | null
    type: $Enums.DrugType
    unitConcentrationId: number
  }

  export type BufferLevelCreateManyDrugInput = {
    id?: number
    type: $Enums.DrugType
    unitConcentrationId: number
    bufferAmount: number
  }

  export type BatchUpdateWithoutDrugInput = {
    number?: StringFieldUpdateOperationsInput | string
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    fullAmount?: FloatFieldUpdateOperationsInput | number
    expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    stockDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remainingQuantity?: FloatFieldUpdateOperationsInput | number
    wholesalePrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    drugBrand?: DrugBrandUpdateOneRequiredWithoutBatchNestedInput
    Supplier?: SupplierUpdateOneRequiredWithoutBatchesNestedInput
    unitConcentration?: UnitConcentrationUpdateOneRequiredWithoutBatchNestedInput
    BatchHistory?: BatchHistoryUpdateManyWithoutBatchNestedInput
    Issue?: IssueUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateWithoutDrugInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    drugBrandId?: IntFieldUpdateOperationsInput | number
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    fullAmount?: FloatFieldUpdateOperationsInput | number
    expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    stockDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remainingQuantity?: FloatFieldUpdateOperationsInput | number
    wholesalePrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    unitConcentrationId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    BatchHistory?: BatchHistoryUncheckedUpdateManyWithoutBatchNestedInput
    Issue?: IssueUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateManyWithoutDrugInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    drugBrandId?: IntFieldUpdateOperationsInput | number
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    fullAmount?: FloatFieldUpdateOperationsInput | number
    expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    stockDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remainingQuantity?: FloatFieldUpdateOperationsInput | number
    wholesalePrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    unitConcentrationId?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
  }

  export type BatchHistoryUpdateWithoutDrugInput = {
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    batch?: BatchUpdateOneRequiredWithoutBatchHistoryNestedInput
    brand?: DrugBrandUpdateOneRequiredWithoutBatchHistoryNestedInput
    unitConcentration?: UnitConcentrationUpdateOneRequiredWithoutBatchHistoryNestedInput
  }

  export type BatchHistoryUncheckedUpdateWithoutDrugInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    unitConcentrationId?: IntFieldUpdateOperationsInput | number
    drugBrandId?: IntFieldUpdateOperationsInput | number
    batchId?: IntFieldUpdateOperationsInput | number
  }

  export type BatchHistoryUncheckedUpdateManyWithoutDrugInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    unitConcentrationId?: IntFieldUpdateOperationsInput | number
    drugBrandId?: IntFieldUpdateOperationsInput | number
    batchId?: IntFieldUpdateOperationsInput | number
  }

  export type IssueUpdateWithoutDrugInput = {
    strategy?: EnumIssuingStrategyFieldUpdateOperationsInput | $Enums.IssuingStrategy
    quantity?: FloatFieldUpdateOperationsInput | number
    dose?: FloatFieldUpdateOperationsInput | number
    details?: NullableStringFieldUpdateOperationsInput | string | null
    meal?: NullableEnumMEALFieldUpdateOperationsInput | $Enums.MEAL | null
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    batch?: BatchUpdateOneWithoutIssueNestedInput
    brand?: DrugBrandUpdateOneRequiredWithoutIssueNestedInput
    prescription?: PrescriptionUpdateOneRequiredWithoutIssuesNestedInput
    unitConcentration?: UnitConcentrationUpdateOneRequiredWithoutIssueNestedInput
    stratergyHistory?: StratergyHistoryUpdateManyWithoutIssueNestedInput
  }

  export type IssueUncheckedUpdateWithoutDrugInput = {
    id?: IntFieldUpdateOperationsInput | number
    prescriptionId?: IntFieldUpdateOperationsInput | number
    batchId?: NullableIntFieldUpdateOperationsInput | number | null
    brandId?: IntFieldUpdateOperationsInput | number
    strategy?: EnumIssuingStrategyFieldUpdateOperationsInput | $Enums.IssuingStrategy
    quantity?: FloatFieldUpdateOperationsInput | number
    dose?: FloatFieldUpdateOperationsInput | number
    details?: NullableStringFieldUpdateOperationsInput | string | null
    meal?: NullableEnumMEALFieldUpdateOperationsInput | $Enums.MEAL | null
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    unitConcentrationId?: IntFieldUpdateOperationsInput | number
    stratergyHistory?: StratergyHistoryUncheckedUpdateManyWithoutIssueNestedInput
  }

  export type IssueUncheckedUpdateManyWithoutDrugInput = {
    id?: IntFieldUpdateOperationsInput | number
    prescriptionId?: IntFieldUpdateOperationsInput | number
    batchId?: NullableIntFieldUpdateOperationsInput | number | null
    brandId?: IntFieldUpdateOperationsInput | number
    strategy?: EnumIssuingStrategyFieldUpdateOperationsInput | $Enums.IssuingStrategy
    quantity?: FloatFieldUpdateOperationsInput | number
    dose?: FloatFieldUpdateOperationsInput | number
    details?: NullableStringFieldUpdateOperationsInput | string | null
    meal?: NullableEnumMEALFieldUpdateOperationsInput | $Enums.MEAL | null
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    unitConcentrationId?: IntFieldUpdateOperationsInput | number
  }

  export type BufferLevelUpdateWithoutDrugInput = {
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    bufferAmount?: IntFieldUpdateOperationsInput | number
    unitConcentration?: UnitConcentrationUpdateOneRequiredWithoutBufferLevelNestedInput
  }

  export type BufferLevelUncheckedUpdateWithoutDrugInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    unitConcentrationId?: IntFieldUpdateOperationsInput | number
    bufferAmount?: IntFieldUpdateOperationsInput | number
  }

  export type BufferLevelUncheckedUpdateManyWithoutDrugInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    unitConcentrationId?: IntFieldUpdateOperationsInput | number
    bufferAmount?: IntFieldUpdateOperationsInput | number
  }

  export type BatchCreateManySupplierInput = {
    id?: number
    number: string
    drugId: number
    drugBrandId: number
    type: $Enums.DrugType
    fullAmount: number
    expiry: Date | string
    stockDate?: Date | string
    remainingQuantity: number
    wholesalePrice: number
    retailPrice: number
    status: $Enums.BatchStatus
    unitConcentrationId: number
  }

  export type BatchUpdateWithoutSupplierInput = {
    number?: StringFieldUpdateOperationsInput | string
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    fullAmount?: FloatFieldUpdateOperationsInput | number
    expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    stockDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remainingQuantity?: FloatFieldUpdateOperationsInput | number
    wholesalePrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    drugBrand?: DrugBrandUpdateOneRequiredWithoutBatchNestedInput
    drug?: DrugUpdateOneRequiredWithoutBatchNestedInput
    unitConcentration?: UnitConcentrationUpdateOneRequiredWithoutBatchNestedInput
    BatchHistory?: BatchHistoryUpdateManyWithoutBatchNestedInput
    Issue?: IssueUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    drugId?: IntFieldUpdateOperationsInput | number
    drugBrandId?: IntFieldUpdateOperationsInput | number
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    fullAmount?: FloatFieldUpdateOperationsInput | number
    expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    stockDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remainingQuantity?: FloatFieldUpdateOperationsInput | number
    wholesalePrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    unitConcentrationId?: IntFieldUpdateOperationsInput | number
    BatchHistory?: BatchHistoryUncheckedUpdateManyWithoutBatchNestedInput
    Issue?: IssueUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateManyWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    drugId?: IntFieldUpdateOperationsInput | number
    drugBrandId?: IntFieldUpdateOperationsInput | number
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    fullAmount?: FloatFieldUpdateOperationsInput | number
    expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    stockDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remainingQuantity?: FloatFieldUpdateOperationsInput | number
    wholesalePrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    unitConcentrationId?: IntFieldUpdateOperationsInput | number
  }

  export type BatchHistoryCreateManyBatchInput = {
    id?: number
    drugId: number
    type: $Enums.DrugType
    unitConcentrationId: number
    drugBrandId: number
  }

  export type IssueCreateManyBatchInput = {
    id?: number
    prescriptionId: number
    drugId: number
    brandId: number
    strategy: $Enums.IssuingStrategy
    quantity: number
    dose: number
    details?: string | null
    meal?: $Enums.MEAL | null
    type: $Enums.DrugType
    unitConcentrationId: number
  }

  export type BatchHistoryUpdateWithoutBatchInput = {
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    brand?: DrugBrandUpdateOneRequiredWithoutBatchHistoryNestedInput
    drug?: DrugUpdateOneRequiredWithoutBatchHistoryNestedInput
    unitConcentration?: UnitConcentrationUpdateOneRequiredWithoutBatchHistoryNestedInput
  }

  export type BatchHistoryUncheckedUpdateWithoutBatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    drugId?: IntFieldUpdateOperationsInput | number
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    unitConcentrationId?: IntFieldUpdateOperationsInput | number
    drugBrandId?: IntFieldUpdateOperationsInput | number
  }

  export type BatchHistoryUncheckedUpdateManyWithoutBatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    drugId?: IntFieldUpdateOperationsInput | number
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    unitConcentrationId?: IntFieldUpdateOperationsInput | number
    drugBrandId?: IntFieldUpdateOperationsInput | number
  }

  export type IssueUpdateWithoutBatchInput = {
    strategy?: EnumIssuingStrategyFieldUpdateOperationsInput | $Enums.IssuingStrategy
    quantity?: FloatFieldUpdateOperationsInput | number
    dose?: FloatFieldUpdateOperationsInput | number
    details?: NullableStringFieldUpdateOperationsInput | string | null
    meal?: NullableEnumMEALFieldUpdateOperationsInput | $Enums.MEAL | null
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    brand?: DrugBrandUpdateOneRequiredWithoutIssueNestedInput
    drug?: DrugUpdateOneRequiredWithoutIssueNestedInput
    prescription?: PrescriptionUpdateOneRequiredWithoutIssuesNestedInput
    unitConcentration?: UnitConcentrationUpdateOneRequiredWithoutIssueNestedInput
    stratergyHistory?: StratergyHistoryUpdateManyWithoutIssueNestedInput
  }

  export type IssueUncheckedUpdateWithoutBatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    prescriptionId?: IntFieldUpdateOperationsInput | number
    drugId?: IntFieldUpdateOperationsInput | number
    brandId?: IntFieldUpdateOperationsInput | number
    strategy?: EnumIssuingStrategyFieldUpdateOperationsInput | $Enums.IssuingStrategy
    quantity?: FloatFieldUpdateOperationsInput | number
    dose?: FloatFieldUpdateOperationsInput | number
    details?: NullableStringFieldUpdateOperationsInput | string | null
    meal?: NullableEnumMEALFieldUpdateOperationsInput | $Enums.MEAL | null
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    unitConcentrationId?: IntFieldUpdateOperationsInput | number
    stratergyHistory?: StratergyHistoryUncheckedUpdateManyWithoutIssueNestedInput
  }

  export type IssueUncheckedUpdateManyWithoutBatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    prescriptionId?: IntFieldUpdateOperationsInput | number
    drugId?: IntFieldUpdateOperationsInput | number
    brandId?: IntFieldUpdateOperationsInput | number
    strategy?: EnumIssuingStrategyFieldUpdateOperationsInput | $Enums.IssuingStrategy
    quantity?: FloatFieldUpdateOperationsInput | number
    dose?: FloatFieldUpdateOperationsInput | number
    details?: NullableStringFieldUpdateOperationsInput | string | null
    meal?: NullableEnumMEALFieldUpdateOperationsInput | $Enums.MEAL | null
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    unitConcentrationId?: IntFieldUpdateOperationsInput | number
  }

  export type BatchCreateManyUnitConcentrationInput = {
    id?: number
    number: string
    drugId: number
    drugBrandId: number
    type: $Enums.DrugType
    fullAmount: number
    expiry: Date | string
    stockDate?: Date | string
    remainingQuantity: number
    wholesalePrice: number
    retailPrice: number
    status: $Enums.BatchStatus
    supplierId: number
  }

  export type BatchHistoryCreateManyUnitConcentrationInput = {
    id?: number
    drugId: number
    type: $Enums.DrugType
    drugBrandId: number
    batchId: number
  }

  export type IssueCreateManyUnitConcentrationInput = {
    id?: number
    prescriptionId: number
    batchId?: number | null
    drugId: number
    brandId: number
    strategy: $Enums.IssuingStrategy
    quantity: number
    dose: number
    details?: string | null
    meal?: $Enums.MEAL | null
    type: $Enums.DrugType
  }

  export type BufferLevelCreateManyUnitConcentrationInput = {
    id?: number
    drugId: number
    type: $Enums.DrugType
    bufferAmount: number
  }

  export type BatchUpdateWithoutUnitConcentrationInput = {
    number?: StringFieldUpdateOperationsInput | string
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    fullAmount?: FloatFieldUpdateOperationsInput | number
    expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    stockDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remainingQuantity?: FloatFieldUpdateOperationsInput | number
    wholesalePrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    drugBrand?: DrugBrandUpdateOneRequiredWithoutBatchNestedInput
    drug?: DrugUpdateOneRequiredWithoutBatchNestedInput
    Supplier?: SupplierUpdateOneRequiredWithoutBatchesNestedInput
    BatchHistory?: BatchHistoryUpdateManyWithoutBatchNestedInput
    Issue?: IssueUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateWithoutUnitConcentrationInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    drugId?: IntFieldUpdateOperationsInput | number
    drugBrandId?: IntFieldUpdateOperationsInput | number
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    fullAmount?: FloatFieldUpdateOperationsInput | number
    expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    stockDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remainingQuantity?: FloatFieldUpdateOperationsInput | number
    wholesalePrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    supplierId?: IntFieldUpdateOperationsInput | number
    BatchHistory?: BatchHistoryUncheckedUpdateManyWithoutBatchNestedInput
    Issue?: IssueUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateManyWithoutUnitConcentrationInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    drugId?: IntFieldUpdateOperationsInput | number
    drugBrandId?: IntFieldUpdateOperationsInput | number
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    fullAmount?: FloatFieldUpdateOperationsInput | number
    expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    stockDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remainingQuantity?: FloatFieldUpdateOperationsInput | number
    wholesalePrice?: FloatFieldUpdateOperationsInput | number
    retailPrice?: FloatFieldUpdateOperationsInput | number
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    supplierId?: IntFieldUpdateOperationsInput | number
  }

  export type BatchHistoryUpdateWithoutUnitConcentrationInput = {
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    batch?: BatchUpdateOneRequiredWithoutBatchHistoryNestedInput
    brand?: DrugBrandUpdateOneRequiredWithoutBatchHistoryNestedInput
    drug?: DrugUpdateOneRequiredWithoutBatchHistoryNestedInput
  }

  export type BatchHistoryUncheckedUpdateWithoutUnitConcentrationInput = {
    id?: IntFieldUpdateOperationsInput | number
    drugId?: IntFieldUpdateOperationsInput | number
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    drugBrandId?: IntFieldUpdateOperationsInput | number
    batchId?: IntFieldUpdateOperationsInput | number
  }

  export type BatchHistoryUncheckedUpdateManyWithoutUnitConcentrationInput = {
    id?: IntFieldUpdateOperationsInput | number
    drugId?: IntFieldUpdateOperationsInput | number
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    drugBrandId?: IntFieldUpdateOperationsInput | number
    batchId?: IntFieldUpdateOperationsInput | number
  }

  export type IssueUpdateWithoutUnitConcentrationInput = {
    strategy?: EnumIssuingStrategyFieldUpdateOperationsInput | $Enums.IssuingStrategy
    quantity?: FloatFieldUpdateOperationsInput | number
    dose?: FloatFieldUpdateOperationsInput | number
    details?: NullableStringFieldUpdateOperationsInput | string | null
    meal?: NullableEnumMEALFieldUpdateOperationsInput | $Enums.MEAL | null
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    batch?: BatchUpdateOneWithoutIssueNestedInput
    brand?: DrugBrandUpdateOneRequiredWithoutIssueNestedInput
    drug?: DrugUpdateOneRequiredWithoutIssueNestedInput
    prescription?: PrescriptionUpdateOneRequiredWithoutIssuesNestedInput
    stratergyHistory?: StratergyHistoryUpdateManyWithoutIssueNestedInput
  }

  export type IssueUncheckedUpdateWithoutUnitConcentrationInput = {
    id?: IntFieldUpdateOperationsInput | number
    prescriptionId?: IntFieldUpdateOperationsInput | number
    batchId?: NullableIntFieldUpdateOperationsInput | number | null
    drugId?: IntFieldUpdateOperationsInput | number
    brandId?: IntFieldUpdateOperationsInput | number
    strategy?: EnumIssuingStrategyFieldUpdateOperationsInput | $Enums.IssuingStrategy
    quantity?: FloatFieldUpdateOperationsInput | number
    dose?: FloatFieldUpdateOperationsInput | number
    details?: NullableStringFieldUpdateOperationsInput | string | null
    meal?: NullableEnumMEALFieldUpdateOperationsInput | $Enums.MEAL | null
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    stratergyHistory?: StratergyHistoryUncheckedUpdateManyWithoutIssueNestedInput
  }

  export type IssueUncheckedUpdateManyWithoutUnitConcentrationInput = {
    id?: IntFieldUpdateOperationsInput | number
    prescriptionId?: IntFieldUpdateOperationsInput | number
    batchId?: NullableIntFieldUpdateOperationsInput | number | null
    drugId?: IntFieldUpdateOperationsInput | number
    brandId?: IntFieldUpdateOperationsInput | number
    strategy?: EnumIssuingStrategyFieldUpdateOperationsInput | $Enums.IssuingStrategy
    quantity?: FloatFieldUpdateOperationsInput | number
    dose?: FloatFieldUpdateOperationsInput | number
    details?: NullableStringFieldUpdateOperationsInput | string | null
    meal?: NullableEnumMEALFieldUpdateOperationsInput | $Enums.MEAL | null
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
  }

  export type BufferLevelUpdateWithoutUnitConcentrationInput = {
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    bufferAmount?: IntFieldUpdateOperationsInput | number
    drug?: DrugUpdateOneRequiredWithoutBufferLevelsNestedInput
  }

  export type BufferLevelUncheckedUpdateWithoutUnitConcentrationInput = {
    id?: IntFieldUpdateOperationsInput | number
    drugId?: IntFieldUpdateOperationsInput | number
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    bufferAmount?: IntFieldUpdateOperationsInput | number
  }

  export type BufferLevelUncheckedUpdateManyWithoutUnitConcentrationInput = {
    id?: IntFieldUpdateOperationsInput | number
    drugId?: IntFieldUpdateOperationsInput | number
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    bufferAmount?: IntFieldUpdateOperationsInput | number
  }

  export type IssueCreateManyPrescriptionInput = {
    id?: number
    batchId?: number | null
    drugId: number
    brandId: number
    strategy: $Enums.IssuingStrategy
    quantity: number
    dose: number
    details?: string | null
    meal?: $Enums.MEAL | null
    type: $Enums.DrugType
    unitConcentrationId: number
  }

  export type OffRecordMedsCreateManyPrescriptionInput = {
    id?: number
    name: string
    description?: string | null
  }

  export type PrescriptionVitalsCreateManyPrescriptionInput = {
    id?: number
    vitalId: number
    value: string
  }

  export type PrescriptionChargesCreateManyPrescriptionInput = {
    id?: number
    name: string
    type: $Enums.ChargeType
    value: number
    description?: string | null
  }

  export type IssueUpdateWithoutPrescriptionInput = {
    strategy?: EnumIssuingStrategyFieldUpdateOperationsInput | $Enums.IssuingStrategy
    quantity?: FloatFieldUpdateOperationsInput | number
    dose?: FloatFieldUpdateOperationsInput | number
    details?: NullableStringFieldUpdateOperationsInput | string | null
    meal?: NullableEnumMEALFieldUpdateOperationsInput | $Enums.MEAL | null
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    batch?: BatchUpdateOneWithoutIssueNestedInput
    brand?: DrugBrandUpdateOneRequiredWithoutIssueNestedInput
    drug?: DrugUpdateOneRequiredWithoutIssueNestedInput
    unitConcentration?: UnitConcentrationUpdateOneRequiredWithoutIssueNestedInput
    stratergyHistory?: StratergyHistoryUpdateManyWithoutIssueNestedInput
  }

  export type IssueUncheckedUpdateWithoutPrescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    batchId?: NullableIntFieldUpdateOperationsInput | number | null
    drugId?: IntFieldUpdateOperationsInput | number
    brandId?: IntFieldUpdateOperationsInput | number
    strategy?: EnumIssuingStrategyFieldUpdateOperationsInput | $Enums.IssuingStrategy
    quantity?: FloatFieldUpdateOperationsInput | number
    dose?: FloatFieldUpdateOperationsInput | number
    details?: NullableStringFieldUpdateOperationsInput | string | null
    meal?: NullableEnumMEALFieldUpdateOperationsInput | $Enums.MEAL | null
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    unitConcentrationId?: IntFieldUpdateOperationsInput | number
    stratergyHistory?: StratergyHistoryUncheckedUpdateManyWithoutIssueNestedInput
  }

  export type IssueUncheckedUpdateManyWithoutPrescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    batchId?: NullableIntFieldUpdateOperationsInput | number | null
    drugId?: IntFieldUpdateOperationsInput | number
    brandId?: IntFieldUpdateOperationsInput | number
    strategy?: EnumIssuingStrategyFieldUpdateOperationsInput | $Enums.IssuingStrategy
    quantity?: FloatFieldUpdateOperationsInput | number
    dose?: FloatFieldUpdateOperationsInput | number
    details?: NullableStringFieldUpdateOperationsInput | string | null
    meal?: NullableEnumMEALFieldUpdateOperationsInput | $Enums.MEAL | null
    type?: EnumDrugTypeFieldUpdateOperationsInput | $Enums.DrugType
    unitConcentrationId?: IntFieldUpdateOperationsInput | number
  }

  export type OffRecordMedsUpdateWithoutPrescriptionInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OffRecordMedsUncheckedUpdateWithoutPrescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OffRecordMedsUncheckedUpdateManyWithoutPrescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PrescriptionVitalsUpdateWithoutPrescriptionInput = {
    value?: StringFieldUpdateOperationsInput | string
    vital?: VitalsUpdateOneRequiredWithoutPrescriptionVitalsNestedInput
  }

  export type PrescriptionVitalsUncheckedUpdateWithoutPrescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    vitalId?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
  }

  export type PrescriptionVitalsUncheckedUpdateManyWithoutPrescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    vitalId?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
  }

  export type PrescriptionChargesUpdateWithoutPrescriptionInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumChargeTypeFieldUpdateOperationsInput | $Enums.ChargeType
    value?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PrescriptionChargesUncheckedUpdateWithoutPrescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumChargeTypeFieldUpdateOperationsInput | $Enums.ChargeType
    value?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PrescriptionChargesUncheckedUpdateManyWithoutPrescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumChargeTypeFieldUpdateOperationsInput | $Enums.ChargeType
    value?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PrescriptionVitalsCreateManyVitalInput = {
    id?: number
    prescriptionId: number
    value: string
  }

  export type PrescriptionVitalsUpdateWithoutVitalInput = {
    value?: StringFieldUpdateOperationsInput | string
    prescription?: PrescriptionUpdateOneRequiredWithoutPrescriptionVitalsNestedInput
  }

  export type PrescriptionVitalsUncheckedUpdateWithoutVitalInput = {
    id?: IntFieldUpdateOperationsInput | number
    prescriptionId?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
  }

  export type PrescriptionVitalsUncheckedUpdateManyWithoutVitalInput = {
    id?: IntFieldUpdateOperationsInput | number
    prescriptionId?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
  }

  export type StratergyHistoryCreateManyIssueInput = {
    id?: number
    drugId: number
  }

  export type StratergyHistoryUpdateWithoutIssueInput = {
    drug?: DrugUpdateOneRequiredWithoutStratergyHistoryNestedInput
  }

  export type StratergyHistoryUncheckedUpdateWithoutIssueInput = {
    id?: IntFieldUpdateOperationsInput | number
    drugId?: IntFieldUpdateOperationsInput | number
  }

  export type StratergyHistoryUncheckedUpdateManyWithoutIssueInput = {
    id?: IntFieldUpdateOperationsInput | number
    drugId?: IntFieldUpdateOperationsInput | number
  }

  export type ReportValueCreateManyReportParameterInput = {
    id?: number
    attention?: boolean
    value: string
    patientReportId?: number | null
  }

  export type ReportValueUpdateWithoutReportParameterInput = {
    attention?: BoolFieldUpdateOperationsInput | boolean
    value?: StringFieldUpdateOperationsInput | string
    PatientReport?: PatientReportUpdateOneWithoutParametersNestedInput
  }

  export type ReportValueUncheckedUpdateWithoutReportParameterInput = {
    id?: IntFieldUpdateOperationsInput | number
    attention?: BoolFieldUpdateOperationsInput | boolean
    value?: StringFieldUpdateOperationsInput | string
    patientReportId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ReportValueUncheckedUpdateManyWithoutReportParameterInput = {
    id?: IntFieldUpdateOperationsInput | number
    attention?: BoolFieldUpdateOperationsInput | boolean
    value?: StringFieldUpdateOperationsInput | string
    patientReportId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PatientReportCreateManyReportTypeInput = {
    id?: number
    patientId: number
    time?: Date | string
  }

  export type ReportParameterCreateManyReportTypeInput = {
    id?: number
    name: string
    units?: string | null
  }

  export type PatientReportUpdateWithoutReportTypeInput = {
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutReportsNestedInput
    parameters?: ReportValueUpdateManyWithoutPatientReportNestedInput
  }

  export type PatientReportUncheckedUpdateWithoutReportTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    parameters?: ReportValueUncheckedUpdateManyWithoutPatientReportNestedInput
  }

  export type PatientReportUncheckedUpdateManyWithoutReportTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportParameterUpdateWithoutReportTypeInput = {
    name?: StringFieldUpdateOperationsInput | string
    units?: NullableStringFieldUpdateOperationsInput | string | null
    ReportValue?: ReportValueUpdateManyWithoutReportParameterNestedInput
  }

  export type ReportParameterUncheckedUpdateWithoutReportTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    units?: NullableStringFieldUpdateOperationsInput | string | null
    ReportValue?: ReportValueUncheckedUpdateManyWithoutReportParameterNestedInput
  }

  export type ReportParameterUncheckedUpdateManyWithoutReportTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    units?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReportValueCreateManyPatientReportInput = {
    id?: number
    reportParameterId: number
    attention?: boolean
    value: string
  }

  export type ReportValueUpdateWithoutPatientReportInput = {
    attention?: BoolFieldUpdateOperationsInput | boolean
    value?: StringFieldUpdateOperationsInput | string
    reportParameter?: ReportParameterUpdateOneRequiredWithoutReportValueNestedInput
  }

  export type ReportValueUncheckedUpdateWithoutPatientReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    reportParameterId?: IntFieldUpdateOperationsInput | number
    attention?: BoolFieldUpdateOperationsInput | boolean
    value?: StringFieldUpdateOperationsInput | string
  }

  export type ReportValueUncheckedUpdateManyWithoutPatientReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    reportParameterId?: IntFieldUpdateOperationsInput | number
    attention?: BoolFieldUpdateOperationsInput | boolean
    value?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}